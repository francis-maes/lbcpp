/*-----------------------------------------.---------------------------------.
| Filename: NQueensDepthFirstSearch.lcpp   | An example to illustrate        |
| Author  : Francis Maes                   |  depth-first search on the      |
| Started : 16/06/2009 17:19               |  states of a CRAlgorithm        |
`------------------------------------------/                                 |
                               |                                             |
                               `--------------------------------------------*/

#include <lbcpp/lbcpp.h>
#include <set>
using namespace lbcpp;

/*
** The following CR-Algorithm defines a search space for the classical "n-queens" problem.
** See http://en.wikipedia.org/wiki/Eight_queens_puzzle for more information on this problem.
*/
crAlgorithm void nQueensSearchSpace(int n)
{
  typedef std::pair<int, int> Position;
  typedef std::vector<Position> SearchNode;

  std::set<Position> freePositions;
  int i;
  for (i = 0; i < n; ++i)
    for (int j = 0; j < n; ++j)
      freePositions.insert(Position(i, j));

  SearchNode node;
  for (i = 0; i < n; ++i)
  {
    if (freePositions.empty())
      return;

    Position ithPosition = choose<Position>(freePositions);
    node.push_back(ithPosition);

    for (int j = -n; j < n; ++j)
    {
      freePositions.erase(Position(ithPosition.first + j, ithPosition.second));
      freePositions.erase(Position(ithPosition.first, ithPosition.second + j));
      freePositions.erase(Position(ithPosition.first + j, ithPosition.second + j));
      freePositions.erase(Position(ithPosition.first + j, ithPosition.second - j));
    }
  }

  reward (1.0);
}

/*
** This is the main backtracking depth first search recursive function
*/
CRAlgorithmPtr backTrackingDepthFirstSearchRec(ChoosePtr choose)
{
  jassert(choose);
  for (VariableIteratorPtr it = choose->newIterator(); it->exists(); it->next())
  {
    CRAlgorithmPtr nextState = choose->getCRAlgorithm()->cloneAndCast<CRAlgorithm>();
    double reward;
    ChoosePtr nextChoose = nextState->runUntilNextChoose(it->get(), &reward);
    if (reward > 0)
      return nextState;
    else if (nextChoose)
    {
      CRAlgorithmPtr res = backTrackingDepthFirstSearchRec(nextChoose);
      if (res)
        return res;
    }
  }
  return CRAlgorithmPtr();  
}

/*
** This function initializes backtraking depth first search
*/
CRAlgorithmPtr backTrackingDepthFirstSearch(CRAlgorithmPtr initialState)
{
  CRAlgorithmPtr state = initialState->cloneAndCast<CRAlgorithm>();
  ChoosePtr choose = state->runUntilFirstChoose();
  jassert(choose);
  return backTrackingDepthFirstSearchRec(choose);
}

int main(int argc, char* argv[])
{
  /*
  ** Solve n-queens problems with n varying from 1 to 10
  */
  for (int i = 1; i < 10; ++i)
  {
    std::cout << "Problem Size:" << i << std::endl;
    CRAlgorithmPtr initialState = nQueensSearchSpace(i);
    CRAlgorithmPtr solution = backTrackingDepthFirstSearch(initialState);
    if (solution)
      std::cout << "Solution: " << solution->toString() << std::endl;
    else
      std::cout << "No solutions" << std::endl << std::endl;
  }
  return 0;
}
