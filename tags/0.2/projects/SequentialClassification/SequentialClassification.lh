/*-----------------------------------------.---------------------------------.
| Filename: SequentialClassification.lh    | Sequential Classification       |
| Author  : Francis Maes                   |    CR-algorithm                 |
| Started : 15/03/2009 20:11               |                                 |
`------------------------------------------/                                 |
                               |                                             |
                               `--------------------------------------------*/
                               
using namespace lbcpp;

namespace lbcpp
{
  String toString(std::set<size_t>::const_iterator it)
    {return "iterator";}
};

featureGenerator describeUsedFeatureGenerators(const std::vector<  std::pair<size_t, SparseVectorPtr> >& usedFeatureGenerators)
{
  featureSense("unit");
  for (int i = 0; i < (int)usedFeatureGenerators.size(); ++i)
    featureCall(usedFeatureGenerators[i].first) usedFeatureGenerators[i].second;
}

crAlgorithm size_t sequentialClassification(FeatureGeneratorPtr compositeFeatureGenerator, double featureCosts, size_t numClasses, size_t ycorrect = (size_t)-1)
{
  typedef std::pair<bool, size_t> Choice; // decision: (true, classNumber), feature-request: (false, featureScopeNumber)
  
  std::set<size_t> unusedFeatureGenerators;
  for (size_t i = 0; i < compositeFeatureGenerator->getNumSubGenerators(); ++i)
    unusedFeatureGenerators.insert(i);
  std::vector< std::pair<size_t, SparseVectorPtr> > usedFeatureGenerators;
  String currentStateString;
  
  for (size_t step = 0; true; ++step)
  {
    std::vector<Choice> choices;
    {
      choices.reserve(unusedFeatureGenerators.size() + numClasses);
      for (std::set<size_t>::const_iterator it = unusedFeatureGenerators.begin(); it != unusedFeatureGenerators.end(); ++it)
        choices.push_back(Choice(false, *it));
      for (size_t i = 0; i < numClasses; ++i)
        choices.push_back(Choice(true, i));
    }
    
    chooseFunction double actionValues(const Choice& choice)
    {
      if (choice.first)
      {
        // decision: -1 for classification error
        // 0 otherwise
        return ycorrect != (size_t)-1 && choice.second != ycorrect ? -1 : 0;
      }
      else
      {
        // feature-request: feature-cost
          return -featureCosts;
      }
    }
    
    chooseFunction featureGenerator actionFeatures(const Choice& choice)
    {
      featureScope(currentStateString)
        if (choice.first)
        {
          featureScope(0)
            featureCall(choice.second)
              inline describeUsedFeatureGenerators(usedFeatureGenerators);
        }
        else
        {
          featureScope(1)
            featureCall(choice.second)
              inline describeUsedFeatureGenerators(usedFeatureGenerators);
        }
    }
    
    Choice c;
    if (step == 0)
      c = Choice(false, 0);
    else
    {
      c = choose<Choice>(choices, actionValues, actionFeatures);
    }
   
    if (c.first)
    {
      if (ycorrect != (size_t)-1) // reward -1 for a classification error
        reward (c.second == ycorrect ? 1.0 : -1.0);
      return c.second;
    }
    else
    {
      SparseVectorPtr newFeatures;

      jassert(unusedFeatureGenerators.find(c.second) != unusedFeatureGenerators.end());

      unusedFeatureGenerators.erase(c.second);

      newFeatures = compositeFeatureGenerator->getSubGenerator(c.second)->toSparseVector();
      usedFeatureGenerators.push_back(std::make_pair(c.second, newFeatures));
      reward (-featureCosts);

      currentStateString += "_" + lbcpp::toString(c.second);
    }
  }
  return 0;
}
