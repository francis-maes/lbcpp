#include <cmath>

using namespace lbcpp;

featureGenerator oneFeatureWithIndex() {featureSense((size_t)0, 1.0);}
featureGenerator oneFeatureWithString() {featureSense("hello", 1.0);}

featureGenerator nestedScopes() 
{
  featureScope(0) featureScope(0) featureScope(0) featureScope(0) featureSense(0);
}


inline bool isMultipleOf(size_t a, size_t b)
{
  assert(b);
  return (a % b) == 0;
}

featureGenerator numberLogFeaturesBase(const std::string& nameMin, const std::string& nameMax, double valMin, double valMax, double value)
{
  assert(value >= valMin && value <= valMax);
  double delta = valMax - valMin;
  assert(delta > 0);
  featureSense (nameMin, 1 - ((value - valMin) / delta));
  featureSense (nameMax, 1 - ((valMax - value) / delta));
}

featureGenerator numberLogFeatures(double positiveNumber)
{
  static const double clog2 = std::log10(2.0);
  static const double clog5 = std::log10(5.0);
  double l = std::log10(positiveNumber);
  double fl = floor(l);
  double frac = l - fl;
  double base = pow(10.0, fl);

  if (frac < clog2)
    featureCall numberLogFeaturesBase(lbcpp::toString(base), lbcpp::toString(2 * base), 0, clog2, frac);
  else if (frac < clog5)
    featureCall numberLogFeaturesBase(lbcpp::toString(2 * base), lbcpp::toString(5 * base), clog2, clog5, frac);
  else
    featureCall numberLogFeaturesBase(lbcpp::toString(5 * base), lbcpp::toString(10 * base), clog5, 1.0, frac);
}

featureGenerator numberFeatures(double value)
{
  if (value > 0)
    featureCall("positive") numberLogFeatures(value);
  else if (value < 0)
    featureCall("negative") numberLogFeatures(-value);
  else
    featureScope("_") featureSense("nullValue");
}

featureGenerator valueWRTTargetFeatures(int value, int target)
{
  assert(value > 0 && target > 0);
  
  featureCall("diff") numberFeatures((double)(value - target));
    
  // is value an approximate multiple of objective ?
  double k = value / (double)target;
  double distanceToMultiple = k - (int)(k + 0.5);
  featureCall("distToMultiple") numberFeatures(distanceToMultiple);

  // is value an approximate divisor of objective ?
  k = 1.0 / k;
  double distanceToDivisor = k - (int)(k + 0.5);
  featureCall("distToDivisor") numberFeatures(distanceToDivisor);
}

featureGenerator valueWRTSecondaryTargetsFeatures(int value, int targetModifier, int target)
{
  if (target > targetModifier)
    featureCall("plus") valueWRTTargetFeatures(value, target - targetModifier);
  featureCall("minus") valueWRTTargetFeatures(value, target + targetModifier);
  if (isMultipleOf(target, targetModifier))
    featureCall("times") valueWRTTargetFeatures(value, target / targetModifier);
  featureCall("divide") valueWRTTargetFeatures(value, target * targetModifier);
}


int main(int argc, char* argv[])
{
  FeatureGeneratorPtr f1 = oneFeatureWithIndex();
  std::cout << f1->getName() << std::endl;
  SparseVectorPtr v1 = f1->toSparseVector();
  std::cout << "F1: " << f1->toString() << std::endl;
  std::cout << "V1: " << v1->size() << " " << v1->toString() << std::endl;
  
  FeatureGeneratorPtr f2 = oneFeatureWithString();
  std::cout << f2->getName() << std::endl;
  std::cout << "F2: " << f2->toString() << std::endl;
  std::cout << "V2: " << f2->toSparseVector()->size() << " " << f2->toSparseVector()->toString() << std::endl;
  
  FeatureGeneratorPtr f3 = nestedScopes();
  std::cout << f3->getName() << std::endl;
  std::cout << "F3: " << std::endl << f3->toString() << std::endl;
  SparseVectorPtr v3 = f3->toSparseVector();
  std::cout << "V3: " << v3->size() << std::endl << v3->toString() << std::endl;
  
  FeatureGeneratorPtr f4 = valueWRTSecondaryTargetsFeatures(100, 906, 6);
  std::cout << "V4: " << std::endl << f4->toString() << std::endl;
  SparseVectorPtr v4 = f4->toSparseVector();
  v4->saveToFile("f4.vector");
  
  SparseVectorPtr f4loaded = Object::loadFromFileAndCast<SparseVector>("f4.vector");
  assert(f4loaded);
  f4loaded->setDictionary(f4->getDictionary());
  std::cout << "V4 Loaded: " << std::endl << f4loaded->toString() << std::endl;
  //f4loaded->substractBy(f4);
  

  DenseVectorPtr dense(new DenseVector(f4->getDictionary()));
//  dense->set(3, 51.0);
//  dense->set(5, 86.0);
  f4->addWeightedTo(dense, 5.0);
  f4->addWeightedTo(dense, 5.0);
  std::cout << "Dense: " << dense->toString() << std::endl;
  
  DenseVectorPtr dense2(new DenseVector(f4->getDictionary()));
  f4->addWeightedSignsTo(dense2, 2.0);
  std::cout << "Dense2: " << dense2->toString() << std::endl;
  
  std::cout << "size: " << dense2->size()
        << " l0 norm: " << dense2->l0norm()
        << " l1 norm: " << dense2->l1norm()
        << " dotprod: " << dense2->dotProduct(dense2)
        << " sumofsqr: " << dense2->sumOfSquares()
        << " l2 norm:" << dense2->l2norm()
        << std::endl;
        
  dense2->saveToFile("d2.vector");
  dense2 = Object::loadFromFileAndCast<DenseVector>("d2.vector");
  std::cout << "size: " << dense2->size()
        << " l0 norm: " << dense2->l0norm()
        << " l1 norm: " << dense2->l1norm()
        << " dotprod: " << dense2->dotProduct(dense2)
        << " sumofsqr: " << dense2->sumOfSquares()
        << " l2 norm:" << dense2->l2norm()
        << std::endl;
  
  return 0;
}
