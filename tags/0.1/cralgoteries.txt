=============
 LBC++ v1.0
============

General:
  -> ReferenceCountedObject, Object, ProgressCallback, ErrorManager, Random
FeatureGenerator:
  -> StringDictionary, FeatureDictionary, FeatureGenerator, FeatureVisitor, SparseVector, DenseVector
CRALGO:
  -> Variable, CRAlgorithmScope, CRAlgorithm, Choose, Policy (enlever Callback), ChooseFunctions

Taches Francis:
 * Splitter et clarifier le subset de classes
 * CMakeries
 * Papier
 * Scripts python de release
 * Site Web

Taches Guillaume:
 * License dans les fichiers
 * Documenter toutes les classes
 * Exemples, Tutorials
 * Tests

==============
 LBC++ library
==============

Gros:
  * Tables, SWIG, Doxygen, Tests

FeatureGenerator:
  * Dans EditableFeatureGenerator, mettre en virtuel addWeighted et multiplyByScalar

ContinuousFunctions:
  * Implementation optimisŽes pour Sparse vs Sparse et Dense vs Dense
  * Faire sauter impl::constant et ScalarConstant
  * ScalarDerivableArchitecturesDotProduct
  * TransferArchitecture
  * Gerer le gradientDirection/derivativeDirection partout
  * SŽrialisation et fonctions de crŽation pour les dynamiques
  * L1-norm

Optimizers:
  * LBFGS: Utiliser un LinearCombinationFeatureGenerator pour "direction"

Policy:
 * GPomdp -> ScalarVectorFunction
 * CRankPost
 * TableLogger
 * policyRun inline

LearningMachine:
  * dans le StochasticDescentLearner, options pour la frequence de l'application du regularizer

* Dictionary: peut mieux faire (creer le dictionaire ˆ la creation de la classe ou getParentDictionary) dans ScalarToVectorArchitecture::compute et dans MultiLinearArchitecture::compute

* CRAlgorithmLearner: Sarsa, QLearning, MonteCarloControl, OlPomdp, CRank


==================
 LC++ translator
==================

* gerer appel de chooseFunction depuis un autre chooseFunction ou depuis le corps du cr-algo

* ChooseArgumentsClass: generer des StateDescriptionFUnction et ActionDescriptionFunction si il n'existent pas

* PrettyPrinter: if-else: sauter a la ligne pour les deux blocs
* variable statique dans les cr-algos ?
* reference en variable locale dans un CR-algo => transformer en pointeur
* crAlgorithm: chooses inside if/switch/while/do/for/try/cases
* Faire le tri des local-scope concernŽe par les choose et n'inclure que ceux la dans la classe CR-algorithm gŽnŽrŽe
     => pas besoin de faire des ctor de copie et des toString pour tout le monde comme ca
* remettre policyRun
* Generer un operateur de stream dans chaque classe, si il n'existe pas
* cralgo-cpp: Mettre un reward par default equivalent a la premiere actionValue de chaque choose

* BUG: "featureCall inline v[index];" avec v[index] = SparseVectorPtr fait planter le translator
* BUG: plusieurs "for (size_t i)" successif => "symbol i multiply defined"

* BUG: for (size_t i) dans une chooseFunction => la resolution du i passe mal
* BUG: Une struct qui ne se finit pas par ; dans une classe => fait peter le assert(prototype) de synopsis
* BUG: => faire marcher "size_t nodeIndex = choose<size_t>(closedNodes, nodeValues);
    SearchNode& node = searchSpace.get(nodeIndex);"

ERREURS/WARNINGS:
  * Warning is le resultat d'un featureGenerator ou d'un crAlgorithm n'est pas utilise. Proposer l'utilisation de 'featureCall' ou 'crAlgorithmCall'.
  * Message d'erreur si le type d'un choice dans featureGenerator ou actionValue ne match pas le type du choose correspondant
  * Warning dans le compilo si le resultat du choose n'est pas utilise
  * Error: "using local variable in cr-algorithm reference", si on a un "cralgo void toto(int& i)" et qu'on appelle "int i; return toto(i);" 
  * Si on instancie une classe dont le compiler connait la definition, checker qu'il y a bien un operator de stream

GROS:
 * clarifier les CRAlgoVisitor
 * crAlgorithmCall
 * gestion des options
