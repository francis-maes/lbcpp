/*-----------------------------------------.---------------------------------.
| Filename: crOrderFreeGraphLabeling.lh    | OrderFree Graph Labeling        |
| Author  : Francis Maes                   |                                 |
| Started : 26/03/2009 20:37               |                                 |
`------------------------------------------/                                 |
                               |                                             |
                               `--------------------------------------------*/

#include "LabeledContentGraph.lh"

namespace lbcpp
{

typedef std::pair<size_t, size_t> PositionAndLabel;

inline void addLabelsForPosition(size_t position, size_t numLabels, std::vector<PositionAndLabel>& res)
{
  for (size_t i = 0; i < numLabels; ++i)
    res.push_back(PositionAndLabel(position, i));
}

inline void addUnlabeledNeighboorhood(LabeledContentGraphPtr graph, size_t foldBegin, size_t foldEnd, size_t nodeIndex, const std::set<size_t>& unlabeledNodes, std::vector<PositionAndLabel>& res)
{
  size_t numLabels = graph->getLabelDictionary()->getNumElements();
  size_t j, n;
  
  n = graph->getNumSuccessors(nodeIndex);
  for (j = 0; j < n; ++j)
  {
    size_t succ = graph->getSuccessor(nodeIndex, j);
    if (succ >= foldBegin && succ < foldEnd && unlabeledNodes.find(succ) != unlabeledNodes.end())
      addLabelsForPosition(succ, numLabels, res);
  }
  n = graph->getNumPredecessors(nodeIndex);
  for (j = 0; j < n; ++j)
  {
    size_t pred = graph->getPredecessor(nodeIndex, j);
    if (pred >= foldBegin && pred < foldEnd && unlabeledNodes.find(pred) != unlabeledNodes.end())
      addLabelsForPosition(pred, numLabels, res);
  }
}

crAlgorithm LabelSequencePtr onePassOrderFreeGraphLabeling(LabeledContentGraphPtr graph, size_t foldBegin, size_t foldEnd, size_t numNodesWhenLost = 20)
{
  LabelSequencePtr prediction = new LabelSequence(*graph->getLabels());
  LabeledContentGraphPtr predictedGraph = new LabeledContentGraph(graph->getContentGraph(), prediction);
  size_t numLabels = graph->getLabelDictionary()->getNumElements();
  
  chooseFunction featureGenerator contentAndStructureActionFeatures(const PositionAndLabel& positionAndLabel)
  {
    featureCall(positionAndLabel.second)
      inline predictedGraph->nodeAndNeighborhoodLabelsFrequencyFeatures(positionAndLabel.first);
  }
  
  chooseFunction double actionValueFunction(const PositionAndLabel& positionAndLabel)
    {return graph->getLabels()->get(positionAndLabel.first) == positionAndLabel.second ? 1.0 : 0.0;}

  // unlabeled nodes
  std::set<size_t> unlabeledNodes;
  size_t i;
  for (i = foldBegin; i < foldEnd; ++i)
    unlabeledNodes.insert(i);
  
  // order-free classification
  int lastLabeledNode = -1;
  for (i = 0; i < foldEnd - foldBegin; ++i)
  {
    std::vector<PositionAndLabel> choices;
    choices.clear();
    if (lastLabeledNode >= 0)
      addUnlabeledNeighboorhood(predictedGraph, foldBegin, foldEnd, (size_t)lastLabeledNode, unlabeledNodes, choices);
    if (choices.empty())
    {
      std::set<size_t>::iterator it = unlabeledNodes.begin();
      while (choices.size() < numNodesWhenLost * numLabels)
      {
        if (it == unlabeledNodes.end())
          break;
        addLabelsForPosition(*it, numLabels, choices);
        ++it;
      }
    }
    jassert(choices.size());
    
    PositionAndLabel positionAndLabel = choose<PositionAndLabel>(choices, actionValueFunction, contentAndStructureActionFeatures);
    //std::cout << lbcpp::toString(positionAndLabel) << " | " << std::flush;
    jassert(positionAndLabel.first >= foldBegin && positionAndLabel.second < foldEnd);
    if (positionAndLabel.second == graph->getLabel(positionAndLabel.first))
      reward (1.0);
    predictedGraph->setLabel(positionAndLabel.first, positionAndLabel.second);
    lastLabeledNode = positionAndLabel.first;
    unlabeledNodes.erase(positionAndLabel.first);
  }
  //std::cout << std::endl;
  jassert(unlabeledNodes.size() == 0);
  return prediction;
}

}; /* namespace lbcpp */
