/*-----------------------------------------.---------------------------------.
| Filename: InterdependantVariableSet.lh   | Set of interdependant varibles  |
| Author  : Francis Maes                   |                                 |
| Started : 28/03/2010 15:02               |                                 |
`------------------------------------------/                                 |
                               |                                             |
                               `--------------------------------------------*/

namespace lbcpp
{

class InterdependantVariableSet : public Object
{
public:
  enum VariableType
  {
    discreteVariable,
    numericVariable
  };

  virtual VariableType getVariablesType() const = 0;
  virtual size_t getNumVariables() const = 0;
  virtual FeatureGeneratorPtr computeVariableFeatures(size_t index) const = 0;

  /*
  ** Discrete variables
  */
  virtual bool getVariable(size_t index, size_t& result) const
    {jassert(false); return false;}

  virtual void setVariable(size_t index, size_t value) const
    {jassert(false);}

  virtual StringDictionaryPtr getVariablesDictionary() const
    {jassert(false); return StringDictionaryPtr();}

  /*
  ** Numeric variables
  */
  virtual bool getVariable(size_t index, double& result) const
    {jassert(false); return false;}

  virtual void setVariable(size_t index, double value) const
    {jassert(false);}
};

typedef ReferenceCountedObjectPtr<InterdependantVariableSet> InterdependantVariableSetPtr;

//////// Features ///////////

class VariableFeatureFunction : public Object
{
public:
  virtual size_t getNumVariables() const = 0;
  virtual FeatureGeneratorPtr computeFeatures(size_t variableIndex) const = 0; 
};

typedef ReferenceCountedObjectPtr<VariableFeatureFunction> VariableFeatureFunctionPtr;

class UnionVariableFeatureFunction : public VariableFeatureFunction
{
public:
  UnionVariableFeatureFunction(VariableFeatureFunctionPtr f1 = VariableFeatureFunctionPtr(),
                               VariableFeatureFunctionPtr f2 = VariableFeatureFunctionPtr(),
                               VariableFeatureFunctionPtr f3 = VariableFeatureFunctionPtr(),
                               VariableFeatureFunctionPtr f4 = VariableFeatureFunctionPtr(),
                               VariableFeatureFunctionPtr f5 = VariableFeatureFunctionPtr())
  {
    if (f1) addFeatureFunction(f1);
    if (f2) addFeatureFunction(f2);
    if (f3) addFeatureFunction(f3);
    if (f4) addFeatureFunction(f4);
    if (f5) addFeatureFunction(f5);
  }

  void addFeatureFunction(VariableFeatureFunctionPtr f)
  {
    jassert(subFeatures.empty() || subFeatures[0]->getNumVariables() == f->getNumVariables());
    subFeatures.push_back(f);
  }

  virtual size_t getNumVariables() const
    {return subFeatures.size() ? subFeatures[0]->getNumVariables() : 0;}

  virtual featureGenerator computeFeatures(size_t variableIndex) const
  {
    for (size_t i = 0; i < subFeatures.size(); ++i)
      featureCall(i) subFeatures[i]->computeFeatures(variableIndex);
  }

private:
  std::vector<VariableFeatureFunctionPtr> subFeatures;
};

class ContentOnlyVariableFeatureFunction : public VariableFeatureFunction
{
public:
  ContentOnlyVariableFeatureFunction(InterdependantVariableSetPtr variables)
    : variables(variables) {}

  virtual size_t getNumVariables() const
    {return variables->getNumVariables();}

  virtual FeatureGeneratorPtr computeFeatures(size_t variableIndex) const
    {return variables->computeVariableFeatures(variableIndex);}

private:
  InterdependantVariableSetPtr variables;
};

class WindowVariableFeatureFunction : public VariableFeatureFunction
{
public:
  WindowVariableFeatureFunction(VariableFeatureFunctionPtr subFeatures, size_t numPrevious, size_t numNexts, bool includeCurrent)
    : subFeatures(subFeatures), numPrevious(numPrevious), numNexts(numNexts), includeCurrent(includeCurrent) {}

  virtual size_t getNumVariables() const
    {return subFeatures->getNumVariables();}

  virtual featureGenerator computeFeatures(size_t variableIndex) const
  {
    featureScope("previous")
    {
      for (size_t i = 0; i < numPrevious; ++i)
      {
        int index = (int)variableIndex - (int)i - 1;
        if (index >= 0)
          featureCall(i) subFeatures->computeFeatures((size_t)index);
        else
          featureScope(i) featureSense("N/A");
      }
    }
    if (includeCurrent)
      featureCall("current") subFeatures->computeFeatures(variableIndex);
    featureScope("nexts")
    {
      for (size_t i = 0; i < numNexts; ++i)
      {
        size_t index = variableIndex + i + 1;
        if (index < this->getNumVariables())
          featureCall(i) subFeatures->computeFeatures((size_t)index);
        else
          featureScope(i) featureSense("N/A");
      }
    }
  }

protected:
  VariableFeatureFunctionPtr subFeatures;
  size_t numPrevious, numNexts;
  bool includeCurrent;
};

/////////// LearningExample /////////////

class InterdependantVariableSetExample : public LearningExample
{
public:
  InterdependantVariableSetExample(VariableFeatureFunctionPtr inputFeatures, InterdependantVariableSetPtr targetVariables)
    : inputFeatures(inputFeatures), targetVariables(targetVariables) {}

  void createClassificationExamples(ObjectConsumerPtr target)
  {
    jassert(inputFeatures->getNumVariables() == targetVariables->getNumVariables());
    jassert(targetVariables->getVariablesType() == InterdependantVariableSet::discreteVariable);

    size_t n = targetVariables->getNumVariables();
    for (size_t i = 0; i < n; ++i)
    {
      size_t value;
      if (targetVariables->getVariable(i, value))
        target->consume(new ClassificationExample(inputFeatures->computeFeatures(i), value));
    }
  }

  InterdependantVariableSetPtr getTargetVariables() const
    {return targetVariables;}

private:
  VariableFeatureFunctionPtr inputFeatures;
  InterdependantVariableSetPtr targetVariables;
};

typedef ReferenceCountedObjectPtr<InterdependantVariableSetExample> InterdependantVariableSetExamplePtr;

}; /* namespace lbcpp */
