/*-----------------------------------------.---------------------------------.
| Filename: AttributeValueSandBox.cpp      | Attribute Value Representation  |
| Author  : Francis Maes                   |                                 |
| Started : 24/06/2010 11:09               |                                 |
`------------------------------------------/                                 |
                               |                                             |
                               `--------------------------------------------*/

#include <lbcpp/lbcpp.h>
#include "Protein/Data/Protein.h" 
using namespace lbcpp;

extern void declareLBCppCoreClasses();
extern void declareProteinClasses();

void printVariableLine(const Variable& value, std::ostream& ostr, size_t variableNumber, const String& name, int currentDepth)
{
  for (int i = 0; i < currentDepth; ++i)
    ostr << "  ";
  if (variableNumber != (size_t)-1)
    ostr << "[" << variableNumber << "] ";
  ostr << value.getTypeName();
  if (name.isNotEmpty())
    ostr << " " << name;
  String v = value.toString();
  if (v.length() > 30)
    v = v.substring(0, 30) + T("...");
  ostr << " = " << v << std::endl;
}

void printVariablesRecursively(const Variable& variable, std::ostream& ostr, int maxDepth, int currentDepth)
{
  if (maxDepth >= 0 && currentDepth >= maxDepth)
    return;
  TypePtr type = variable.getType();
  for (size_t i = 0; i < variable.size(); ++i)
  {
    String name;
    if (i < type->getNumStaticVariables())
      name = type->getStaticVariableName(i);
    printVariableLine(variable[i], ostr, i, name, currentDepth);
    printVariablesRecursively(variable[i], ostr, maxDepth, currentDepth + 1);
  }
}

void printVariable(const Variable& variable, std::ostream& ostr, int maxDepth = -1)
{
  printVariableLine(variable, ostr, (size_t)-1, String::empty, 0);
  printVariablesRecursively(variable, ostr, maxDepth, 1);
}

///////////////

class ResidueRepresentation : public CompositeRepresentation
{
public:
  virtual TypePtr getInputType() const
    {return pairType(proteinClass(), integerType());}
};

//////////////////////////////////////////
//////////////////////////////////////////
//////// FeatureGenerator ////////////////
//////////////////////////////////////////
//////////////////////////////////////////

featureGenerator enumerationFeatures(const Variable& value)
{
  jassert(value.isInteger());
  featureSense(value.getInteger());
}

//////////////////////////////////////////
//////////////////////////////////////////
//////// Inference ///////////////////////
//////////////////////////////////////////
//////////////////////////////////////////

class SharedParallelContainerInference : public SharedParallelInference
{
public:
  SharedParallelContainerInference(const String& name, InferencePtr subInference)
    : SharedParallelInference(name, subInference)
    {setBatchLearner(simulationInferenceLearner());}
  
  SharedParallelContainerInference() {}
  
  virtual size_t getNumSubInferences(const Variable& input) const = 0;
  virtual ContainerPtr getSupervisionTargets(const Variable& supervision) const = 0;
  virtual Variable getSubInput(const Variable& input, size_t index) const = 0;

  virtual Variable createOutput(const Variable& input) const = 0;
  virtual void addResultToOutput(Variable& output, size_t index, const Variable& subInferenceOutput) const = 0;

  virtual ParallelInferenceStatePtr prepareInference(InferenceContextPtr context, const Variable& input, const Variable& supervision, ReturnCode& returnCode)
  {
    size_t n = getNumSubInferences(input);

    ContainerPtr supervisionTargets;
    if (supervision)
    {
      supervisionTargets = getSupervisionTargets(supervision);
      jassert(supervisionTargets->size() == n);
    }

    ParallelInferenceStatePtr res = new ParallelInferenceState(input, supervision);
    res->reserve(n);
    if (supervisionTargets)
      for (size_t i = 0; i < n; ++i)
        res->addSubInference(subInference, getSubInput(input, i), supervisionTargets->getVariable(i));
    else
      for (size_t i = 0; i < n; ++i)
        res->addSubInference(subInference, getSubInput(input, i), Variable());
    return res;
  }

  virtual Variable finalizeInference(InferenceContextPtr context, ParallelInferenceStatePtr state, ReturnCode& returnCode)
  {
    Variable res;
    size_t n = state->getNumSubInferences();
    for (size_t i = 0; i < n; ++i)
    {
      Variable subOutput = state->getSubOutput(i);
      if (subOutput)
      {
        if (!res)
          res = createOutput(state->getInput());
        addResultToOutput(res, i, subOutput);
      }
    }
    return res;
  }
};

class ProteinSequenceInference : public SharedParallelContainerInference
{
public:
  ProteinSequenceInference(const String& targetName, InferencePtr elementInference, FunctionPtr representation)
    : SharedParallelContainerInference(targetName, elementInference), representation(representation)
  {
    int index = proteinClass()->findStaticVariable(targetName);
    jassert(index >= 0);
    targetIndex = (size_t)index;
  }

  virtual size_t getNumSubInferences(const Variable& input) const
    {return input.getObjectAndCast<Protein>()->getLength();}

  virtual ContainerPtr getSupervisionTargets(const Variable& supervision) const
    {return supervision[targetIndex].getObjectAndCast<Container>();}

  virtual Variable getSubInput(const Variable& input, size_t index) const
  {return representation->compute(Variable::pair(input[targetIndex], index));}

  virtual Variable createOutput(const Variable& input) const
    {return input.getObjectAndCast<Protein>()->createEmptyTarget(targetIndex);}

  virtual void addResultToOutput(Variable& output, size_t index, const Variable& subInferenceOutput) const
    {output.getObject()->setVariable(index, subInferenceOutput);}

protected:
  size_t targetIndex;
  FunctionPtr representation;
};

class ProteinSequentialInference : public VectorSequentialInference
{
public:
  ProteinSequentialInference() : VectorSequentialInference(T("Protein")) {}
};

///////////////////////////////////////// 

class ProteinInferenceFactory : public Object
{
public:
  ProteinInferenceFactory() : proteinClass(lbcpp::proteinClass()) {}

  virtual InferencePtr createInference(const String& targetName) const
    {return addToProteinInference(createTargetInference(targetName), targetName);}

  virtual InferencePtr createTargetInference(const String& targetName) const
  {
    if (targetName == T("secondaryStructure") || targetName == T("dsspSecondaryStructure")
          || targetName == T("structuralAlphabetSequence"))
      return createSequenceLabelingInference(targetName);
    jassert(false);
    return InferencePtr();
  }

  virtual InferencePtr createSequenceLabelingInference(const String& targetName) const
  {
    TypePtr targetType = getTargetType(targetName);
    EnumerationPtr elementsType = targetType->getTemplateArgument(0).dynamicCast<Enumeration>();
    jassert(elementsType);
    return InferencePtr(new ProteinSequenceInference(targetName,
      createMultiClassClassifier(targetName, elementsType),
      createRepresentation(targetName, true, false)));
  }

  virtual FunctionPtr createRepresentation(const String& targetName, bool is1DTarget, bool is2DTarget) const = 0;
  virtual InferencePtr createBinaryClassifier(const String& targetName) const = 0;
  virtual InferencePtr createMultiClassClassifier(const String& targetName, EnumerationPtr classes) const = 0;

protected:
  ClassPtr proteinClass;

  size_t getTargetIndex(const String& targetName) const
  {
    int targetIndex = proteinClass->findStaticVariable(targetName);
    jassert(targetIndex >= 0);
    return (size_t)targetIndex;
  }

  TypePtr getTargetType(const String& targetName) const
    {return proteinClass->getStaticVariableType(getTargetIndex(targetName));}

  InferencePtr addToProteinInference(InferencePtr targetInference, const String& targetName) const
    {return postProcessInference(targetInference, setFieldFunction(getTargetIndex(targetName)));}
};


///////////////////////////////////////// 

bool canSubVariableBePruned(const Variable& subVariable)
{
  if (subVariable.getType()->inheritsFrom(probabilityType()))
    return subVariable.getDouble() == 0.0;
  return false;
}

featureGenerator variableFeatures(const Variable& variable)
{
  if (variable.isNil())
  {
    featureSense(T("Nil"));
    return;
  }
  else if (variable.isMissingValue())
  {
    featureSense(T("Missing"));
    return;
  }
  
  TypePtr type = variable.getType();

  if (variable.isEnumeration())
  {
    EnumerationPtr enumeration = type.dynamicCast<Enumeration>();
    jassert(enumeration);
    featureSense(enumeration->getElementName(variable.getInteger()));
    return;
  }

  if (type->inheritsFrom(objectClass()))
  {
    ObjectPtr object = variable.getObject();
    size_t n = object->getNumVariables(); 
    for (size_t i = 0; i < n; ++i)
    {
      Variable subVariable = object->getVariable(i);
      if (!canSubVariableBePruned(subVariable))
        featureCall(object->getVariableName(i)) variableFeatures(subVariable);
    }
    return;
  }

  if (type == probabilityType())
  {
    featureSense(T("Value"), variable.getDouble());
    return;
  }

  jassert(false);
}

FeatureGeneratorPtr representationToFeatures(RepresentationPtr representation, const Variable& input)
{
  size_t n = representation->getNumOutputVariables();
  ObjectPtr object = representation->compute(input);
  return variableFeatures(object);
}

class RepresentationToFeaturesFunction : public Function
{
public:
  RepresentationToFeaturesFunction(RepresentationPtr representation)
    : representation(representation) {}
 
  virtual TypePtr getInputType() const
    {return representation->getInputType();}

  virtual TypePtr getOutputType(TypePtr inputType) const
    {return Class::get(T("FeatureGenerator"));}

protected:
  RepresentationPtr representation;

  virtual Variable computeFunction(const Variable& input, ErrorHandler& callback) const
    {return representationToFeatures(representation, input);}
};

///////////////////////////////////////// 

class MyProteinInferenceFactory : public ProteinInferenceFactory
{
public:
  RepresentationPtr createDiscreteProbabilityDistributionRepresentation(EnumerationPtr enumeration) const
  {
    return RepresentationPtr();
  }

  virtual FunctionPtr createRepresentation(const String& targetName, bool is1DTarget, bool is2DTarget) const
  {
    if (is1DTarget)
    {
      CompositeRepresentationPtr res = new ResidueRepresentation();

      FunctionPtr selectPrimaryStructure = selectPairFieldsFunction(proteinClass->findStaticVariable(T("primaryStructure")));
      FunctionPtr selectPSSM = selectPairFieldsFunction(proteinClass->findStaticVariable(T("positionSpecificScoringMatrix")));

      res->addRepresentation(T("AA"), Representation::compose(selectPrimaryStructure,
        vectorWindowRepresentation(aminoAcidTypeEnumeration(), 15)));
      res->addRepresentation(T("PSSM"), Representation::compose(selectPSSM,
        vectorWindowRepresentation(discreteProbabilityDistributionClass(aminoAcidTypeEnumeration()), 15)));
      return new RepresentationToFeaturesFunction(res);
    }
    jassert(false);
    return FunctionPtr();
  }
  
public:
  virtual InferencePtr createBinaryClassifier(const String& targetName) const
    {return binaryLinearSVMInference(createOnlineLearner(targetName + T(" Learner")), targetName + T(" Classifier"));}

  virtual InferencePtr createMultiClassClassifier(const String& targetName, EnumerationPtr classes) const
  {
    InferencePtr binaryClassifier = createBinaryClassifier(targetName);
    return oneAgainstAllClassificationInference(targetName, classes, binaryClassifier);
  }

protected:
  InferenceOnlineLearnerPtr createOnlineLearner(const String& targetName, double initialLearningRate = 1.0) const
  {
    StoppingCriterionPtr stoppingCriterion = maxIterationsStoppingCriterion(10);/*logicalOr(
      maxIterationsStoppingCriterion(100),  
      maxIterationsWithoutImprovementStoppingCriterion(1));*/

    if (targetName.startsWith(T("contactMap")))
      return gradientDescentInferenceOnlineLearner(
        InferenceOnlineLearner::perEpisode,                                                 // randomization
        InferenceOnlineLearner::perStep, invLinearIterationFunction(initialLearningRate, 100000), true, // learning steps
        InferenceOnlineLearner::perStepMiniBatch20, sumOfSquaresFunction(0.0),         // regularizer
        InferenceOnlineLearner::perPass, stoppingCriterion, true);                     // stopping criterion
    else
      return gradientDescentInferenceOnlineLearner(
        InferenceOnlineLearner::never,                                                 // randomization
        InferenceOnlineLearner::perStep, invLinearIterationFunction(initialLearningRate, 10000), true, // learning steps
        InferenceOnlineLearner::perStepMiniBatch20, sumOfSquaresFunction(0.0),         // regularizer
        InferenceOnlineLearner::perPass, stoppingCriterion, true);                     // stopping criterion
  }
};

///////////////////////////////////////// 

VectorPtr loadProteins(const File& directory, size_t maxCount = 0)
{
#ifdef JUCE_DEBUG
  if (!maxCount) maxCount = 7;
#endif // JUCE_DEBUG
  return directoryFileStream(directory)->apply(loadFromFileFunction())->load(maxCount);
}

// todo: Class::declare(new IntegerType(T("SequenceSeparationDistance"), integerType()));
TypePtr sequenceSeparationDistanceType()
  {return integerType();} // FIXME

class ProteinLengthRepresentation : public Representation
{
public:
  virtual size_t getNumOutputVariables() const
    {return 1;}

  virtual TypePtr getOutputVariableType(size_t index) const
    {return sequenceSeparationDistanceType();}

  virtual String getOutputVariableName(size_t index) const
    {return T("proteinLength");}

  virtual void computeRepresentation(const Variable& input, RepresentationCallbackPtr callback) const
    {callback->sense(0, input.getObjectAndCast<Protein>()->getLength());}
};

int main(int argc, char** argv)
{
  lbcpp::initialize();
  declareProteinClasses();
  
  File workingDirectory(T("C:\\Projets\\LBC++\\projects\\temp"));
  //File workingDirectory(T("/Users/francis/tmp"));

  VectorPtr proteins = loadProteins(workingDirectory.getChildFile(T("SmallPDB\\xml")));
  std::cout << proteins->size() << " proteins" << std::endl;

  //PrintRepresentationCallback::print(proteins->getVariable(2), std::cout, 2);

  // make representation
  CompositeRepresentationPtr representation = new ResidueRepresentation();

  FunctionPtr selectPrimaryStructure = selectPairFieldsFunction(proteinClass()->findStaticVariable(T("primaryStructure")));
  FunctionPtr selectPSSM = selectPairFieldsFunction(proteinClass()->findStaticVariable(T("positionSpecificScoringMatrix")));

  representation->addRepresentation(T("AA"), Representation::compose(selectPrimaryStructure,
    vectorWindowRepresentation(aminoAcidTypeEnumeration(), 15)));
  representation->addRepresentation(T("PSSM"), Representation::compose(selectPSSM,
    vectorWindowRepresentation(discreteProbabilityDistributionClass(aminoAcidTypeEnumeration()), 15)));

  std::cout << "Representation output class: " << representation->getOutputType()->toString() << std::endl;

  RepresentationPtr flatRepresentation = representation->flatten();

  std::cout << "Flat Representation output class: " << flatRepresentation->getOutputType()->toString() << std::endl;

  // make secondary structure classification examples
  VectorPtr secondaryStructureExamples = new Vector(pairType(
      flatRepresentation->getOutputType(),
      secondaryStructureElementEnumeration()));
  for (size_t i = 0; i < proteins->size(); ++i)
  {
    ProteinPtr protein = proteins->getVariable(i).getObjectAndCast<Protein>();
    jassert(protein);
    size_t n = protein->getLength();
    VectorPtr secondaryStructure = protein->getSecondaryStructure();
    for (size_t j = 0; j < n; ++j)
    {
      Variable input = flatRepresentation->compute(Variable::pair(protein, j));
      //std::cout << "Representation of : " << protein->getName() << " " << j << ": "
      //    << std::endl << representation->compute(Variable::pair(protein, j)) << std::endl;
      //std::cout << "    Flat : " << input << std::endl;
      //printVariable(input, std::cout, 3);
      //std::cout << std::endl << std::endl << std::endl;
      Variable output = secondaryStructure->getVariable(j);
      secondaryStructureExamples->append(Variable::pair(input, output));
    }
  }

  {
    Variable anExampleInput = secondaryStructureExamples->getVariable(10)[0];
    printVariable(anExampleInput, std::cout, 3);
    FeatureGeneratorPtr anExampleFeatures = variableFeatures(anExampleInput)->toSparseVector();
    std::cout << "Features: " << anExampleFeatures->toString() << std::endl;
  }
  exit(0);

  

  // make train and test set
  ContainerPtr data = secondaryStructureExamples->randomize();
  ContainerPtr trainingData = data->fold(0, 2);
  ContainerPtr testingData = data->fold(1, 2);
  std::cout << "Training Data: " << trainingData->size() << " Testing Data: " << testingData->size() << std::endl;

  // train
  InferencePtr inference = extraTreeInference(T("SS3"), 2, 15);
  InferenceContextPtr context = singleThreadedInferenceContext();
  context->train(inference, trainingData);

  // evaluate
  EvaluatorPtr evaluator = classificationAccuracyEvaluator(T("SS3"));
  context->evaluate(inference, trainingData, evaluator);
  std::cout << "Train: " << evaluator->toString() << std::endl;

  evaluator = classificationAccuracyEvaluator(T("SS3"));
  context->evaluate(inference, testingData, evaluator);
  std::cout << "Test: " << evaluator->toString() << std::endl;
  return 0;
}
