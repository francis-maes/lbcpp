/*-----------------------------------------.---------------------------------.
| Filename: AttributeValueSandBox.cpp      | Attribute Value Perception      |
| Author  : Francis Maes                   |                                 |
| Started : 24/06/2010 11:09               |                                 |
`------------------------------------------/                                 |
                               |                                             |
                               `--------------------------------------------*/

#include <lbcpp/lbcpp.h>
#include "Data/Protein.h" 
#include "Inference/ProteinInferenceFactory.h"
#include "Inference/ProteinInference.h"
#include "Evaluator/ProteinEvaluator.h"
using namespace lbcpp;

extern void declareLBCppCoreClasses();
extern void declareProteinClasses();

void printVariableLine(const Variable& value, std::ostream& ostr, size_t variableNumber, const String& name, int currentDepth)
{
  for (int i = 0; i < currentDepth; ++i)
    ostr << "  ";
  if (variableNumber != (size_t)-1)
    ostr << "[" << variableNumber << "] ";
  ostr << value.getTypeName();
  if (name.isNotEmpty())
    ostr << " " << name;
  String v = value.toString();
  if (v.length() > 30)
    v = v.substring(0, 30) + T("...");
  ostr << " = " << v << std::endl;
}

void printVariablesRecursively(const Variable& variable, std::ostream& ostr, int maxDepth, int currentDepth)
{
  if (maxDepth >= 0 && currentDepth >= maxDepth)
    return;
  TypePtr type = variable.getType();
  for (size_t i = 0; i < variable.size(); ++i)
  {
    String name;
    if (i < type->getNumStaticVariables())
      name = type->getStaticVariableName(i);
    printVariableLine(variable[i], ostr, i, name, currentDepth);
    printVariablesRecursively(variable[i], ostr, maxDepth, currentDepth + 1);
  }
}

void printVariable(const Variable& variable, std::ostream& ostr, int maxDepth = -1)
{
  printVariableLine(variable, ostr, (size_t)-1, String::empty, 0);
  printVariablesRecursively(variable, ostr, maxDepth, 1);
}
//////////////////////////////////////////
//////////////////////////////////////////
//////// Perception //////////////////////
//////////////////////////////////////////
//////////////////////////////////////////

class ResidueCompositePerception : public CompositePerception
{
public:
  virtual TypePtr getInputType() const
    {return pairType(proteinClass(), integerType());}
};

// todo: Class::declare(new IntegerType(T("SequenceSeparationDistance"), integerType()));
TypePtr sequenceSeparationDistanceType()
  {return integerType();} // FIXME

class ProteinLengthRepresentation : public Perception
{
public:
  virtual size_t getNumOutputVariables() const
    {return 1;}

  virtual TypePtr getOutputVariableType(size_t index) const
    {return sequenceSeparationDistanceType();}

  virtual String getOutputVariableName(size_t index) const
    {return T("proteinLength");}

  virtual void computePerception(const Variable& input, PerceptionCallbackPtr callback) const
    {callback->sense(0, input.getObjectAndCast<Protein>()->getLength());}
};

//////////////////////////////////////////
//////////////////////////////////////////
//// FeatureGenerators compatibility /////
//////////////////////////////////////////
//////////////////////////////////////////
/*
class FeatureGeneratorFactory : public Function
{
public:
  virtual TypePtr getInput() const
    {return perceptionClass();}

  virtual TypePtr getOutput(TypePtr ) const
    {return Class::get(T("FeatureGenerator"));}

  virtual Variable computeFunction(const Variable& input, ErrorHandler& callback) const
  {
    PerceptionPtr perception = input.getObjectAndCast<Perception>(callback);
    if (!perception)
      return Variable();
    
    size_t n = perception->getNumOutputVariables();

    CompositeFeatureGeneratorPtr res = new CompositeFeatureGenerator();
    
    res->appendSubGenerator(
  }

};


*/
bool canSubVariableBePruned(const Variable& subVariable)
{
  if (subVariable.getType()->inheritsFrom(probabilityType()))
    return subVariable.getDouble() == 0.0;
  return false;
}

featureGenerator variableFeatures(Variable variable)
{
  if (variable.isNil())
  {
    featureSense(0);
    return;
  }
  else if (variable.isMissingValue())
  {
    featureSense(2);
    return;
  }
  
  TypePtr type = variable.getType();

  if (type == probabilityType())
  {
    featureSense(2, variable.getDouble());
    return;
  }

  if (variable.isEnumeration())
  {
    EnumerationPtr enumeration = type.dynamicCast<Enumeration>();
    jassert(enumeration);
    featureSense(2 + variable.getInteger());
    return;
  }

  if (type->inheritsFrom(objectClass()))
  {
    ObjectPtr object = variable.getObject();
    size_t n = object->getNumVariables(); 
    for (size_t i = 0; i < n; ++i)
    {
      Variable subVariable = object->getVariable(i);
      if (!canSubVariableBePruned(subVariable))
        featureCall(i) variableFeatures(subVariable);
    }
    return;
  }

  jassert(false);
}

FeatureGeneratorPtr representationToFeatures(PerceptionPtr representation, const Variable& input)
{
  ObjectPtr object = representation->compute(input);
  return variableFeatures(object);
}

class RepresentationToFeaturesFunction : public Function
{
public:
  RepresentationToFeaturesFunction(PerceptionPtr representation)
    : representation(representation) {}
 
  virtual TypePtr getInputType() const
    {return representation->getInputType();}

  virtual TypePtr getOutputType(TypePtr inputType) const
    {return Class::get(T("FeatureGenerator"));}

protected:
  PerceptionPtr representation;

  virtual Variable computeFunction(const Variable& input, ErrorHandler& callback) const
    {return representationToFeatures(representation, input);}
};


//////////////////////////////////////////
//////////////////////////////////////////
//////// Inference ///////////////////////
//////////////////////////////////////////
//////////////////////////////////////////

void declareNewProteinInferenceClasses()
{
  LBCPP_DECLARE_CLASS(ResidueCompositePerception, CompositePerception);
}

///////////////////////////////////////// 
///////////////////////////////////////// 
///////////////////////////////////////// 

class MyProteinInferenceFactory : public ProteinInferenceFactory
{
public:
  PerceptionPtr createDiscreteProbabilityDistributionRepresentation(EnumerationPtr enumeration) const
  {
    return PerceptionPtr();
  }

  virtual FunctionPtr createPerception(const String& targetName, bool is1DTarget, bool is2DTarget) const
  {
    if (is1DTarget)
    {
      CompositePerceptionPtr res = new ResidueCompositePerception();

      FunctionPtr selectPrimaryStructure = selectPairFieldsFunction(proteinClass->findStaticVariable(T("primaryStructure")));
      FunctionPtr selectPSSM = selectPairFieldsFunction(proteinClass->findStaticVariable(T("positionSpecificScoringMatrix")));

      res->addPerception(T("AA"), Perception::compose(selectPrimaryStructure,
        windowPerception(aminoAcidTypeEnumeration(), 15)));
      res->addPerception(T("PSSM"), Perception::compose(selectPSSM,
        windowPerception(discreteProbabilityDistributionClass(aminoAcidTypeEnumeration()), 15)));
      return new RepresentationToFeaturesFunction(res);
    }
    jassert(false);
    return FunctionPtr();
  }
  
public:
  virtual InferencePtr createBinaryClassifier(const String& targetName) const
    {return binaryLinearSVMInference(createOnlineLearner(targetName + T(" Learner")), targetName + T(" Classifier"));}

  virtual InferencePtr createMultiClassClassifier(const String& targetName, EnumerationPtr classes) const
  {
    InferencePtr binaryClassifier = createBinaryClassifier(targetName);
    return oneAgainstAllClassificationInference(targetName, classes, binaryClassifier);
  }

protected:
  InferenceOnlineLearnerPtr createOnlineLearner(const String& targetName, double initialLearningRate = 1.0) const
  {
    StoppingCriterionPtr stoppingCriterion = maxIterationsStoppingCriterion(10);/*logicalOr(
      maxIterationsStoppingCriterion(100),  
      maxIterationsWithoutImprovementStoppingCriterion(1));*/

    if (targetName.startsWith(T("contactMap")))
      return gradientDescentInferenceOnlineLearner(
        InferenceOnlineLearner::perEpisode,                                                 // randomization
        InferenceOnlineLearner::perStep, invLinearIterationFunction(initialLearningRate, 100000), true, // learning steps
        InferenceOnlineLearner::perStepMiniBatch20, sumOfSquaresFunction(0.0),         // regularizer
        InferenceOnlineLearner::perPass, stoppingCriterion, true);                     // stopping criterion
    else
      return gradientDescentInferenceOnlineLearner(
        InferenceOnlineLearner::never,                                                 // randomization
        InferenceOnlineLearner::perStep, invLinearIterationFunction(initialLearningRate, 10000), true, // learning steps
        InferenceOnlineLearner::perStepMiniBatch20, sumOfSquaresFunction(0.0),         // regularizer
        InferenceOnlineLearner::perPass, stoppingCriterion, true);                     // stopping criterion
  }
};

///////////////////////////////////////// 

class MyInferenceCallback : public InferenceCallback
{
public:
  MyInferenceCallback(InferencePtr inference, ContainerPtr trainingData, ContainerPtr testingData)
    : inference(inference), trainingData(trainingData), testingData(testingData) {}

  virtual void preInferenceCallback(InferenceStackPtr stack, Variable& input, Variable& supervision, Variable& output, ReturnCode& returnCode)
  {
    String inferenceClassName = stack->getCurrentInference()->getClassName();
    //std::cout << "preInferenceCallback: " << inferenceClassName << std::endl;

    if (stack->getDepth() == 1)
    {
      // top-level learning is beginning
      startingTime = Time::getMillisecondCounter();
      bestTrainContactMap = bestTestContactMap = 0.0;
      iterationNumber = 0;
    }
    else if (inferenceClassName == T("SimulationInferenceBatchLearner"))
    {
      // simulation-based learning is beginning
      if (input.getType()->inheritsFrom(pairType()))
      {
        String inferenceName = input[0].getObject()->getName();
        std::cout << std::endl << "=====================================================" << std::endl;
        std::cout << "======= " << inferenceName << " ==========" << (Time::getMillisecondCounter() - startingTime) / 1000 << " s" << std::endl;
        std::cout << "=====================================================" << std::endl;
      }
      iterationNumber = 0;
    }
    else if (inferenceClassName == T("RunOnSupervisedExamplesInference"))
    {
      // learning iteration is beginning
      std::cout << std::endl << " ================== ITERATION " << ++iterationNumber << " ================== " << (Time::getMillisecondCounter() - startingTime) / 1000.0 << " s" <<  std::endl;
    }
  }
  
  virtual void postInferenceCallback(InferenceStackPtr stack, const Variable& input, const Variable& supervision, Variable& output, ReturnCode& returnCode)
  {
    String inferenceClassName = stack->getCurrentInference()->getClassName();
    //std::cout << "postInferenceCallback: " << inferenceClassName << std::endl;

    if (inferenceClassName == T("RunOnSupervisedExamplesInference"))
    {
      // end of learning iteration
      std::cout << "Evaluating ... " << std::endl;
      
      InferenceContextPtr validationContext = singleThreadedInferenceContext();
      ProteinEvaluatorPtr evaluator = new ProteinEvaluator();
      validationContext->evaluate(inference, trainingData, evaluator);
      processResults(evaluator, true);
      
      evaluator = new ProteinEvaluator();
      validationContext->evaluate(inference, testingData, evaluator);
      processResults(evaluator, false);
    }
    else if (stack->getDepth() == 1)
    {
      // end of top-level learning
      //std::cout << "Best train: " << bestTrainContactMap << " test: " << bestTestContactMap << std::endl;
      std::cout << "Bye." << std::endl;
    }
  }

  void processResults(ProteinEvaluatorPtr evaluator, bool isTrainingData)
  {
    /*{
      EvaluatorPtr bbbEvaluator = evaluation->getEvaluatorForTarget(T("BackboneBondSequence"));
      jassert(bbbEvaluator);
      std::cout << (isTrainingData ? "Train: " : "Test: ") << evaluation->toString() << std::endl;
    }*/
/*
    EvaluatorPtr contactMapEvaluator = evaluation->getEvaluatorForTarget(T("ResidueResidueContactMatrix8Ca"));
    jassert(contactMapEvaluator);
    std::cout << (isTrainingData ? "Train: " : "Test: ") << contactMapEvaluator->toString() << std::endl;
      
    std::vector< std::pair<String, double> > scores;
    contactMapEvaluator->getScores(scores);
    for (size_t i = 0; i < scores.size(); ++i)
      std::cout << scores[i].first << ": " << scores[i].second << std::endl;*/
    std::cout << " == " << (isTrainingData ? "Training" : "Testing") << " Scores == " << std::endl << evaluator->toString() << std::endl;
  }

private:
  InferencePtr inference;
  ContainerPtr trainingData, testingData;
  size_t iterationNumber;
  juce::uint32 startingTime;

  double bestTrainContactMap, bestTestContactMap;

  void updateBestScore(double score, double& bestScore)
    {if (score > bestScore) bestScore = score;}
};
///////////////////////////////////////// 

VectorPtr loadProteins(const File& directory, size_t maxCount = 0)
{
#ifdef JUCE_DEBUG
  if (!maxCount) maxCount = 7;
#endif // JUCE_DEBUG
  return directoryFileStream(directory)->apply(loadFromFileFunction(proteinClass()))->load(maxCount);
}

class ProteinToInputOutputPairFunction : public Function
{
public:
  virtual TypePtr getInputType() const
    {return proteinClass();}

  virtual TypePtr getOutputType(TypePtr ) const
    {return pairType(proteinClass(), proteinClass());}

  virtual Variable computeFunction(const Variable& input, ErrorHandler& callback) const
  {
    ProteinPtr protein = input.getObjectAndCast<Protein>();
    jassert(protein);
    protein->computeMissingVariables();
    ProteinPtr inputProtein = new Protein(protein->getName());
    inputProtein->setPrimaryStructure(protein->getPrimaryStructure());
    inputProtein->setPositionSpecificScoringMatrix(protein->getPositionSpecificScoringMatrix());
    return Variable::pair(inputProtein, protein);
  }
};

FunctionPtr proteinToInputOutputPairFunction()
  {return new ProteinToInputOutputPairFunction();}

int main(int argc, char** argv)
{
  lbcpp::initialize();
  declareProteinClasses();
  declareNewProteinInferenceClasses();
  
  File workingDirectory(T("C:\\Projets\\LBC++\\projects\\temp"));
  //File workingDirectory(T("/Users/francis/tmp"));

  ContainerPtr proteins = loadProteins(workingDirectory.getChildFile(T("SmallPDB\\xml")))->apply(proteinToInputOutputPairFunction())->randomize();
  ContainerPtr trainProteins = proteins->fold(0, 2);
  ContainerPtr testProteins = proteins->fold(1, 2);
  std::cout << trainProteins->size() << " training proteins, " << testProteins->size() << " testing proteins" << std::endl;

  // todo: proteinToInputOutput function

  ProteinInferenceFactoryPtr factory = new MyProteinInferenceFactory();

  ProteinSequentialInferencePtr inference = new ProteinSequentialInference();
  inference->appendInference(factory->createInference(T("secondaryStructure")));

  InferenceContextPtr context = singleThreadedInferenceContext();
  context->appendCallback(new MyInferenceCallback(inference, trainProteins, testProteins));
  context->train(inference, trainProteins);
  return 0;
  //PrintPerceptionCallback::print(proteins->getVariable(2), std::cout, 2);

  // make representation
  CompositePerceptionPtr perception = new ResidueCompositePerception();

  TypePtr pssmRowType = discreteProbabilityDistributionClass(aminoAcidTypeEnumeration());

  FunctionPtr selectPrimaryStructure = selectPairFieldsFunction(proteinClass()->findStaticVariable(T("primaryStructure")));
  FunctionPtr selectPSSM = selectPairFieldsFunction(proteinClass()->findStaticVariable(T("positionSpecificScoringMatrix")));

  perception->addPerception(T("AA"), Perception::compose(selectPrimaryStructure,
    windowPerception(aminoAcidTypeEnumeration(), 3)));
  perception->addPerception(T("PSSM"), Perception::compose(selectPSSM,
    windowPerception(pssmRowType, 3, identityPerception(pssmRowType))));

  //std::cout << "Perception output class: " << perception->getOutputType()->toString() << std::endl;

  PerceptionPtr flatPerception = perception->flatten();

  //std::cout << "Flat Perception output class: " << flatPerception->getOutputType()->toString() << std::endl;

  // make secondary structure classification examples
  VectorPtr secondaryStructureExamples = new Vector(pairType(
      flatPerception->getOutputType(),
      secondaryStructureElementEnumeration()));
  for (size_t i = 0; i < proteins->size(); ++i)
  {
    ProteinPtr protein = proteins->getVariable(i).getObjectAndCast<Protein>();
    jassert(protein);
    size_t n = protein->getLength();
    VectorPtr secondaryStructure = protein->getSecondaryStructure();
    for (size_t j = 0; j < n; ++j)
    {
      Variable input = flatPerception->compute(Variable::pair(protein, j));
      //std::cout << "Perception of : " << protein->getName() << " " << j << ": "
      //    << std::endl << perception->compute(Variable::pair(protein, j)) << std::endl;
      //std::cout << "    Flat : " << input << std::endl;
      //printVariable(perception->compute(Variable::pair(protein, j)), std::cout);
      //std::cout << std::endl << std::endl << std::endl;
      //printVariable(input, std::cout);
      Variable output = secondaryStructure->getVariable(j);
      secondaryStructureExamples->append(Variable::pair(input, output));
    }
  }

  /*{
    Variable anExampleInput = secondaryStructureExamples->getVariable(10)[0];
    printVariable(anExampleInput, std::cout, 3);
    FeatureGeneratorPtr anExampleFeatures = variableFeatures(anExampleInput)->toSparseVector();
    std::cout << "Features: " << anExampleFeatures->toString() << std::endl;
  }*/
  //exit(0);
  

  // make train and test set
  ContainerPtr data = secondaryStructureExamples->randomize();
  ContainerPtr trainingData = data->fold(0, 2);
  ContainerPtr testingData = data->fold(1, 2);
  std::cout << "Training Data: " << trainingData->size() << " Testing Data: " << testingData->size() << std::endl;

  // train
  inference = extraTreeInference(T("SS3"), 100, 15);
  context->train(inference, trainingData);

  // evaluate
  EvaluatorPtr evaluator = classificationAccuracyEvaluator(T("SS3"));
  context->evaluate(inference, trainingData, evaluator);
  std::cout << "Train: " << evaluator->toString() << std::endl;

  evaluator = classificationAccuracyEvaluator(T("SS3"));
  context->evaluate(inference, testingData, evaluator);
  std::cout << "Test: " << evaluator->toString() << std::endl;
  return 0;
}
