/*-----------------------------------------.---------------------------------.
| Filename: FromScratch.lcpp               | Test Learning                   |
| Author  : Francis Maes                   |                                 |
| Started : 08/04/2010 16:27               |                                 |
`------------------------------------------/                                 |
                               |                                             |
                               `--------------------------------------------*/

#include <lbcpp/lbcpp.h>
#include "GeneratedCode/Data/Bio/Protein.lh"
#include "VariableSetModel.h"
#include "InferenceStep/ProteinInferenceSteps.h"
#include "InferenceStep/SequenceInferenceStep.h"
using namespace lbcpp;

extern void declareProteinsClasses();
extern void declareVariableSetClasses();

// the aim is to learn a "incomplete Protein => complete Protein" function
class SupervisedTrainingCallback
{
public:
  virtual ~SupervisedTrainingCallback() {}
};

class MySupervisedTrainingCallback : public SupervisedTrainingCallback
{
};
// Input: Protein
// Output: SecondaryStructureSequence
class SS3ContentOnlyInferenceStep : public SecondaryStructureInferenceStep
{
public:
  SS3ContentOnlyInferenceStep() : SecondaryStructureInferenceStep(T("SS3ContentOnly")) {}

  virtual featureGenerator getInputFeatures(ProteinPtr protein, size_t index) const
  {
    LabelSequencePtr aminoAcidSequence = protein->getAminoAcidSequence();
    ScoreVectorSequencePtr positionSpecificScores = protein->getPositionSpecificScoringMatrix();

    featureCall("a") inline aminoAcidSequence->windowFeatures(index, 8, 8, true);
    featureCall("p") inline positionSpecificScores->windowFeatures(index, 8, 8, true);
  }
};

class SS3ContentAndStructureInferenceStep : public SecondaryStructureInferenceStep
{
public:
  SS3ContentAndStructureInferenceStep(size_t passNumber)
    : SecondaryStructureInferenceStep(T("SS3ContentAndStructure") + lbcpp::toString(passNumber)) {}

  virtual featureGenerator getInputFeatures(ProteinPtr protein, size_t index) const
  {
    LabelSequencePtr aminoAcidSequence = protein->getAminoAcidSequence();
    ScoreVectorSequencePtr positionSpecificScores = protein->getPositionSpecificScoringMatrix();
    SecondaryStructureSequencePtr secondaryStructure = protein->getSecondaryStructureSequence();

    featureCall("a") aminoAcidSequence->windowFeatures(index, 8, 8, true);
    featureCall("p") positionSpecificScores->windowFeatures(index, 8, 8, true);
    featureCall("w") secondaryStructure->windowFeatures(index, 5, 5, true);
  }
};

class MainInferenceStep : public SequenceInferenceStep
{
public:
  MainInferenceStep() : SequenceInferenceStep(T("Main"))
  {
    appendSubStep(new SS3ContentOnlyInferenceStep());
    appendSubStep(new SS3ContentAndStructureInferenceStep(1));
    appendSubStep(new SS3ContentAndStructureInferenceStep(2));
    appendSubStep(new SS3ContentAndStructureInferenceStep(3));
  }

  virtual ResultCode run(InferencePolicyPtr policy, ObjectPtr input, ObjectPtr& output)
  {
    ProteinPtr protein = input->cloneAndCast<Protein>();
    jassert(protein);
    ProteinPtr correctProtein = output ? output->cloneAndCast<Protein>() : ProteinPtr();
    output = protein;
    
    SecondaryStructureSequencePtr correctSecondaryStructure;
    if (correctProtein)
      correctSecondaryStructure = correctProtein->getSecondaryStructureSequence();

    for (size_t i = 0; i < subSteps.size(); ++i)
    {
      ObjectPtr subStepOutput = correctSecondaryStructure;
      ResultCode code = policy->doSubStep(subSteps[i], protein, subStepOutput);
      if (code != finishedReturnCode)
        return code;
      protein->setSecondaryStructureSequence(subStepOutput.dynamicCast<SecondaryStructureSequence>());
    }
    return finishedReturnCode;
  }
/*
  void train(ObjectContainerPtr proteins)
  {
    proteins = proteins->apply(new ObjectToObjectPairFunction());
    runOnSupervisedExamples(policy, proteins);
  }*/
};

////////////////////////////////
/*class InferencePolicy : public NameableObject
{
public:
  typedef InferenceStep::ResultCode ResultCode;

  virtual ResultCode doSubStep(InferenceStepPtr step, ObjectPtr input, ObjectPtr& output) = 0;
  virtual ResultCode doParallelSteps(const std::vector< std::pair<InferenceStepPtr, ObjectPtr> >& subInferences, ObjectContainerPtr output) = 0;

  virtual ResultCode doClassification(ClassifierPtr classifier, FeatureGeneratorPtr input, FeatureGeneratorPtr& result) = 0;
};*/


class ClassificationExamplesCreatorInferencePolicy : public DefaultInferencePolicy
{
public:
  ClassificationExamplesCreatorInferencePolicy(VectorObjectContainerPtr classificationExamples, bool stochasticSampling)
    : classificationExamples(classificationExamples), stochasticSampling(stochasticSampling) {}

  virtual ResultCode doClassification(ClassifierPtr classifier, FeatureGeneratorPtr input, FeatureGeneratorPtr& result)
  {
    if (result)
    {
      LabelPtr label = result.dynamicCast<Label>();
      jassert(label);
      classificationExamples->append(new ClassificationExample(input, label->getIndex()));
    }
    size_t label = stochasticSampling ? classifier->sample(input) : classifier->predict(input);
    result = new Label(classifier->getLabels(), label);
    return InferenceStep::finishedReturnCode;
  }

protected:
  VectorObjectContainerPtr classificationExamples;
  bool stochasticSampling;
};

class FixedLengthChain2InferencePolicy : public DefaultInferencePolicy
{
public:
  FixedLengthChain2InferencePolicy(InferencePolicyPtr policy1, size_t policy1NumSteps, InferencePolicyPtr policy2, size_t policy2NumSteps)
    : policy1(policy1), policy1NumSteps(policy1NumSteps), policy2(policy2), policy2NumSteps(policy2NumSteps) {reset();}
  
  void reset()
    {currentPosition = 0;}

  virtual ResultCode doSubStep(InferenceStepPtr step, ObjectPtr input, ObjectPtr& output)
  {
    if (currentPosition < policy1NumSteps)
    {
      ResultCode res = policy1->doSubStep(step, input, output);
      ++currentPosition;
      return res;
    }
    else if (currentPosition < policy2NumSteps)
    {
      ResultCode res = policy2->doSubStep(step, input, output);
      ++currentPosition;
      return res;
    }
    else
      return InferenceStep::canceledReturnCode;
  }

private:
  InferencePolicyPtr policy1;
  size_t policy1NumSteps;
  InferencePolicyPtr policy2;
  size_t policy2NumSteps;

  size_t currentPosition;
};

class LearnNthStepDeterministicInferencePolicy : public FixedLengthChain2InferencePolicy
{
public:
  LearnNthStepDeterministicInferencePolicy(size_t learnedStepNumber, InferencePolicyPtr learningPolicy)
    : FixedLengthChain2InferencePolicy(new DefaultInferencePolicy(), learnedStepNumber, learningPolicy, 1) {}
};

/////////////////////////



int main(int argc, char** argv)
{
  File modelFile(T("C:\\Projets\\Proteins\\data\\models\\test.model"));
  File proteinsDirectory(T("C:\\Projets\\Proteins\\data\\CB513cool"));
  ObjectStreamPtr proteinsStream = directoryObjectStream(proteinsDirectory, T("*.protein"));
  ObjectContainerPtr proteins = proteinsStream->load()->randomize();
  ObjectContainerPtr trainingData = proteins->invFold(0, 7);
  ObjectContainerPtr testingData = proteins->fold(0, 7);

  InferenceStepPtr mainInferenceStep = new MainInferenceStep();

//  ObjectGraphPtr dependencyGraph = mainInferenceStep->getDependencyGraph();


//  MySupervisedTrainingCallback callback;
//  trainSupervised(mainInferenceStep, trainingData, callback);
  
  return 0;
}
