/*-----------------------------------------.---------------------------------.
| Filename: FromScratch.lcpp               | Test Learning                   |
| Author  : Francis Maes                   |                                 |
| Started : 08/04/2010 16:27               |                                 |
`------------------------------------------/                                 |
                               |                                             |
                               `--------------------------------------------*/

#include <lbcpp/lbcpp.h>
#include <lbcpp/StoppingCriterion.h>
#include "InferenceContext/CacheInferenceCallback.h"
#include "InferenceLearner/InferenceLearner.h"
#include "InferenceLearner/InferenceLearnerCallback.h"
#include "Protein/Evaluation/ProteinEvaluationCallback.h"
#include "Protein/Inference/ProteinSequenceInferenceStep.h"
#include "Protein/Inference/ProteinInference.h"
#include "Protein/SecondaryStructureDictionary.h"
#include "Programs/ArgumentSet.h"
#include "Protein/Formats/PSSMFileParser.h"
#include "Programs/AAIndexParser.h"
#include "Programs/InferenceLearnerCallbackDefinitions.h"

using namespace lbcpp;

extern void declareProteinClasses();

/*                                                  *
                Under Heavy Development
 *                                                  */

int main(int argc, char** argv)
{
  declareProteinClasses();
  
  String proteinsDirectory("/Users/jbecker/Documents/Workspace/CASP9/CB513");
  String prefixResults("result");
  int currentFold = 0;
  //String inferenceModel("CO");
  String predictionTarget("SS3");
  int maxIteration = 5;
  int maxPass = 5;
  int wAA = 10;
  int wPSSM = 10;
  int wSS3 = 10;
  int wSS8 = 10;
  int wSA = 10;
  int wProp = 50;
  double regularizer = 20.0;
  double initialLearningRate = 2.0;
  int numberIterationLearningRate = 150000;
  bool useSavedModel = false;
  String savedModelDirectory("SAVED_MODEL");
  
  bool isTestVersion = false;
  
  ArgumentSet arguments;
  arguments.insert(new StringArgument(T("ProteinsDirectory"), &proteinsDirectory));
  arguments.insert(new StringArgument(T("PrefixResults"), &prefixResults));
  arguments.insert(new IntegerArgument(T("CurrentFold"), &currentFold));
  //arguments.insert(new StringArgument(T("InferenceModel"), &inferenceModel));
  arguments.insert(new StringArgument(T("PredictionTarget"), &predictionTarget));
  arguments.insert(new IntegerArgument(T("MaximumIteration"), &maxIteration));
  arguments.insert(new IntegerArgument(T("MaximumPass"), &maxPass));
  arguments.insert(new IntegerArgument(T("AminoAcidWindow"), &wAA));
  arguments.insert(new IntegerArgument(T("PSSMWindow"), &wPSSM));
  arguments.insert(new IntegerArgument(T("PropertyWindow"), &wProp));
  arguments.insert(new IntegerArgument(T("SS3Window"), &wSS3));
  arguments.insert(new IntegerArgument(T("SS8Window"), &wSS8));
  arguments.insert(new IntegerArgument(T("SAWindow"), &wSA));
  arguments.insert(new DoubleArgument(T("Regularizer"), &regularizer));
  arguments.insert(new DoubleArgument(T("InitialLearningRate"), &initialLearningRate));
  arguments.insert(new IntegerArgument(T("NumberIterationLearningRate"), &numberIterationLearningRate));
  arguments.insert(new BooleanArgument(T("UseSavedModel"), &useSavedModel));
  arguments.insert(new StringArgument(T("SavedModelDirectory"), &savedModelDirectory));
  
  arguments.insert(new BooleanArgument(T("IsTestVersion"), &isTestVersion));

  if (!arguments.parse(argv, 1, argc-1))
  {
    std::cout << "Usage: " << argv[0] << " " << arguments.toString() << std::endl;
    return -1;
  }

  File proteinsDirectoryFile = File::getCurrentWorkingDirectory().getChildFile(proteinsDirectory);
  
  enum{nbFolds = 7};
  
  std::cout << "*---- Program Parameters -----" << std::endl;
  std::cout << arguments;
  std::cout << "*-----------------------------" << std::endl;

  ObjectStreamPtr proteinsStream = directoryObjectStream(proteinsDirectoryFile, T("*.protein"));

/*------------------------------------------------------------------------------
          /!\   Testing Area - BE CAREFUL - AT YOUR OWN RISK   /!\
------------------------------------------------------------------------------*/
//#define PSSM
#ifdef PSSM
  while (!proteinsStream->isExhausted()) {
    ProteinPtr myProtein = proteinsStream->nextAndCast<Protein>();
    std::cout << myProtein->getName();
    std::cout.flush();   
 
    File pssmFile("/scratch/jbecker/CB513_PSSM/SOFT_NR_DB/" + myProtein->getName() + T(".pssm"));
    if (!pssmFile.exists()) {
      std::cout << " No pssm file found !" << std::endl;
      continue;
    }
    
    ObjectPtr newPSSM = ObjectStreamPtr(new PSSMFileParser(pssmFile, myProtein->getLength()))->next(); 
    jassert(newPSSM);
    myProtein->setObject(newPSSM);
  
    myProtein->computeProperties();
  
    File outputFile("/scratch/jbecker/CB513_PROTEIN/SOFT/" + myProtein->getName() + T(".protein"));
    myProtein->saveToFile(outputFile);
    
    std::cout << " OK" << std::endl;
  }

  return 0;

#endif
#ifdef VIEW
  ObjectContainerPtr prots = proteinsStream->load(1)->randomize();
  for (size_t i = 0; i < prots->size(); ++i)
  {
    ProteinPtr protein = (ProteinPtr) prots->get(i);
    protein->computeProperties();

    std::cout << protein->toString() << std::endl;
  }
  
  
  return 0;
#endif
/*----------------------------------------------------------------------------*/

  /*
  ** Retreive and compute AAIndex for each protein
  */
/*
  File file("/scratch/jbecker/aaindex1");
  if (isTestVersion)
    file = T("/Users/jbecker/Documents/Workspace/CASP9/aaindex1");
  ObjectStreamPtr aaindex = ObjectStreamPtr(new AAIndexParser(file));

  std::vector< ScoreVectorSequencePtr > vectorAAIndex;

  while (!aaindex->isExhausted()) {
    ScoreVectorSequencePtr score = (ScoreVectorSequencePtr) aaindex->next();
    if (!score) {
      continue;
    }

    vectorAAIndex.push_back(score);
  }

  std::cout << "Number of AAIndex: " << vectorAAIndex.size() << std::endl;
  jassert(vectorAAIndex.size() != 0);
*/
  ObjectContainerPtr proteins;
  if (isTestVersion)
    proteins = proteinsStream->load(7)->randomize();
  else
    proteins = proteinsStream->load()->randomize();
/*
  for (size_t i = 0; i < proteins->size(); ++i)
  {
    ProteinPtr protein = (ProteinPtr) proteins->get(i);
    protein->computePropertiesFrom(vectorAAIndex);
  }
*/
  proteins = proteins->apply(new ObjectToObjectPairFunction());

  /*
  ** Management of folds: Training fold and testing fold
  */
  ObjectContainerPtr trainingData = proteins->invFold(currentFold, nbFolds);
  ObjectContainerPtr testingData = proteins->fold(currentFold, nbFolds);

  std::cout << trainingData->size() << " Training Proteins "
            << testingData->size()  << " Testing Proteins" << std::endl;

  /*
  ** Creation of features function
  */
  CompositeProteinResidueFeaturesPtr featureFunction = new CompositeProteinResidueFeatures();
  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("AminoAcidSequence"), wAA, wAA, true));
  featureFunction->addSubFeatures(proteinFrequencyWindowFeatures(T("AminoAcidSequence"), 50, true));

  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("PositionSpecificScoringMatrix"), wPSSM, wPSSM, true));
  featureFunction->addSubFeatures(proteinFrequencyWindowFeatures(T("PositionSpecificScoringMatrix"), 150, true));

  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("SecondaryStructureSequence"), wSS3, wSS3, true));
  featureFunction->addSubFeatures(proteinFrequencyWindowFeatures(T("SecondaryStructureSequence"), 100, true));

  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("DSSPSecondaryStructureSequence"), wSS8, wSS8, true));
  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("SolventAccessibilityThreshold20"), wSA, wSA, true));
  
  featureFunction->addSubFeatures(proteinFrequencyWindowFeatures(T("AminoAcidProperty"), wProp, true));
  
  /*
  ** Creation of the inference
  */
  ProteinInferencePtr proteinInference = new ProteinInference();
  ProteinSequenceInferenceStepPtr step;

  for (size_t i = 0; i < (size_t) maxPass; ++i) {
    if (predictionTarget.contains(T("SS3")))
    {
      step = new ProteinSequenceLabelingInferenceStep(T("SS3_Pass_") + lbcpp::toString(i), featureFunction, T("SecondaryStructureSequence"));
      proteinInference->appendStep(step);
    }
    
    if (predictionTarget.contains(T("SS8")))
    {
      step = new ProteinSequenceLabelingInferenceStep(T("SS8_Pass_") + lbcpp::toString(i), featureFunction, T("DSSPSecondaryStructureSequence"));
      proteinInference->appendStep(step);
    }
    
    if (predictionTarget.contains(T("SA")))
    {
      step = new ProteinSequenceLabelingInferenceStep(T("SA_Pass_") + lbcpp::toString(i), featureFunction, T("SolventAccessibilityThreshold20"));
      proteinInference->appendStep(step);
    }
  }

  DefaultInferenceLearnerCallbackPtr factory = new DefaultInferenceLearnerCallback();
  factory->setL2Regularizer(regularizer);
  factory->setInitialLearningRate(initialLearningRate);
  factory->setNumberInterationLearningRate(numberIterationLearningRate);

  MultiInferenceLearnerCallbackPtr callback = new MultiInferenceLearnerCallback(trainingData, testingData, factory);
  callback->useCache(true);
  callback->appendCallback(new StoppingCriterionInferenceLearnerCallback(maxIteration));
  callback->appendCallback(new StandardOutputInferenceLearnerCallback());
  callback->appendCallback(new GnuPlotInferenceLearnerCallback(prefixResults));

  /* Load inference step that we already leaned */
  size_t firstStepToLearn = 0;
  while (useSavedModel && firstStepToLearn < proteinInference->getNumSubSteps())
  {
    File toLoad = File::getCurrentWorkingDirectory().getChildFile(savedModelDirectory + T("/") + lbcpp::toString(firstStepToLearn) + T("_") + proteinInference->getSubStep(firstStepToLearn)->getName() + T(".inference"));
    if (!toLoad.exists())
      break;

    InferenceStepPtr inference = Object::createFromFileAndCast<InferenceStep>(toLoad);
    jassert(inference);
    
    std::cout << "Loaded step: " << inference->getName() << std::endl;
    
    proteinInference->setSubStep(firstStepToLearn, inference);
    
    ++firstStepToLearn;
  }

  callback->appendCallback(new BestStepKeeperInferenceLearnerCallback(proteinInference, prefixResults, firstStepToLearn));
  stepByStepDeterministicSimulationLearner(callback, true, firstStepToLearn)->train(proteinInference, trainingData);

  return 0;
}

