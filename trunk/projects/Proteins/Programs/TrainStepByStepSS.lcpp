/*-----------------------------------------.---------------------------------.
| Filename: FromScratch.lcpp               | Test Learning                   |
| Author  : Francis Maes                   |                                 |
| Started : 08/04/2010 16:27               |                                 |
`------------------------------------------/                                 |
                               |                                             |
                               `--------------------------------------------*/

#include <lbcpp/lbcpp.h>
#include "InferenceCallback/InferenceLearner.h"
#include "ProteinInference/ProteinEvaluationCallback.h"
#include "ProteinInference/ProteinInference.h"
#include "Programs/ArgumentSet.h"

using namespace lbcpp;

extern void declareProteinClasses();

class SSContentOnlyInferenceStep : public SecondaryStructureInferenceStep
{
public:
  SSContentOnlyInferenceStep(const String& name, bool useDSSPElements)
    : SecondaryStructureInferenceStep(name, useDSSPElements) {}

  virtual featureGenerator getInputFeatures(ObjectPtr input, size_t index) const
  {
    ProteinPtr protein = input.dynamicCast<Protein>();
    jassert(protein);
    LabelSequencePtr aminoAcidSequence = protein->getAminoAcidSequence();
    ScoreVectorSequencePtr positionSpecificScores = protein->getPositionSpecificScoringMatrix();

    featureCall("a") inline aminoAcidSequence->windowFeatures(index, 10, 10, true);
    featureCall("p") inline positionSpecificScores->windowFeatures(index, 10, 10, true);
  }
};

class SSContentAndStructureInferenceStep : public SecondaryStructureInferenceStep
{
public:
  size_t wAA;
  size_t wPSSM;
  size_t wSS3;
  size_t wSS8;

  SSContentAndStructureInferenceStep(const String& name, bool useDSSPElements, size_t wAA, size_t wPSSM, size_t wSS3, size_t wSS8)
    : SecondaryStructureInferenceStep(name, useDSSPElements), wAA(wAA), wPSSM(wPSSM), wSS3(wSS3), wSS8(wSS8) {}

  virtual featureGenerator getInputFeatures(ObjectPtr input, size_t index) const
  {
    ProteinPtr protein = input.dynamicCast<Protein>();
    jassert(protein);
    LabelSequencePtr aminoAcidSequence = protein->getAminoAcidSequence();
    ScoreVectorSequencePtr positionSpecificScores = protein->getPositionSpecificScoringMatrix();
    LabelSequencePtr secondaryStructure = protein->getSecondaryStructureSequence();
    LabelSequencePtr dsspSecondaryStructure = protein->getDSSPSecondaryStructureSequence();

    featureCall("a") aminoAcidSequence->windowFeatures(index, wAA, wAA, true);
    featureCall("p") positionSpecificScores->windowFeatures(index, wPSSM, wPSSM, true);
    
    if (secondaryStructure)
      featureCall("w3") secondaryStructure->windowFeatures(index, wSS3, wSS3, true);
    
    if (dsspSecondaryStructure)
      featureCall("w8") dsspSecondaryStructure->windowFeatures(index, wSS8, wSS8, true);
  }
};

class CustomableSecondaryStructureContent : public FeaturesToContainerElementsSharedParallelInferenceStep
{
public:
  size_t wAA;
  size_t wPSSM;
  size_t wSS3;
  size_t wSS8;

  CustomableSecondaryStructureContent(const String& name)
    : FeaturesToContainerElementsSharedParallelInferenceStep(name
    , InferenceStepPtr(new ClassificationInferenceStep(T("SSClassification"))))
  {
    wAA = 10;
    wPSSM = 10;
    wSS3 = 0;
    wSS8 = 0;
  }
  
  virtual size_t getNumSubInferences(ObjectPtr input) const
  {
    ProteinPtr protein = input.dynamicCast<Protein>();
    jassert(protein);
    return protein->getLength();
  }
  
  virtual ObjectPtr createEmptyOutput(ObjectPtr input) const = 0;

  virtual featureGenerator getInputFeatures(ObjectPtr input, size_t index) const
  {
    ProteinPtr protein = input.dynamicCast<Protein>();
    jassert(protein);
    
    if (wAA) {
      LabelSequencePtr aminoAcidSequence = protein->getAminoAcidSequence();
      featureCall("AA") aminoAcidSequence->windowFeatures(index, wAA, wAA, true);
    }
    
    if (wPSSM) {
      ScoreVectorSequencePtr positionSpecificScores = protein->getPositionSpecificScoringMatrix();
      featureCall("PSSM") positionSpecificScores->windowFeatures(index, wPSSM, wPSSM, true);
    }
    
    if (wSS3) {
      LabelSequencePtr secondaryStructure = protein->getSecondaryStructureSequence();
      featureCall("wSS3") secondaryStructure->windowFeatures(index, wSS3, wSS3, true);
    }
    
    if (wSS8) {
      LabelSequencePtr dsspSecondaryStructure = protein->getDSSPSecondaryStructureSequence();
      featureCall("wSS8") dsspSecondaryStructure->windowFeatures(index, wSS8, wSS8, true);
    }
  }
  
  void setWindows(size_t newAA, size_t newPSSM, size_t newSS3, size_t newSS8)
  {
    wAA   = newAA;
    wPSSM = newPSSM;
    wSS3  = newSS3;
    wSS8  = newSS8;
  }
};

class SS3Content : public CustomableSecondaryStructureContent
{
public:
  SS3Content(const String& name) : CustomableSecondaryStructureContent(name)
  {
  }

  virtual ObjectPtr createEmptyOutput(ObjectPtr input) const
  {
    return new LabelSequence(SecondaryStructureDictionary::getInstance(), getNumSubInferences(input));
  }
};

class SS8Content : public CustomableSecondaryStructureContent
{
public:
  SS8Content(const String& name) : CustomableSecondaryStructureContent(name)
  {
  }

  virtual ObjectPtr createEmptyOutput(ObjectPtr input) const
  {
    return new LabelSequence(DSSPSecondaryStructureDictionary::getInstance(), getNumSubInferences(input));
  }
};

class MyInferenceFactory : public InferenceFactory
{
public:
  virtual ClassifierPtr createClassifier(FeatureDictionaryPtr labels)
  {
    static const double regularizer = 20.0;
    static const bool useConstantLearningRate = false;

    IterationFunctionPtr learningRate = useConstantLearningRate ? invLinearIterationFunction(2.0, 150000) : constantIterationFunction(1.0);
    GradientBasedLearnerPtr learner = stochasticDescentLearner(learningRate);  
    GradientBasedClassifierPtr classifier = maximumEntropyClassifier(learner, labels);
    classifier->setL2Regularizer(regularizer);
    return classifier;
  }
};

class MyInferenceLearnerCallback : public InferenceLearnerCallback
{
public:
  MyInferenceLearnerCallback(ObjectContainerPtr testingData, String& prefix, size_t maxIteration)
    : testingData(testingData), startTimeIteration(0.0)
    , prefixFilename(prefix), oIteration(NULL), oPass(NULL)
    , currentPass(0), lastTrainQ3(0.), lastTrainQ8(0.)
    , lastTestQ3(0.), lastTestQ8(0.), lastIterationNumber(0)
    , maxIteration(maxIteration)
  {
    startTimePass = juce::Time::getMillisecondCounter();
    File cwd = File::getCurrentWorkingDirectory();
    File dst = cwd.getChildFile(prefixFilename + T(".pass"));
    std::cout << "New file: " << dst.getFullPathName() << std::endl;
    dst.deleteFile();
    oPass = dst.createOutputStream();
    
  }

  virtual void preLearningIterationCallback(size_t iterationNumber)
  {
    std::cout << std::endl << " ================== ITERATION " << iterationNumber << " ================== " << std::endl;
    lastIterationNumber = iterationNumber;
  }

  // returns false if learning should stop
  virtual bool postLearningIterationCallback(InferenceStepPtr inference, InferenceContextPtr validationContext, InferenceCallbackPtr evaluation, size_t iterationNumber)
  {
    ProteinEvaluationCallbackPtr proteinEval = (ProteinEvaluationCallbackPtr)evaluation;
    
    std::cout << "Online evaluation: " << evaluation->toString() << std::endl;

    lastTrainQ3 = proteinEval->getQ3Score();
    lastTrainQ8 = proteinEval->getQ8Score();
    
    validationContext->runWithSupervisedExamples(inference, testingData);
    std::cout << "Validation evaluation: " << evaluation->toString() << std::endl;
    
    lastTestQ3 = proteinEval->getQ3Score();
    lastTestQ8 = proteinEval->getQ8Score();

    *oIteration << (int) lastIterationNumber << '\t'
               << lastTrainQ3 << '\t'
               << lastTestQ3  << '\t'
               << lastTrainQ8 << '\t'
               << lastTestQ8  << '\t'
               << (juce::Time::getMillisecondCounter() - startTimeIteration) << '\t'
               << (int) currentPass << '\n';
    oIteration->flush();

    return iterationNumber < maxIteration;
  }

  virtual void preLearningPassCallback(const String& passName)
  {
    std::cout << std::endl << "=====================================================" << std::endl;
    std::cout << "======= LEARNING PASS " << passName << " ==========" << std::endl;
    std::cout << "=====================================================" << std::endl;
    
    startTimeIteration = juce::Time::getMillisecondCounter();
    File cwd = File::getCurrentWorkingDirectory();
    File dst = cwd.getChildFile(prefixFilename + T(".iter_") + lbcpp::toString(currentPass));
    std::cout << "New file: " << dst.getFullPathName() << std::endl;
    dst.deleteFile();
    oIteration = dst.createOutputStream();
  }
  
  virtual void postLearningPassCallback()
  {
    *oPass << (int) currentPass << '\t'
          << lastTrainQ3 << '\t'
          << lastTestQ3  << '\t'
          << lastTrainQ8 << '\t'
          << lastTestQ8  << '\t'
          << (juce::Time::getMillisecondCounter() - startTimePass) / 1000. << '\n';
    oPass->flush();
    
    currentPass++;
  }

  virtual InferenceContextPtr createContext()
  {
    return singleThreadedInferenceContext(new MyInferenceFactory());
  }

  virtual InferenceCallbackPtr createEvaluationCallback()
  {
    return new ProteinEvaluationCallback();
  }

private:
  ObjectContainerPtr testingData;
  double startTimeIteration;
  double startTimePass;
  String& prefixFilename;
  OutputStream* oIteration;
  OutputStream* oPass;
  
  size_t currentPass;
  double lastTrainQ3;
  double lastTrainQ8;
  double lastTestQ3;
  double lastTestQ8;
  
  size_t lastIterationNumber;
  size_t maxIteration;
};


/*                                                *
                Under Heavy Development
 *                                                */

int main(int argc, char** argv)
{
  declareProteinClasses();
  
  String proteinsDirectory;
  String prefixResults;
  int currentFold = 0;
  String inferenceModel("CO");
  String predictionTarget("SS3");
  int maxIteration = 22;
  int maxPass = 5;
  int wAA = 10;
  int wPSSM = 10;
  int wSS3 = 10;
  int wSS8 = 10;
  
  ArgumentSet arguments;
  arguments.insert(new StringArgument(T("ProteinsDirectory"), &proteinsDirectory));
  arguments.insert(new StringArgument(T("PrefixResults"), &prefixResults));
  arguments.insert(new IntegerArgument(T("CurrentFold"), &currentFold));
  arguments.insert(new StringArgument(T("InferenceModel"), &inferenceModel));
  arguments.insert(new StringArgument(T("PredictionTarget"), &predictionTarget));
  arguments.insert(new IntegerArgument(T("MaximumIteration"), &maxIteration));
  arguments.insert(new IntegerArgument(T("MaximumPass"), &maxPass));
  arguments.insert(new IntegerArgument(T("AminoAcidWindow"), &wAA));
  arguments.insert(new IntegerArgument(T("PSSMWindow"), &wPSSM));
  arguments.insert(new IntegerArgument(T("SS3Window"), &wSS3));
  arguments.insert(new IntegerArgument(T("SS8Window"), &wSS8));
  
  
  if (!arguments.parse(argv, 1, argc-1)) {
    std::cout << "Usage: " << argv[0] << " " << arguments.toString() << std::endl;
    return -1;
  }


  File proteinsDirectoryFile = File::getCurrentWorkingDirectory().getChildFile(proteinsDirectory);
  
  enum{nbFolds = 7};
  
  std::cout << "----- Program Parameters -----" << std::endl;
  std::cout << arguments << std::endl;
  
  
  
  ObjectStreamPtr proteinsStream = directoryObjectStream(proteinsDirectoryFile, T("*.protein"));
  ObjectContainerPtr proteins = proteinsStream->load()->randomize()->apply(new ObjectToObjectPairFunction());

  ObjectContainerPtr trainingData = proteins->invFold(currentFold, nbFolds);
  ObjectContainerPtr testingData = proteins->fold(currentFold, nbFolds);

  std::cout << trainingData->size() << " Training Proteins "
            << testingData->size() << " Testing Proteins" << std::endl;

  ProteinInferencePtr proteinInference = new ProteinInference();
  
  if (predictionTarget == T("SS3"))
  {
    proteinInference->appendStep(new SSContentAndStructureInferenceStep(T("AA+PSSM -> S3"), false, wAA, wPSSM, wSS3, wSS8), T("SecondaryStructureSequence"));
    if (inferenceModel == T("SICA"))
    {
      for (size_t i = 0; i < (size_t) maxPass; ++i)
      {
        proteinInference->appendStep(new SSContentAndStructureInferenceStep(T("AA+PSSM+S3 -> S3 (") + toString(i) + T(")"), false, wAA, wPSSM, wSS3, wSS8), T("SecondaryStructureSequence"));
      }
    }
  } 
  else if (predictionTarget == T("SS8"))
  {
    proteinInference->appendStep(new SSContentAndStructureInferenceStep(T("AA+PSSM -> S8"), true, wAA, wPSSM, wSS3, wSS8), T("SecondaryStructureSequence"));
    if (inferenceModel == T("SICA"))
    {
      for (size_t i = 0; i < (size_t) maxPass; ++i)
      {
        proteinInference->appendStep(new SSContentAndStructureInferenceStep(T("AA+PSSM+S8 -> S8 (") + toString(i) + T(")"), true, wAA, wPSSM, wSS3, wSS8), T("SecondaryStructureSequence"));
      }
    }
  }
  else if (predictionTarget == T("SS3-SS8"))
  {
    proteinInference->appendStep(new SSContentAndStructureInferenceStep(T("AA+PSSM -> S3"), false, wAA, wPSSM, wSS3, wSS8), T("SecondaryStructureSequence"));
    proteinInference->appendStep(new SSContentAndStructureInferenceStep(T("AA+PSSM -> S8"), true, wAA, wPSSM, wSS3, wSS8), T("SecondaryStructureSequence"));
    if (inferenceModel == T("SICA"))
    {
      for (size_t i = 0; i < (size_t) maxPass; ++i)
      {
        proteinInference->appendStep(new SSContentAndStructureInferenceStep(T("AA+PSSM+S3+S8 -> S3 (") + toString(i) + T(")"), false, wAA, wPSSM, wSS3, wSS8), T("SecondaryStructureSequence"));
        proteinInference->appendStep(new SSContentAndStructureInferenceStep(T("AA+PSSM+S3+S8 -> S8 (") + toString(i) + T(")"), true, wAA, wPSSM, wSS3, wSS8), T("SecondaryStructureSequence"));
      }
    }
  }
  
#if 0
  if (predictionTarget == T("SS3"))
  {
    SS3Content is_SS3(T("AA+PSSM -> S3"));
    is_SS3.setWindows(wAA, wPSSM, 0, 0);
    proteinInference->appendStep(&is_SS3, T("SecondaryStructureSequence"));
    if (inferenceModel == T("SICA"))
    {
      for (size_t i = 0; i < (size_t) maxPass; ++i)
      {
        SS3Content is_SS3_Struct(T("AA+PSSM+S3 -> S3 (") + toString(i) + T(")"));
        is_SS3_Struct.setWindows(wAA, wPSSM, wSS3, 0);
        proteinInference->appendStep(&is_SS3_Struct, T("SecondaryStructureSequence"));
      }
    }
  } 
  else if (predictionTarget == T("SS8"))
  {
    SS8Content is_SS8(T("AA+PSSM -> S8"));
    is_SS8.setWindows(wAA, wPSSM, 0, 0);
    proteinInference->appendStep(&is_SS8, T("SecondaryStructureSequence"));
    if (inferenceModel == T("SICA"))
    {
      for (size_t i = 0; i < (size_t) maxPass; ++i)
      {
        SS8Content is_SS8_Struct(T("AA+PSSM+S8 -> S8 (") + toString(i) + T(")"));
        is_SS8_Struct.setWindows(wAA, wPSSM, 0, wSS8);
        proteinInference->appendStep(&is_SS8_Struct, T("SecondaryStructureSequence"));
      }
    }
  }
  else if (predictionTarget == T("SS3-SS8"))
  {
    SS3Content is_SS3(T("AA+PSSM -> S3"));
    is_SS3.setWindows(wAA, wPSSM, 0, 0);
    proteinInference->appendStep(&is_SS3, T("SecondaryStructureSequence"));
    
    SS8Content is_SS8(T("AA+PSSM -> S8"));
    is_SS8.setWindows(wAA, wPSSM, 0, 0);
    proteinInference->appendStep(&is_SS8, T("SecondaryStructureSequence"));
    
    if (inferenceModel == T("SICA"))
    {
      for (size_t i = 0; i < (size_t) maxPass; ++i)
      {
        SS3Content is_SS3_Struct(T("AA+PSSM+S3+S8 -> S3 (") + toString(i) + T(")"));
        is_SS3_Struct.setWindows(wAA, wPSSM, wSS3, wSS3);
        proteinInference->appendStep(&is_SS3_Struct, T("SecondaryStructureSequence"));
        
        SS8Content is_SS8_Struct(T("AA+PSSM+S3+S8 -> S8 (") + toString(i) + T(")"));
        is_SS8_Struct.setWindows(wAA, wPSSM, wSS3, wSS8);
        proteinInference->appendStep(&is_SS8_Struct, T("SecondaryStructureSequence"));
      }
    }
  }
#endif // 0

  InferenceLearnerCallbackPtr callback = new MyInferenceLearnerCallback(testingData, prefixResults, maxIteration);
  InferenceLearnerPtr learner = stepByStepSimulationInferenceLearner(callback);
  learner->train(proteinInference, trainingData);
  return 0;
}
