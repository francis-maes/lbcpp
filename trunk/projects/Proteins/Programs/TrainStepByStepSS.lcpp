/*-----------------------------------------.---------------------------------.
| Filename: FromScratch.lcpp               | Test Learning                   |
| Author  : Francis Maes                   |                                 |
| Started : 08/04/2010 16:27               |                                 |
`------------------------------------------/                                 |
                               |                                             |
                               `--------------------------------------------*/

#include <lbcpp/lbcpp.h>
#include "Protein/Evaluation/ProteinEvaluationCallback.h"
#include "Protein/Inference/Protein1DInferenceStep.h"
#include "Protein/Inference/ProteinBackboneBondSequenceInferenceStep.h"
#include "Protein/Inference/ProteinInference.h"
#include "Protein/SecondaryStructureDictionary.h"
#include "Programs/ArgumentSet.h"
#include "Protein/Formats/PSSMFileParser.h"
#include "Programs/AAIndexParser.h"
#include "Programs/InferenceLearnerCallbackDefinitions.h"

using namespace lbcpp;

extern void declareProteinClasses();

void clusterizeAAIndex(const std::vector< ScoreVectorSequencePtr > aaIndex, size_t numberCluster, std::vector< ScalarSequencePtr >& filteredIndex)
{
  if (!numberCluster)
    return;
  
  size_t numCluster = aaIndex.size();
  std::vector< std::vector<int> > clusters(numCluster);
  std::vector< std::vector<double> > distance(numCluster, std::vector<double>(numCluster, 0.0));
  
  /*
  ** Initialize structure
  */
  for (size_t i = 0; i < numCluster; ++i)
  {
    clusters[i].push_back(i);
    for (size_t j = i + 1; j < numCluster; ++j)
    {
      for (size_t k = 0; k < 20; ++k)
      {
        double val = aaIndex[i]->getScore(0, k) - aaIndex[j]->getScore(0, k);
        distance[i][j] += val * val;
      }
      distance[i][j] = sqrt(distance[i][j]);
      distance[j][i] = distance[i][j];
    }
    distance[i][i] = DBL_MAX / 2;
  }
  
  /*
  ** Generate clusters
  */
  for (; numCluster > numberCluster; --numCluster)
  {
    size_t min_i = 0;
    size_t min_j = 0;
    double min = DBL_MAX;

    /*
    ** Find closest cluster
    */
    for (size_t i = 0; i < numCluster; ++i)
    {
      for (size_t j = i + 1; j < numCluster; ++j)
      {
        if (distance[i][j] < min) {
          min = distance[i][j];
          min_i = i;
          min_j = j;
        }
      }
    }
    
    /*
    ** Merge clusters
    */
    for (size_t i = 0; i < clusters[min_j].size(); ++i)
      clusters[min_i].push_back(clusters[min_j][i]);

    /*
    ** Update distance matrix
    */
    for (size_t i = 0; i < numCluster; ++i)
    {
      distance[min_i][i] = (distance[min_i][i] + distance[min_j][i]) / 2;
      distance[i][min_i] = distance[min_i][i];
    }
    
    for (size_t i = 0; i < numCluster; ++i)
      distance[min_j][i] = distance[numCluster-1][i];
    
    for (size_t i = 0; i < numCluster; ++i)
      distance[i][min_j] = distance[i][numCluster-1];
    
    clusters[min_j] = clusters[numCluster-1];
  }
  
  for (size_t i = 0; i < numCluster; ++i)
  {
    //std::cout << lbcpp::toString(clusters[i]) << std::endl;
    ScalarSequencePtr scoreCluster = new ScalarSequence(T("AAIndex"), 24);
    for (size_t k = 0; k < 24; ++k)
    {
      double sum = 0.;
      for (size_t j = 0; j < clusters[i].size(); j++)
      {
        sum += aaIndex[clusters[i][j]]->getScore(0, k);
      }
      scoreCluster->setValue(k, sum / clusters[i].size());
    }
    filteredIndex.push_back(scoreCluster);
  }
}

/*                                                  *
                Under Heavy Development
 *                                                  */

int main(int argc, char** argv)
{
  declareProteinClasses();
  
  String proteinsDirectory("/Users/jbecker/Documents/Workspace/CASP9/SmallPDB/test_version");
  String prefixResults("result");
  int currentFold = 0;
  std::vector<String> predictionTargets;
  int maxIteration = 5;
  int wAA = 10;
  int wPSSM = 10;
  int wSS3 = 10;
  int wSS8 = 10;
  int wSA = 10;
  int wProp = 50;
  int numberAAIndex = 25;
  double regularizer = 20.0;
  double DRRegularizer = 150.0;
  double SARegularizer = 150.0;
  double initialLearningRate = 2.0;
  int numberIterationLearningRate = 150000;
  bool useSavedModel = false;
  String savedModelDirectory("SAVED_MODEL");
  
  bool isTestVersion = false;
  
  ArgumentSet arguments;
  arguments.insert(new StringArgument(T("ProteinsDirectory"), proteinsDirectory));
  arguments.insert(new StringArgument(T("PrefixResults"), prefixResults));
  arguments.insert(new IntegerArgument(T("CurrentFold"), currentFold));
  arguments.insert(new TargetExpressionArgument(T("PredictionTargets"), predictionTargets));
  arguments.insert(new IntegerArgument(T("MaximumIteration"), maxIteration));
  arguments.insert(new IntegerArgument(T("AminoAcidWindow"), wAA));
  arguments.insert(new IntegerArgument(T("PSSMWindow"), wPSSM));
  arguments.insert(new IntegerArgument(T("NumberOfAAIndex"), numberAAIndex));
  arguments.insert(new IntegerArgument(T("PropertyWindow"), wProp));
  arguments.insert(new IntegerArgument(T("SS3Window"), wSS3));
  arguments.insert(new IntegerArgument(T("SS8Window"), wSS8));
  arguments.insert(new IntegerArgument(T("SAWindow"), wSA));
  arguments.insert(new DoubleArgument(T("Regularizer"), regularizer));
  arguments.insert(new DoubleArgument(T("DRRegularizer"), DRRegularizer));
  arguments.insert(new DoubleArgument(T("SARegularizer"), SARegularizer));
  arguments.insert(new DoubleArgument(T("InitialLearningRate"), initialLearningRate));
  arguments.insert(new IntegerArgument(T("NumberIterationLearningRate"), numberIterationLearningRate));
  arguments.insert(new BooleanArgument(T("UseSavedModel"), useSavedModel));
  arguments.insert(new StringArgument(T("SavedModelDirectory"), savedModelDirectory));
  
  arguments.insert(new BooleanArgument(T("IsTestVersion"), isTestVersion));

  String testFeatures;
  arguments.insert(new StringArgument(T("TestFeatures"), testFeatures));

  double drProb = 0.2;
  arguments.insert(new DoubleArgument(T("DRProbability"), drProb));

  if (!arguments.parse(argv, 1, argc-1))
  {
    std::cout << "Usage: " << argv[0] << " " << arguments.toString() << std::endl;
    return -1;
  }

  File proteinsDirectoryFile = File::getCurrentWorkingDirectory().getChildFile(proteinsDirectory);
  
  enum{nbFolds = 7};
  
  std::cout << "*---- Program Parameters -----" << std::endl;
  std::cout << arguments;
  std::cout << "*-----------------------------" << std::endl;

  ObjectStreamPtr proteinsStream = directoryObjectStream(proteinsDirectoryFile, T("*.protein"));

/*------------------------------------------------------------------------------
          /!\   Testing Area - BE CAREFUL - AT YOUR OWN RISK   /!\
------------------------------------------------------------------------------*/


/*----------------------------------------------------------------------------*/

  /*
  ** Retreive and compute AAIndex for each protein
  */
  /*
  File file("/scratch/jbecker/aaindex1");
  if (isTestVersion)
    file = T("/Users/jbecker/Documents/Workspace/CASP9/aaindex1");
  ObjectStreamPtr aaindex = ObjectStreamPtr(new AAIndexParser(file));

  std::vector< ScoreVectorSequencePtr > vectorAAIndex;

  while (!aaindex->isExhausted()) {
    ScoreVectorSequencePtr score = (ScoreVectorSequencePtr) aaindex->next();
    if (!score) {
      continue;
    }

    vectorAAIndex.push_back(score);
  }

  std::cout << "Total number of AAIndex: " << vectorAAIndex.size() << std::endl;
  jassert(vectorAAIndex.size() != 0);

  std::vector< ScalarSequencePtr > clusteredAAIndex;
  clusterizeAAIndex(vectorAAIndex, numberAAIndex, clusteredAAIndex);

  for (size_t i = 0; i < clusteredAAIndex.size(); ++i) {
    std::cout << lbcpp::toString(clusteredAAIndex[i]) << std::endl;
  }
  */
  ObjectContainerPtr proteins;
  if (isTestVersion)
    proteins = proteinsStream->load(7)->randomize();
  else
    proteins = proteinsStream->load(500)->randomize();

  for (size_t i = 0; i < proteins->size(); ++i)
  {
    ProteinPtr protein = (ProteinPtr) proteins->get(i);
//    protein->computePropertiesFrom(clusteredAAIndex);
    protein->computeMissingFields();
  }

  proteins = proteins->apply(new ProteinToInputOutputPairFunction());

  /*
  ** Management of folds: Training fold and testing fold
  */
  ObjectContainerPtr trainingData = proteins->invFold(currentFold, nbFolds);
  ObjectContainerPtr testingData = proteins->fold(currentFold, nbFolds);

  std::cout << trainingData->size() << " Training Proteins "
            << testingData->size()  << " Testing Proteins" << std::endl;

  /*
  ** Creation of features function
  */
  CompositeProteinResidueFeaturesPtr featureFunction = new CompositeProteinResidueFeatures();
  
  featureFunction->addSubFeatures(proteinUnitResidueFeature());
  
  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("AminoAcidSequence"), wAA, wAA, true));
  featureFunction->addSubFeatures(proteinFrequencyWindowFeatures(T("AminoAcidSequence"), 50, true));
  //featureFunction->addSubFeatures(proteinSequenceEntropyFeatures(T("AminoAcidSequence"), 10));
  
  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("ReducedAminoAcidAlphabetSequence"), wAA, wAA, true));
  featureFunction->addSubFeatures(proteinFrequencyWindowFeatures(T("ReducedAminoAcidAlphabetSequence"), 50, true));

  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("StructuralAlphabetSequence"), wAA, wAA, true));


  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("PositionSpecificScoringMatrix"), wPSSM, wPSSM, true));
  featureFunction->addSubFeatures(proteinFrequencyWindowFeatures(T("PositionSpecificScoringMatrix"), 150, true));
  //featureFunction->addSubFeatures(proteinSequenceEntropyFeatures(T("PositionSpecificScoringMatrix"), 10));

  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("SecondaryStructureSequence"), wSS3, wSS3, true));
  featureFunction->addSubFeatures(proteinFrequencyWindowFeatures(T("SecondaryStructureSequence"), 100, true));
  //featureFunction->addSubFeatures(proteinSequenceEntropyFeatures(T("SecondaryStructureSequence"), 10));


  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("DSSPSecondaryStructureSequence"), wSS8, wSS8, true));
  //featureFunction->addSubFeatures(proteinSequenceEntropyFeatures(T("DSSPSecondaryStructureSequence"), 10));

  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("SolventAccessibilityThreshold20"), wSA, wSA, true));
  //featureFunction->addSubFeatures(proteinSequenceEntropyFeatures(T("SolventAccessibilityThreshold20"), 10));
 
  featureFunction->addSubFeatures(proteinFrequencyWindowFeatures(T("AminoAcidProperty"), wProp, true));
  
  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("DisorderProbabilitySequence"), 5, 5, true));
  
  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("BackboneBondSequence"), 5, 5, true));

  std::cout << "New features: ";
  if (testFeatures.contains(T("SegCon")))
  {
    featureFunction->addSubFeatures(proteinSegmentConjunctionFeatures(T("SecondaryStructureSequence"), 2));
    std::cout << "SegmentConjunction(2)  ";
  }

  if (testFeatures.contains(T("Pos")))
  {
    featureFunction->addSubFeatures(proteinPositionFeatures());
    std::cout << "Position  ";
  }

  if (testFeatures.contains(T("Len")))
  {
    featureFunction->addSubFeatures(proteinGlobalToResidueFeatures(proteinLengthFeatures()));
    std::cout << "Length  ";
  }
  std::cout << std::endl;
  
  /*
  ** Creation of the inference
  */
  ProteinInferencePtr proteinInference = new ProteinInference();
  Protein1DInferenceStepPtr step;

  for (size_t i = 0; i < predictionTargets.size(); ++i) {
    String predictionTarget = predictionTargets[i];
    if (predictionTarget.contains(T("SS3")))
    {
      step = new ProteinSequenceLabelingInferenceStep(T("SS3_Pass_") + lbcpp::toString(i), featureFunction, T("SecondaryStructureSequence"));
      proteinInference->appendStep(step);
    }
    
    if (predictionTarget.contains(T("SS8")))
    {
      step = new ProteinSequenceLabelingInferenceStep(T("SS8_Pass_") + lbcpp::toString(i), featureFunction, T("DSSPSecondaryStructureSequence"));
      proteinInference->appendStep(step);
    }
    
    if (predictionTarget.contains(T("SA")))
    {
      step = new ProteinSequenceLabelingInferenceStep(T("SA_Pass_") + lbcpp::toString(i), featureFunction, T("SolventAccessibilityThreshold20"));
      proteinInference->appendStep(step);
    }
    
    if (predictionTarget.contains(T("DR")))
    {
      step = new ProteinSequenceLabelingInferenceStep(T("DR_Pass_") + lbcpp::toString(i), featureFunction, T("DisorderProbabilitySequence"), T("DisorderSequence"));
      proteinInference->appendStep(step);
    }

    if (predictionTarget.contains(T("BBB")))
    {
      step = new ProteinBackboneBondSequenceInferenceStep(T("BBB_Pass_") + lbcpp::toString(i), featureFunction);
      proteinInference->appendStep(step);
    }
  }

  DefaultInferenceLearnerCallbackPtr factory = new DefaultInferenceLearnerCallback();
  factory->setL2Regularizer(regularizer);
  factory->setInitialLearningRate(initialLearningRate);
  factory->setNumberInterationLearningRate(numberIterationLearningRate);
  factory->setDRProbability(drProb);
  factory->setDRRegularizer(DRRegularizer);
  factory->setSARegularizer(SARegularizer);

  MultiInferenceLearnerCallbackPtr callback = new MultiInferenceLearnerCallback(trainingData, testingData, factory);
  callback->useCache(true);
  callback->appendCallback(new StoppingCriterionInferenceLearnerCallback(maxIteration));
  callback->appendCallback(new StandardOutputInferenceLearnerCallback());
  callback->appendCallback(new GnuPlotInferenceLearnerCallback(prefixResults));

  /* Load inference step that we already leaned */
  File modelDirectory;
  if (useSavedModel)
    modelDirectory = savedModelDirectory;

  //callback->appendCallback(new BestStepKeeperInferenceLearnerCallback(proteinInference, prefixResults));
  stepByStepDeterministicSimulationLearner(callback, true, modelDirectory)->train(proteinInference, trainingData);

  return 0;
}

