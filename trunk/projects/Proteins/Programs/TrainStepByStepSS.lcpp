/*-----------------------------------------.---------------------------------.
| Filename: FromScratch.lcpp               | Test Learning                   |
| Author  : Francis Maes                   |                                 |
| Started : 08/04/2010 16:27               |                                 |
`------------------------------------------/                                 |
                               |                                             |
                               `--------------------------------------------*/

#include <lbcpp/lbcpp.h>
#include <lbcpp/StoppingCriterion.h>
#include "InferenceContext/CacheInferenceCallback.h"
#include "InferenceLearner/InferenceLearner.h"
#include "InferenceLearner/InferenceLearnerCallback.h"
#include "Protein/ProteinEvaluationCallback.h"
#include "Protein/ProteinInference.h"
#include "Programs/ArgumentSet.h"
#include "Protein/Formats/PSSMFileParser.h"
#include "Programs/AAIndexParser.h"

using namespace lbcpp;

extern void declareProteinClasses();

class CustomableSecondaryStructureContent : public ProteinSequenceLabelingInferenceStep
{
public:
  enum Target {NONE = -1, SS3 = 0, SS8, SA};
  
  enum {numberTarget = 3};

  CustomableSecondaryStructureContent(const String& name = String::empty)
    : ProteinSequenceLabelingInferenceStep(name), wAA(0), wPSSM(0), wSS3(0), wSS8(0), wSA(0), wProp(0), target(SS3)
    {}
  
  void setTarget(Target newTarget)
    {target = newTarget;}
  
  void enableAminoAcidFeatures(size_t windowLength)
    {wAA = windowLength;}
  
  void enablePositionSpecificScoreFeatures(size_t windowLength)
    {wPSSM = windowLength;}
  
  void enablePropertyFeatures(size_t windowLength)
    {wProp = windowLength;}
  
  void enableSecondaryStructure3StatesFeatures(size_t windowLength)
    {wSS3 = windowLength;}
  
  void enableSecondaryStructure8StatesFeatures(size_t windowLength)
    {wSS8 = windowLength;}
  
  void enableSolventAccesibility2StatesFeatures(size_t windowLength)
    {wSA = windowLength;}
  
  void disableAminoAcidFeatures()
    {wAA = 0;}
  
  void disablePositionSpecificScoreFeatures()
    {wPSSM = 0;}
  
  void disablePropertyFeatures()
    {wProp = 0;}
  
  void disableSecondaryStructure3StatesFeatures()
    {wSS3 = 0;}
  
  void disableSecondaryStructure8StatesFeatures()
    {wSS8 = 0;}
  
  void disableSolventAccesibility2StatesFeatures(size_t windowLength)
    {wSA = 0;}

  virtual featureGenerator getInputFeatures(ObjectPtr input, size_t index) const
  {
    ProteinPtr protein = input.dynamicCast<Protein>();
    jassert(protein);

    if (wAA)
    {
      LabelSequencePtr aminoAcidSequence = protein->getAminoAcidSequence();
      jassert(aminoAcidSequence);
      featureCall("AA") aminoAcidSequence->windowFeatures(index, wAA, wAA, true);
      featureCall("AAFreq") aminoAcidSequence->symetricFrequencyFeatures(index, 50, true);
    }
    
    if (wPSSM)
    {
      ScoreVectorSequencePtr positionSpecificScores = protein->getPositionSpecificScoringMatrix();
      jassert(positionSpecificScores);
      featureCall("PSSM") positionSpecificScores->windowFeatures(index, wPSSM, wPSSM, true);
      featureCall("PSSMFreq") positionSpecificScores->symetricFrequencyFeatures(index, 150, true);
    }
    
    if (wProp) {
      ScoreVectorSequencePtr properties = protein->getAminoAcidProperty();
      jassert(properties);
      
      featureCall("Prop") properties->symetricFrequencyFeatures(index, wProp, true);
    }
    
    if (wSS3)
    {
      LabelSequencePtr secondaryStructure = protein->getSecondaryStructureSequence();
      jassert(secondaryStructure);
      featureCall("wSS3") secondaryStructure->windowFeatures(index, wSS3, wSS3, true);
      featureCall("wSS3Freq") secondaryStructure->symetricFrequencyFeatures(index, 100, true);
    }
    
    if (wSS8)
    {
      LabelSequencePtr dsspSecondaryStructure = protein->getDSSPSecondaryStructureSequence();
      jassert(dsspSecondaryStructure);
      featureCall("wSS8") dsspSecondaryStructure->windowFeatures(index, wSS8, wSS8, true);
    }
    
    if (wSA)
    {
      LabelSequencePtr solventAccesibilityStructure = protein->getSolventAccessibilitySequence();
      jassert(solventAccesibilityStructure);
      featureCall("wSA") solventAccesibilityStructure->windowFeatures(index, wSA, wSA, true);
    }
  }

  static Target getTarget(String& target)
  {
    static const juce::tchar* targetNames[] = {
      T("SecondaryStructureSequence"), T("DSSPSecondaryStructureSequence"), T("SolventAccessibilitySequence")
    };
    
    for (size_t i = 0; i < numberTarget; ++i)
    {
      if (target == targetNames[i])
        return (Target) i;
    }
    
    return NONE;
  }

  virtual String getTargetName() const
  {
    static const juce::tchar* targetNames[] = {
      T("SecondaryStructureSequence"), T("DSSPSecondaryStructureSequence"), T("SolventAccessibilitySequence")
    };
    jassert((size_t)target < sizeof (targetNames) / sizeof (const juce::tchar* ));
    return targetNames[target];
  }

  virtual FeatureDictionaryPtr getTargetDictionary() const
  {
    static const FeatureDictionaryPtr targetDictionaries[] = {
      SecondaryStructureDictionary::getInstance(), DSSPSecondaryStructureDictionary::getInstance(), SolventAccesibility2StateDictionary::getInstance()
    };
    jassert((size_t)target < sizeof (targetDictionaries) / sizeof (FeatureDictionaryPtr));
    return targetDictionaries[target];
  }

protected:
  virtual bool load(InputStream& istr)
  {
    int versionNumber;
    if (!lbcpp::read(istr, versionNumber))
      return false;
    if (versionNumber != 101)
    {
      Object::error(T("CustomableSecondaryStructureContent::load"), T("Unrecognized version number"));
      return false;
    }
    if (!ProteinSequenceLabelingInferenceStep::load(istr))
      return false;
    if (!lbcpp::read(istr, wAA) || !lbcpp::read(istr, wPSSM) ||
        !lbcpp::read(istr, wSS3) || !lbcpp::read(istr, wSS8) ||
        !lbcpp::read(istr, wSA) || !lbcpp::read(istr, wProp))
      return false;
    int targeti;
    if (!lbcpp::read(istr, targeti))
      return false;
    target = (Target)targeti;
    return true;
  }

  virtual void save(OutputStream& ostr) const
  {
    int versionNumber = 101;
    lbcpp::write(ostr, versionNumber);
    ProteinSequenceLabelingInferenceStep::save(ostr);
    lbcpp::write(ostr, wAA);
    lbcpp::write(ostr, wPSSM);
    lbcpp::write(ostr, wSS3);
    lbcpp::write(ostr, wSS8);
    lbcpp::write(ostr, wSA);
    lbcpp::write(ostr, wProp);
    lbcpp::write(ostr, (int)target);
  }

private:
  size_t wAA;
  size_t wPSSM;
  size_t wSS3;
  size_t wSS8;
  size_t wSA;
  size_t wProp;
  Target target;
};

typedef ReferenceCountedObjectPtr<CustomableSecondaryStructureContent> CustomableSecondaryStructureContentPtr;

class DefaultInferenceLearnerCallback : public InferenceLearnerCallback
{
public:
  DefaultInferenceLearnerCallback() : regularizer(1.0), initialLearningRate(2.0), numberIterationLearningRate(150000) {}
  
  virtual InferenceContextPtr createContext()
    {return singleThreadedInferenceContext();}
  
  virtual ClassifierPtr createClassifier(ClassificationInferenceStepPtr step, FeatureDictionaryPtr labels)
  {
    static const bool useConstantLearningRate = false;

    IterationFunctionPtr learningRate = useConstantLearningRate ? invLinearIterationFunction(initialLearningRate, numberIterationLearningRate) : constantIterationFunction(1.0);
    GradientBasedLearnerPtr learner = stochasticDescentLearner(learningRate);  
    GradientBasedClassifierPtr classifier = maximumEntropyClassifier(learner, labels);
    classifier->setL2Regularizer(regularizer);
    return classifier;
  }

  virtual RegressorPtr createRegressor(RegressionInferenceStepPtr step)
  {
    static const bool useConstantLearningRate = true;

    IterationFunctionPtr learningRate = useConstantLearningRate ? invLinearIterationFunction(initialLearningRate, numberIterationLearningRate) : constantIterationFunction(0.5);
    GradientBasedLearnerPtr learner = stochasticDescentLearner(learningRate);  
    return leastSquaresLinearRegressor(learner, 0.0/*regularizer*/);
  }

  void setL2Regularizer(double regularizer)
    {this->regularizer = regularizer;}
  
  void setInitialLearningRate(double value)
    {this->initialLearningRate = value;}
    
  void setNumberInterationLearningRate(size_t value)
    {this->numberIterationLearningRate = value;}

protected:
  double regularizer;
  double initialLearningRate;
  size_t numberIterationLearningRate;
};

typedef ReferenceCountedObjectPtr<DefaultInferenceLearnerCallback> DefaultInferenceLearnerCallbackPtr;

class EvaluationInferenceLearnerCallback : public InferenceLearnerCallback
{
public:
  EvaluationInferenceLearnerCallback(InferenceLearnerCallbackPtr factory = new DefaultInferenceLearnerCallback())
    : trainingEvaluation(new ProteinEvaluationCallback()), testingEvaluation(new ProteinEvaluationCallback())
    , factory(factory)
    , target(CustomableSecondaryStructureContent::NONE), targetTrainingScore(0.), targetTestingScore(0.)
  {
    trainingEvaluation->startInferencesCallback(0); // initialize a zero score
    testingEvaluation->startInferencesCallback(0);
  }

  virtual void setTrainingEvaluation(ProteinEvaluationCallbackPtr trainingEvaluation)
  {
    jassert(trainingEvaluation);
    this->trainingEvaluation = trainingEvaluation;
    switch (target) {
    case CustomableSecondaryStructureContent::SS3:
        targetTrainingScore = trainingEvaluation->getQ3Score(); break;
    
    case CustomableSecondaryStructureContent::SS8:
        targetTrainingScore = trainingEvaluation->getQ8Score(); break;
    
    case CustomableSecondaryStructureContent::SA:
        targetTrainingScore = trainingEvaluation->getSA2Score(); break;

    default:
        jassert(false); break;
    }
  }
  
  virtual void setTestingEvaluation(ProteinEvaluationCallbackPtr testingEvaluation)
  {
    jassert(testingEvaluation);
    this->testingEvaluation = testingEvaluation;
    switch (target) {
    case CustomableSecondaryStructureContent::SS3:
        targetTestingScore = testingEvaluation->getQ3Score(); break;
    
    case CustomableSecondaryStructureContent::SS8:
        targetTestingScore = testingEvaluation->getQ8Score(); break;
    
    case CustomableSecondaryStructureContent::SA:
        targetTestingScore = testingEvaluation->getSA2Score(); break;

    default:
        jassert(false); break;
    }

  }
  
  virtual void setTargetName(String& targetName)
  {
    target = CustomableSecondaryStructureContent::getTarget(targetName);
    jassert(target != CustomableSecondaryStructureContent::NONE);
  }

  virtual InferenceContextPtr createContext()
    {jassert(factory); return factory->createContext();}
  
  virtual ClassifierPtr createClassifier(ClassificationInferenceStepPtr step, FeatureDictionaryPtr labels)
    {jassert(factory); return factory->createClassifier(step, labels);}

  virtual RegressorPtr createRegressor(RegressionInferenceStepPtr step)
    {jassert(factory); return factory->createRegressor(step);}

  void setFactory(InferenceLearnerCallbackPtr factory)
    {this->factory = factory;}

protected:
  typedef CustomableSecondaryStructureContent::Target Target;

  ProteinEvaluationCallbackPtr getTrainingEvaluation()
    {jassert(trainingEvaluation); return trainingEvaluation;}
  
  ProteinEvaluationCallbackPtr getTestingEvaluation()
    {jassert(testingEvaluation); return testingEvaluation;}

  Target getTarget()
  {
    jassert(target != CustomableSecondaryStructureContent::NONE);
    return target;
  }
  
  double getTargetTrainingScore()
    {return targetTrainingScore;}
  
  double getTargetTestingScore()
    {return targetTestingScore;}

private:
  ProteinEvaluationCallbackPtr trainingEvaluation;
  ProteinEvaluationCallbackPtr testingEvaluation;
  
  InferenceLearnerCallbackPtr factory;
  
  Target target;
  double targetTrainingScore;
  double targetTestingScore;
};

typedef ReferenceCountedObjectPtr<EvaluationInferenceLearnerCallback> EvaluationInferenceLearnerCallbackPtr;

class MultiInferenceLearnerCallback : public InferenceLearnerCallback
{
public:
  MultiInferenceLearnerCallback(ObjectContainerPtr trainingData, ObjectContainerPtr testingData, InferenceLearnerCallbackPtr factory)
    : trainingData(trainingData), testingData(testingData), factory(factory)
    , cache(new InferenceResultCache()) {}

  virtual ~MultiInferenceLearnerCallback()
    {}
  
  virtual InferenceContextPtr createContext()
    {return factory->createContext();}
  
  virtual ClassifierPtr createClassifier(ClassificationInferenceStepPtr step, FeatureDictionaryPtr labels)
    {return factory->createClassifier(step, labels);}

  virtual RegressorPtr createRegressor(RegressionInferenceStepPtr step)
    {return factory->createRegressor(step);}

  virtual void preLearningIterationCallback(size_t iterationNumber)
  {
    for (size_t i = 0; i < callbacks.size(); ++i)
    {
      callbacks[i]->preLearningIterationCallback(iterationNumber);
    }
  }

  // returns false if learning should stop (if at least one callback return false)
  virtual bool postLearningIterationCallback(InferenceStepPtr inference, size_t iterationNumber)
  {
    InferenceContextPtr validationContext = createContext();
    
    if (cache)
      validationContext->appendCallback(new AutoSubStepsCacheInferenceCallback(cache, inference));

    ProteinEvaluationCallbackPtr trainingEvaluation = new ProteinEvaluationCallback();
    validationContext->appendCallback(trainingEvaluation);
    validationContext->runWithSupervisedExamples(inference, trainingData);
    validationContext->removeCallback(trainingEvaluation);
    
    ProteinEvaluationCallbackPtr testingEvaluation = new ProteinEvaluationCallback();
    validationContext->appendCallback(testingEvaluation);
    validationContext->runWithSupervisedExamples(inference, testingData);

    bool res = true;
    for (size_t i = 0; i < callbacks.size(); ++i)
    {
      callbacks[i]->setTrainingEvaluation(trainingEvaluation);
      callbacks[i]->setTestingEvaluation(testingEvaluation);
      if (!callbacks[i]->postLearningIterationCallback(inference, iterationNumber))
        res = false;
    }
    
    return res;
  }
  
  virtual void preLearningStepCallback(InferenceStepPtr step)
  {
    String target = ((ProteinSequenceLabelingInferenceStepPtr) step)->getTargetName();

    for (size_t i = 0; i < callbacks.size(); ++i)
    {
      callbacks[i]->setTargetName(target);
      callbacks[i]->preLearningStepCallback(step);
    }
  }
  
  virtual void postLearningStepCallback(InferenceStepPtr step)
  {
    for (size_t i = 0; i < callbacks.size(); ++i)
    {
      callbacks[i]->postLearningStepCallback(step);
    }
  }

  void appendCallback(EvaluationInferenceLearnerCallbackPtr callback)
  {
    jassert(callback);
    callback->setFactory(factory);
    callbacks.push_back(callback);
  }
  
  void useCache(bool useCache)
  {
    if (!useCache)
      cache = ObjectPtr();
    else if (!cache)
      cache = new InferenceResultCache();
  }
  
private:
  std::vector< EvaluationInferenceLearnerCallbackPtr >callbacks;

  ObjectContainerPtr trainingData;
  ObjectContainerPtr testingData;
  
  InferenceLearnerCallbackPtr factory;
  InferenceResultCachePtr cache;
};

typedef ReferenceCountedObjectPtr<MultiInferenceLearnerCallback> MultiInferenceLearnerCallbackPtr;

class GnuPlotInferenceLearnerCallback : public EvaluationInferenceLearnerCallback
{
public:
  GnuPlotInferenceLearnerCallback(String& prefix)
    : prefixFilename(prefix)
//    , startTimeIteration(0.0)
    , startTimePass(juce::Time::getMillisecondCounter())
//    , oIteration(NULL)
//    , iterationNumber(0), passNumber(0)
      , bestTrainingScore(0.), bestTestingScore(0.)
  {
    for (size_t i = 0; i < CustomableSecondaryStructureContent::numberTarget; ++i) {
      oTargetPass[i] = NULL;
      targetIteration[i] = 0;
    }
  }
  
  ~GnuPlotInferenceLearnerCallback()
  {
    for (size_t i = 0; i < CustomableSecondaryStructureContent::numberTarget; ++i)
      delete oTargetPass[i];
  }

  virtual void preLearningIterationCallback(size_t iterationNumber)
  {
//  this->iterationNumber = iterationNumber;
  }
  
  virtual bool postLearningIterationCallback(InferenceStepPtr inference, size_t iterationNumber)
  {
//    *oIteration << (int) iterationNumber << '\t'
//               << getTrainingEvaluation()->getQ3Score() << '\t'
//               << getTestingEvaluation()->getQ3Score()  << '\t'
//               << getTrainingEvaluation()->getQ8Score() << '\t'
//               << getTestingEvaluation()->getQ8Score()  << '\t'
//               << getTrainingEvaluation()->getSA2Score() << '\t'
//               << getTestingEvaluation()->getSA2Score()  << '\t'
//               << (juce::Time::getMillisecondCounter() - startTimeIteration) / 1000. << '\t'
//               << (int) passNumber << '\n';
//    oIteration->flush();
    
    if (getTargetTrainingScore() > bestTrainingScore) {
      bestTrainingScore = getTargetTrainingScore();
      bestTestingScore = getTargetTestingScore();
    }
    
    return true;
  }

  virtual void preLearningStepCallback(InferenceStepPtr step)
  {
//    startTimeIteration = juce::Time::getMillisecondCounter();
//
//    File dst = File::getCurrentWorkingDirectory().getChildFile(prefixFilename + T(".iter_") + lbcpp::toString(passNumber));
//    dst.deleteFile();
//    oIteration = dst.createOutputStream();
    bestTrainingScore = 0.;
    bestTestingScore = 0.;
  }
  
  virtual void postLearningStepCallback(InferenceStepPtr step)
  {
//    jassert(oIteration);
//    delete oIteration;
    jassert(getTarget() != CustomableSecondaryStructureContent::NONE);

    if (!oTargetPass[getTarget()]) {
      static const juce::tchar* targetToString[] = {
        T("SS3"), T("SS8"), T("SA")
      };
      
      File dst = File::getCurrentWorkingDirectory().getChildFile(prefixFilename + T(".") + targetToString[getTarget()]);
      dst.deleteFile();
      oTargetPass[getTarget()] = dst.createOutputStream();
    }

    jassert(oTargetPass[getTarget()]);
    
    *oTargetPass[getTarget()] << (int) targetIteration[getTarget()] << '\t'
          << bestTrainingScore << '\t'
          << bestTestingScore  << '\t'
          << (juce::Time::getMillisecondCounter() - startTimePass) / 1000. << '\n';
    oTargetPass[getTarget()]->flush();
    
    targetIteration[getTarget()]++;
 //   ++passNumber;
  }

private:
  String prefixFilename;
  
//  double startTimeIteration;
  double startTimePass;

  OutputStream* oTargetPass[CustomableSecondaryStructureContent::numberTarget];
//  OutputStream* oIteration;
  
  size_t targetIteration[CustomableSecondaryStructureContent::numberTarget];
//  size_t iterationNumber;
//  size_t passNumber;

  double bestTrainingScore;
  double bestTestingScore;
};

class StoppingCriterionInferenceLearnerCallback : public EvaluationInferenceLearnerCallback
{
public:
  StoppingCriterionInferenceLearnerCallback(size_t maximumIteration)
    : stoppingCriterion(logicalOr(maxIterationsStoppingCriterion(25), maxIterationsWithoutImprovementStoppingCriterion(maximumIteration)))
    {}

  virtual void preLearningStepCallback(InferenceStepPtr step)
    {stoppingCriterion->reset();}

  // returns false if learning should stop
  virtual bool postLearningIterationCallback(InferenceStepPtr inference, size_t iterationNumber)
    {return !stoppingCriterion->shouldOptimizerStop(getTargetTrainingScore());}

private:
  StoppingCriterionPtr stoppingCriterion;
};

class BestStepKeeperInferenceLearnerCallback : public EvaluationInferenceLearnerCallback
{
public:
  BestStepKeeperInferenceLearnerCallback(ProteinInferencePtr proteinInference, String& prefixFilename, size_t firstStepToLearn = 0)
    : proteinInference(proteinInference)
    , prefixFilename(prefixFilename), stepNumber(firstStepToLearn)
    , bestScore(0.)
    {}
  
  virtual void preLearningStepCallback(InferenceStepPtr step)
    {bestScore = 0.;}
  
  // returns false if learning should stop
  virtual bool postLearningIterationCallback(InferenceStepPtr inference, size_t iterationNumber)
  {
    if (getTargetTrainingScore() > bestScore)
    {
      File dst = File::getCurrentWorkingDirectory().getChildFile(prefixFilename);
      inference->saveToFile(dst);
      std::cout << "Save iteration: " << inference->getName()
                << " - Iteration: " << iterationNumber << std::endl;
      bestScore = getTargetTrainingScore();
    }

    return true;
  }
  
  virtual void postLearningStepCallback(InferenceStepPtr step)
  {
    File toLoad = File::getCurrentWorkingDirectory().getChildFile(prefixFilename + T("/decorated.inference/") + lbcpp::toString(stepNumber) + T("_") + step->getName() + T(".inference"));
    jassert(toLoad.exists());
    InferenceStepPtr inference = Object::createFromFileAndCast<InferenceStep>(toLoad);
    jassert(inference);
    std::cout << "Loaded step: " << inference->getName() << std::endl;
    
    proteinInference->setSubStep(stepNumber, inference);
    ++stepNumber;
  }
  
private:
  ProteinInferencePtr proteinInference;

  String prefixFilename;
  size_t stepNumber;

  double bestScore;
};

class StandardOutputInferenceLearnerCallback : public EvaluationInferenceLearnerCallback {
  virtual void preLearningIterationCallback(size_t iterationNumber)
    {std::cout << std::endl << " ================== ITERATION " << iterationNumber << " ================== " << std::endl;}

  // returns false if learning should stop
  virtual bool postLearningIterationCallback(InferenceStepPtr inference, size_t iterationNumber)
  {
    std::cout << "Train evaluation: " << getTrainingEvaluation()->toString() << std::endl;
    std::cout << "Test evaluation: " << getTestingEvaluation()->toString() << std::endl;
    return true;
  }
  
  virtual void preLearningStepCallback(InferenceStepPtr step)
  {
    String passName = step->getName();
    std::cout << std::endl << "=====================================================" << std::endl;
    std::cout << "======= LEARNING PASS " << passName << " ==========" << std::endl;
    std::cout << "=====================================================" << std::endl;
  }
};

/*                                                  *
                Under Heavy Development
 *                                                  */

int main(int argc, char** argv)
{
  declareProteinClasses();
  LBCPP_DECLARE_CLASS(CustomableSecondaryStructureContent);
  
  String proteinsDirectory("/Users/jbecker/Documents/Workspace/CASP9/CB513");
  String prefixResults("result");
  int currentFold = 0;
  //String inferenceModel("CO");
  String predictionTarget("SS3");
  int maxIteration = 5;
  int maxPass = 5;
  int wAA = 10;
  int wPSSM = 10;
  int wSS3 = 10;
  int wSS8 = 10;
  int wSA = 10;
  int wProp = 10;
  double regularizer = 20.0;
  double initialLearningRate = 2.0;
  int numberIterationLearningRate = 150000;
  bool useSavedModel = false;
  
  ArgumentSet arguments;
  arguments.insert(new StringArgument(T("ProteinsDirectory"), &proteinsDirectory));
  arguments.insert(new StringArgument(T("PrefixResults"), &prefixResults));
  arguments.insert(new IntegerArgument(T("CurrentFold"), &currentFold));
  //arguments.insert(new StringArgument(T("InferenceModel"), &inferenceModel));
  arguments.insert(new StringArgument(T("PredictionTarget"), &predictionTarget));
  arguments.insert(new IntegerArgument(T("MaximumIteration"), &maxIteration));
  arguments.insert(new IntegerArgument(T("MaximumPass"), &maxPass));
  arguments.insert(new IntegerArgument(T("AminoAcidWindow"), &wAA));
  arguments.insert(new IntegerArgument(T("PSSMWindow"), &wPSSM));
  arguments.insert(new IntegerArgument(T("PropertyWindow"), &wProp));
  arguments.insert(new IntegerArgument(T("SS3Window"), &wSS3));
  arguments.insert(new IntegerArgument(T("SS8Window"), &wSS8));
  arguments.insert(new IntegerArgument(T("SAWindow"), &wSA));
  arguments.insert(new DoubleArgument(T("Regularizer"), &regularizer));
  arguments.insert(new DoubleArgument(T("InitialLearningRate"), &initialLearningRate));
  arguments.insert(new IntegerArgument(T("NumberIterationLearningRate"), &numberIterationLearningRate));
  arguments.insert(new BooleanArgument(T("UseSavedModel"), &useSavedModel));

  if (!arguments.parse(argv, 1, argc-1))
  {
    std::cout << "Usage: " << argv[0] << " " << arguments.toString() << std::endl;
    return -1;
  }

  File proteinsDirectoryFile = File::getCurrentWorkingDirectory().getChildFile(proteinsDirectory);
  
  enum{nbFolds = 7};
  
  std::cout << "*---- Program Parameters -----" << std::endl;
  std::cout << arguments;
  std::cout << "*-----------------------------" << std::endl;

  ObjectStreamPtr proteinsStream = directoryObjectStream(proteinsDirectoryFile, T("*.protein"));

//#define PSSM
#ifdef PSSM
  while (!proteinsStream->isExhausted()) {
    ProteinPtr myProtein = proteinsStream->nextAndCast<Protein>();
    std::cout << myProtein->getName();
    std::cout.flush();   
 
    File pssmFile("/scratch/jbecker/CB513_PSSM/SOFT_NR_DB/" + myProtein->getName() + T(".pssm"));
    if (!pssmFile.exists()) {
      std::cout << " No pssm file found !" << std::endl;
      continue;
    }
    
    ObjectPtr newPSSM = ObjectStreamPtr(new PSSMFileParser(pssmFile, myProtein->getLength()))->next(); 
    jassert(newPSSM);
    myProtein->setObject(newPSSM);
  
    myProtein->computeProperties();
  
    File outputFile("/scratch/jbecker/CB513_PROTEIN/SOFT/" + myProtein->getName() + T(".protein"));
    myProtein->saveToFile(outputFile);
    
    std::cout << " OK" << std::endl;
  }

  return 0;

#endif
#ifdef VIEW
  ObjectContainerPtr prots = proteinsStream->load(1)->randomize();
  for (size_t i = 0; i < prots->size(); ++i)
  {
    ProteinPtr protein = (ProteinPtr) prots->get(i);
    protein->computeProperties();

    std::cout << protein->toString() << std::endl;
  }
  
  
  return 0;
#endif

  File file("/Users/jbecker/Documents/Workspace/CASP9/aaindex1");
  ObjectStreamPtr aaindex = ObjectStreamPtr(new AAIndexParser(file));

  std::vector< ScoreVectorSequencePtr > vectorAAIndex;


  while (!aaindex->isExhausted()) {
    ScoreVectorSequencePtr score = (ScoreVectorSequencePtr) aaindex->next();
    if (!score) {
      continue;
    }

    vectorAAIndex.push_back(score);
  }


  ObjectContainerPtr proteins = proteinsStream->load(7)->randomize();

  for (size_t i = 0; i < proteins->size(); ++i)
  {
    ProteinPtr protein = (ProteinPtr) proteins->get(i);
    protein->computePropertiesFrom(vectorAAIndex);
  }

  proteins = proteins->apply(new ObjectToObjectPairFunction());

  ObjectContainerPtr trainingData = proteins->invFold(currentFold, nbFolds);
  ObjectContainerPtr testingData = proteins->fold(currentFold, nbFolds);

  std::cout << trainingData->size() << " Training Proteins "
            << testingData->size()  << " Testing Proteins" << std::endl;

  ProteinInferencePtr proteinInference = new ProteinInference();

  CustomableSecondaryStructureContentPtr step;
  /* First Steps */
  if (predictionTarget.contains(T("SS3")))
  {
    step = new CustomableSecondaryStructureContent(T("AA+PSSM -> S3"));
    step->setTarget(CustomableSecondaryStructureContent::SS3);
    step->enableAminoAcidFeatures(wAA);
    step->enablePositionSpecificScoreFeatures(wPSSM);
    step->enablePropertyFeatures(wProp);
    proteinInference->appendStep(step);
  }
  
  if (predictionTarget.contains(T("SS8")))
  {
    step = new CustomableSecondaryStructureContent(T("AA+PSSM -> S8"));
    step->setTarget(CustomableSecondaryStructureContent::SS8);
    step->enableAminoAcidFeatures(wAA);
    step->enablePositionSpecificScoreFeatures(wPSSM);
    step->enablePropertyFeatures(wProp);
    proteinInference->appendStep(step);
  }
  
  if (predictionTarget.contains(T("SA")))
  {
    step = new CustomableSecondaryStructureContent(T("AA+PSSM -> SA"));
    step->setTarget(CustomableSecondaryStructureContent::SA);
    step->enableAminoAcidFeatures(wAA);
    step->enablePositionSpecificScoreFeatures(wPSSM);
    step->enablePropertyFeatures(wProp);
    proteinInference->appendStep(step);
  }
  /* Iterated Steps */
  for (size_t i = 0; i < (size_t) maxPass; ++i) {
    if (predictionTarget.contains(T("SS3"))) {
      step = new CustomableSecondaryStructureContent(T("AA+PSSM+") + predictionTarget + T(" -> SS3 (") + toString(i) + T(")"));
      step->setTarget(CustomableSecondaryStructureContent::SS3);
      step->enableAminoAcidFeatures(wAA);
      step->enablePositionSpecificScoreFeatures(wPSSM);
    step->enablePropertyFeatures(wProp);
      step->enableSecondaryStructure3StatesFeatures(wSS3);
      
      if (predictionTarget.contains(T("SS8")))
        step->enableSecondaryStructure8StatesFeatures(wSS8);
      if (predictionTarget.contains(T("SA")))
        step->enableSolventAccesibility2StatesFeatures(wSA);
      
      proteinInference->appendStep(step);
    }
    
    if (predictionTarget.contains(T("SS8"))) {
      step = new CustomableSecondaryStructureContent(T("AA+PSSM+") + predictionTarget + T(" -> SS8 (") + toString(i) + T(")"));
      step->setTarget(CustomableSecondaryStructureContent::SS8);
      step->enableAminoAcidFeatures(wAA);
      step->enablePositionSpecificScoreFeatures(wPSSM);
    step->enablePropertyFeatures(wProp);
      step->enableSecondaryStructure8StatesFeatures(wSS8);
      
      if (predictionTarget.contains(T("SS3")))
        step->enableSecondaryStructure3StatesFeatures(wSS3);
      if (predictionTarget.contains(T("SA")))
        step->enableSolventAccesibility2StatesFeatures(wSA);
      
      proteinInference->appendStep(step);
    }
    
    if (predictionTarget.contains(T("SA"))) {
      step = new CustomableSecondaryStructureContent(T("AA+PSSM+") + predictionTarget + T(" -> SA (") + toString(i) + T(")"));
      step->setTarget(CustomableSecondaryStructureContent::SA);
      step->enableAminoAcidFeatures(wAA);
      step->enablePositionSpecificScoreFeatures(wPSSM);
    step->enablePropertyFeatures(wProp);
      step->enableSolventAccesibility2StatesFeatures(wSA);
      
      if (predictionTarget.contains(T("SS3")))
        step->enableSecondaryStructure3StatesFeatures(wSS3);
      if (predictionTarget.contains(T("SS8")))
        step->enableSecondaryStructure8StatesFeatures(wSS8);
      
      proteinInference->appendStep(step);
    }
  }

  DefaultInferenceLearnerCallbackPtr factory = new DefaultInferenceLearnerCallback();
  factory->setL2Regularizer(regularizer);
  factory->setInitialLearningRate(initialLearningRate);
  factory->setNumberInterationLearningRate(numberIterationLearningRate);

  MultiInferenceLearnerCallbackPtr callback = new MultiInferenceLearnerCallback(trainingData, testingData, factory);
  callback->useCache(true);
  callback->appendCallback(new StoppingCriterionInferenceLearnerCallback(maxIteration));
  callback->appendCallback(new StandardOutputInferenceLearnerCallback());
  callback->appendCallback(new GnuPlotInferenceLearnerCallback(prefixResults));

  /* Load inference step that we already leaned */
  /*
  size_t firstStepToLearn = 0;
  while (firstStepToLearn < proteinInference->getNumSubSteps())
  {
    File toLoad = File::getCurrentWorkingDirectory().getChildFile(prefixResults + T("/decorated.inference/") + lbcpp::toString(firstStepToLearn) + T("_") + proteinInference->getSubStep(firstStepToLearn)->getName() + T(".inference"));
    if (!toLoad.exists())
      break;

    InferenceStepPtr inference = Object::createFromFileAndCast<InferenceStep>(toLoad);
    jassert(inference);
    
    std::cout << "Loaded step: " << inference->getName() << std::endl;
    
    proteinInference->setSubStep(firstStepToLearn, inference);
    
    ++firstStepToLearn;
  }
  */

  /* Load saved model */
  size_t firstStepToLearn = 0;
  while (useSavedModel && firstStepToLearn < proteinInference->getNumSubSteps())
  {
    File toLoad = File::getCurrentWorkingDirectory().getChildFile(T("SAVED_MODEL/") + lbcpp::toString(firstStepToLearn) + T("_") + proteinInference->getSubStep(firstStepToLearn)->getName() + T(".inference"));
    if (!toLoad.exists())
      break;

    InferenceStepPtr inference = Object::createFromFileAndCast<InferenceStep>(toLoad);
    jassert(inference);
    
    std::cout << "Loaded step: " << inference->getName() << std::endl;
    
    proteinInference->setSubStep(firstStepToLearn, inference);
    
    ++firstStepToLearn;
  }

  callback->appendCallback(new BestStepKeeperInferenceLearnerCallback(proteinInference, prefixResults, firstStepToLearn));
  stepByStepDeterministicSimulationLearner(callback, true, firstStepToLearn)->train(proteinInference, trainingData);

  return 0;
}
