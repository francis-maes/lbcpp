/*-----------------------------------------.---------------------------------.
| Filename: FromScratch.lcpp               | Test Learning                   |
| Author  : Francis Maes                   |                                 |
| Started : 08/04/2010 16:27               |                                 |
`------------------------------------------/                                 |
                               |                                             |
                               `--------------------------------------------*/

#include <lbcpp/lbcpp.h>
#include "InferenceCallback/InferenceLearner.h"
#include "ProteinInference/ProteinEvaluationCallback.h"
#include "ProteinInference/ProteinInference.h"
using namespace lbcpp;

extern void declareProteinClasses();

class SSContentOnlyInferenceStep : public SecondaryStructureInferenceStep
{
public:
  SSContentOnlyInferenceStep(const String& name, bool useDSSPElements)
    : SecondaryStructureInferenceStep(name, useDSSPElements) {}

  virtual featureGenerator getInputFeatures(ObjectPtr input, size_t index) const
  {
    ProteinPtr protein = input.dynamicCast<Protein>();
    jassert(protein);
    LabelSequencePtr aminoAcidSequence = protein->getAminoAcidSequence();
    ScoreVectorSequencePtr positionSpecificScores = protein->getPositionSpecificScoringMatrix();

    featureCall("a") inline aminoAcidSequence->windowFeatures(index, 10, 10, true);
    featureCall("p") inline positionSpecificScores->windowFeatures(index, 10, 10, true);
  }
};

class SSContentAndStructureInferenceStep : public SecondaryStructureInferenceStep
{
public:
  SSContentAndStructureInferenceStep(const String& name, bool useDSSPElements)
    : SecondaryStructureInferenceStep(name, useDSSPElements) {}

  virtual featureGenerator getInputFeatures(ObjectPtr input, size_t index) const
  {
    ProteinPtr protein = input.dynamicCast<Protein>();
    jassert(protein);
    LabelSequencePtr aminoAcidSequence = protein->getAminoAcidSequence();
    ScoreVectorSequencePtr positionSpecificScores = protein->getPositionSpecificScoringMatrix();
    LabelSequencePtr secondaryStructure = protein->getSecondaryStructureSequence();
    LabelSequencePtr dsspSecondaryStructure = protein->getDSSPSecondaryStructureSequence();

    featureCall("a") aminoAcidSequence->windowFeatures(index, 10, 10, true);
    featureCall("p") positionSpecificScores->windowFeatures(index, 10, 10, true);
    featureCall("w3") secondaryStructure->windowFeatures(index, 10, 10, true);
    featureCall("w8") dsspSecondaryStructure->windowFeatures(index, 10, 10, true);
  }
};

class MyInferenceFactory : public InferenceFactory
{
public:
  virtual ClassifierPtr createClassifier(FeatureDictionaryPtr labels)
  {
    static const double regularizer = 20.0;
    static const bool useConstantLearningRate = false;

    IterationFunctionPtr learningRate = useConstantLearningRate ? invLinearIterationFunction(2.0, 150000) : constantIterationFunction(1.0);
    GradientBasedLearnerPtr learner = stochasticDescentLearner(learningRate);  
    GradientBasedClassifierPtr classifier = maximumEntropyClassifier(learner, labels);
    classifier->setL2Regularizer(regularizer);
    return classifier;
  }
};

class MyInferenceLearnerCallback : public InferenceLearnerCallback
{
public:
  MyInferenceLearnerCallback(ObjectContainerPtr testingData)
    : testingData(testingData) {}

  virtual void preLearningIterationCallback(size_t iterationNumber)
    {std::cout << std::endl << " ================== ITERATION " << iterationNumber << " ================== " << std::endl;}

  // returns false if learning should stop
  virtual bool postLearningIterationCallback(InferenceStepPtr inference, InferenceContextPtr validationContext, InferenceCallbackPtr evaluation, size_t iterationNumber)
  {
    std::cout << "Online evaluation: " << evaluation->toString() << std::endl;
    validationContext->runWithSupervisedExamples(inference, testingData);
    std::cout << "Validation evaluation: " << evaluation->toString() << std::endl;
    return iterationNumber < 100;
  }

  virtual void preLearningPassCallback(const String& passName)
  {
    std::cout << std::endl << "=====================================================" << std::endl;
    std::cout << "======= LEARNING PASS " << passName << " ==========" << std::endl;
    std::cout << "=====================================================" << std::endl;
  }

  virtual InferenceContextPtr createContext()
    {return singleThreadedInferenceContext(new MyInferenceFactory());}

  virtual InferenceCallbackPtr createEvaluationCallback()
    {return new ProteinEvaluationCallback();}

private:
  ObjectContainerPtr testingData;
};

#if 0
class ArgumentParser
{
  public:
  enum ArgumentType {UNKNOWN, INTEGER, FLOAT, BOOLEAN, STRING};
  
  void append(String& name, ArgumentType type, void* destination, String& description)
  {
    std::vector<Argument> vec = arguments[name];
    if (!vec.size()) {
      vec.resize(10);
      arguments[name] = vec;
    }
    
    Argument new_argument = {type, destination, description};
    vec[vec.size()] = new_argument;
  }
  
  String toString()
  {
    String toReturn("");
    for (std::map<String, std::vector<Argument> >::const_iterator iter = arguments.begin(); iter != arguments.end(); ++iter) {
      toString += String(" '") + iter->first + String("'");
      for (size_t i = 0; i < iter->second.size(); ++i) {
        toString += String(" ") + iter->second[i].description;
      }
    }
  }
  
  private:
  struct Argument {
    ArgumentType type;
    void* destination;
    String description;
  };

  std::map<String, std::vector<Argument> > arguments;
};
#endif // 0

int main(int argc, char** argv)
{
  declareProteinClasses();
  
  size_t nextArgument = 1;
  String sourceDir(argv[nextArgument++]);
  
  
  

//  File modelFile(T("C:\\Projets\\Proteins\\data\\models\\test.model"));

  File proteinsDirectory(sourceDir);
  ObjectStreamPtr proteinsStream = directoryObjectStream(proteinsDirectory, T("*.protein"));
  ObjectContainerPtr proteins = proteinsStream->load()->randomize()->apply(new ObjectToObjectPairFunction());

  ObjectContainerPtr trainingData = proteins->invFold(0, 7);
  ObjectContainerPtr testingData = proteins->fold(0, 7);
  std::cout << trainingData->size() << " Training Proteins "
            << testingData->size() << " Testing Proteins" << std::endl;

  ProteinInferencePtr proteinInference = new ProteinInference();
  proteinInference->appendStep(new SSContentOnlyInferenceStep(T("AA+PSSM -> S3"), false), T("SecondaryStructureSequence"));
  proteinInference->appendStep(new SSContentOnlyInferenceStep(T("AA+PSSM -> S8"), true), T("DSSPSecondaryStructureSequence"));
  for (size_t i = 0; i < 5; ++i)
  {
    proteinInference->appendStep(new SSContentAndStructureInferenceStep(T("AA+PSSM+S3+S8 -> S3 (") + lbcpp::toString(i) + T(")"), false), T("SecondaryStructureSequence"));
    proteinInference->appendStep(new SSContentAndStructureInferenceStep(T("AA+PSSM+S3+S8 -> S8 (") + lbcpp::toString(i) + T(")"), true), T("DSSPSecondaryStructureSequence"));
  }

  InferenceLearnerCallbackPtr callback = new MyInferenceLearnerCallback(testingData);
  InferenceLearnerPtr learner = stepByStepSimulationInferenceLearner(callback);
  learner->train(proteinInference, trainingData);
  return 0;
}
