/*-----------------------------------------.---------------------------------.
| Filename: SandBox.lcpp                   | Test Learning                   |
| Author  : Francis Maes                   |                                 |
| Started : 08/04/2010 16:27               |                                 |
`------------------------------------------/                                 |
                               |                                             |
                               `--------------------------------------------*/

#include <lbcpp/lbcpp.h>
#include "InferenceStep/RegressionInferenceStep.h"
#include "InferenceStep/ParallelSharedMultiRegressionInferenceStep.h"
#include "InferenceLearner/InferenceLearner.h"
#include "InferenceLearner/InferenceLearnerCallback.h"
#include "InferenceContext/CacheInferenceCallback.h"
#include "InferenceData/ScoreSymmetricMatrix.h"
#include "InferenceData/CommonFeatureGenerators.h"
#include "Protein/Evaluation/ProteinEvaluationCallback.h"
#include "Protein/Evaluation/ProteinStatisticsCalculator.h"
#include "Protein/SecondaryStructureDictionary.h"
#include "Protein/Inference/Protein1DInferenceStep.h"
#include "Protein/Inference/ProteinBackboneBondSequenceInferenceStep.h"
#include "Protein/Inference/ProteinContactMapInferenceStep.h"
#include "Protein/Inference/ProteinTertiaryStructureInferenceStep.h"
#include "Protein/Inference/ProteinInference.h"
#include "Geometry/kdtree.h"
using namespace lbcpp;

extern void declareProteinClasses();

class AbsoluteDifferenceScalarFunction : public ScalarFunction
{
public:
  AbsoluteDifferenceScalarFunction(double reference = 0.0)
    : reference(reference) {jassert(isNumberValid(reference));}

  virtual bool isDerivable() const
    {return false;}

  virtual void compute(double input, double* output, const double* derivativeDirection, double* derivative) const
  {
    if (output)
      *output = fabs(input - reference);
    if (derivative)
      *derivative = input > reference ? 1.0 : (input < reference ? -1.0 : 0.0);
  }

protected:
  double reference;

  virtual bool load(InputStream& istr)
    {return ScalarFunction::load(istr) && lbcpp::read(istr, reference);}

  virtual void save(OutputStream& ostr) const
    {ScalarFunction::save(ostr); lbcpp::write(ostr, reference);}
};

// Input: Features
// Output: direction Vector3Object 
// Supervision: target Vector3Object
class Vector3InferenceStep : public VectorParallelInferenceStep
{
public:
  Vector3InferenceStep(const String& name)
    : VectorParallelInferenceStep(name)
  {
    appendRegressionStep(T("x"));
    appendRegressionStep(T("y"));
    appendRegressionStep(T("z"));
  }

  void appendRegressionStep(const String& name)
  {
    RegressionInferenceStepPtr regressionInference = new RegressionInferenceStep(getName() + T(" ") + name);
    //appendStep(new TransferRegressionInferenceStep(regressionInference->getName(), regressionInference, new ScaledSigmoidScalarFunction(-1.0, 1.1)));
    appendStep(regressionInference);
  }

  virtual ObjectPtr createEmptyOutput(ObjectPtr input) const
    {return new Vector3Object(0.0);}
 
  virtual ObjectPtr getSubInput(ObjectPtr input, size_t index) const
    {return input;}

  virtual ObjectPtr getSubSupervision(ObjectPtr supervision, size_t index, ObjectPtr predictedObject) const
  {
    Vector3ObjectPtr vo = supervision.dynamicCast<Vector3Object>();
    jassert(vo);
    Vector3 v = vo->getValue();
    double target = (index == 0 ? v.getX() : (index == 1 ? v.getY() : v.getZ()));
    // loss(prediction) = (target - prediction)^2
    if (target == DBL_MAX)
      return ObjectPtr();
    return squareFunction(addConstantScalarFunction(-target)); //new AbsoluteDifferenceScalarFunction(target);
  }

  virtual void setSubOutput(ObjectPtr output, size_t index, ObjectPtr subOutput) const
  {
    Vector3ObjectPtr res = output.dynamicCast<Vector3Object>();
    ScalarPtr value = subOutput.dynamicCast<Scalar>();
    jassert(res && value);
    if (index == 0)
      res->getValue().setX(value->getValue());
    else if (index == 1)
      res->getValue().setY(value->getValue());
    else if (index == 2)
      res->getValue().setZ(value->getValue());
  }
};

class ProteinCAlphaTraceUpdateInferenceStep : public Protein1DInferenceStep
{
public:
  ProteinCAlphaTraceUpdateInferenceStep(const String& name, ProteinResidueFeaturesPtr features)
    : Protein1DInferenceStep(name, new Vector3InferenceStep(name + T(" Pos")), features, T("CAlphaTrace")) {}
  
  ProteinCAlphaTraceUpdateInferenceStep() {}

  virtual ObjectPtr createEmptyOutput(ObjectPtr input) const
  {
    ProteinPtr protein = getProtein(input);
    CartesianCoordinatesSequencePtr calphaTrace = protein->getCAlphaTrace();
    jassert(calphaTrace);
    return calphaTrace->clone();
  }

  static double lerp(double a, double b, double k) {return a + k * (b - a);}

  static void applyBoundConstraints(double& valueToConstrain, double minimum, double maximum, double intensity = 1.0)
  {
    jassert(minimum <= maximum);
    if (valueToConstrain < minimum)
      valueToConstrain = lerp(valueToConstrain, minimum, 1.0);
    if (valueToConstrain > maximum)
      valueToConstrain = lerp(valueToConstrain, maximum, 1.0);
  }

  static void applyPreferedValueConstraint(double& value, double preferredValue, double intensity)
    {value = lerp(value, preferredValue, intensity);}

  static CartesianCoordinatesSequencePtr applyCAlphaConstraints(CartesianCoordinatesSequencePtr calphaTrace, bool lengthConstraints, bool angleConstraints, double intensity = 1.0)
  {
    BondCoordinatesSequencePtr bonds = new BondCoordinatesSequence(T("bonds"), calphaTrace);
    for (size_t i = 0; i < bonds->size(); ++i)
    {
      BondCoordinates b = bonds->getCoordinates(i);
      if (!b.exists())
        continue;
      if (lengthConstraints && b.hasLength())
      {
        double length = b.getLength();
        applyBoundConstraints(length, 3.65, 3.95, intensity);
        applyPreferedValueConstraint(length, 3.8, intensity / 30.0);
        b.setLength(length);
      }
      if (angleConstraints && b.hasThetaAngle())
      {
        double angle = b.getThetaAngle();
        applyBoundConstraints(angle, 0.95, 2.75, intensity);
        applyPreferedValueConstraint(angle, 1.85, intensity / 30.0);
        b.setThetaAngle(angle);
      }
      bonds->setCoordinates(i, b);
    }
    return bonds->makeCartesianCoordinates(T("CAlphaTrace"));
  }

  virtual ObjectPtr run(InferenceContextPtr context, ObjectPtr input, ObjectPtr supervision, ReturnCode& returnCode)
  {
    ObjectPtr res = Protein1DInferenceStep::run(context, input, supervision, returnCode);
    CartesianCoordinatesSequencePtr prediction = res.dynamicCast<CartesianCoordinatesSequence>();
    jassert(prediction);
    return applyCAlphaConstraints(prediction, true, true, 0.9);
  }

  static double computeSupervisionWeight(int deltaPosition, int windowHalfSize)
  {
 //   jassert(deltaPosition >= -windowHalfSize && deltaPosition <= windowHalfSize);
//    double stddev = (double)windowHalfSize / 2.0;
    return 1.0;//exp(-(double)(deltaPosition * deltaPosition) / (stddev * stddev));
  }

  void computeSupervision(CartesianCoordinatesSequencePtr predicted, CartesianCoordinatesSequencePtr correct, std::vector<Vector3>& res, int halfWindowSize = 30) const
  {
    size_t n = predicted->size();
    jassert(n == correct->size());

    res.clear();
    res.resize(n, Vector3(0.0));
    std::vector<double> weights(n, 0.0);

    std::vector< std::pair<Vector3, Vector3 > > pointPairs;
    pointPairs.reserve(2 * halfWindowSize + 1);

    for (size_t position = 0; position < n; ++position)
    {
      int first = juce::jmax(0, (int)position - (int)halfWindowSize);
      int last = juce::jmin((int)n - 1, (int)position + (int)halfWindowSize);

      pointPairs.clear();
      for (int i = first; i <= last; ++i)
      {
        Vector3 p = predicted->getPosition(i);
        Vector3 c = correct->getPosition(i);
        if (p.exists() && c.exists())
          pointPairs.push_back(std::make_pair(c, p));
      }
      bool success;
      Matrix4 affineTransform = Matrix4::findAffineTransformToSuperposePoints(pointPairs, &success);
      if (success)
      {
        for (int i = first; i <= last; ++i)
        {
          Vector3 c = correct->getPosition(i);
          if (c.exists())
          {
            Vector3 target = affineTransform.transformAffine(c);
            double w = computeSupervisionWeight(i - (int)position, halfWindowSize);
            res[i].addWeighted(target, w);
            weights[i] += w;
          }
        }
      }
    }

    for (size_t i = 0; i < n; ++i)
    {
      //std::cout << "i = " << i << " weight = " << weights[i];
      if (weights[i])
      {
        res[i] /= weights[i];
        //std::cout << "current: " << predicted->getPosition(i).toString() << " Supervision = " << res[i].toString() << " " << std::endl;
        jassert(isNumberValid(res[i].getX()) && isNumberValid(res[i].getY()) && isNumberValid(res[i].getZ()));
      }
      else
      {
        res[i] = Vector3();
        //std::cout << std::endl;
      }
    }

    double error = 0.0;
    size_t count = 0;
    for (size_t i = 0; i < n; ++i)
      if (predicted->getPosition(i).exists() && res[i].exists())
      {
        error = (predicted->getPosition(i) - res[i]).sumOfSquares();
        ++count;
      }
    if (count)
      error /= count;
    if (sqrt(error) > 50)
      std::cout << "Supervision RMSE = " << sqrt(error) << " protein = " << currentTarget->getName() << std::endl;
  }

  virtual ObjectPtr getSubSupervision(ObjectPtr supervision, size_t index, ObjectPtr predictedObject) const
  {
    ProteinPtr protein = getProtein(supervision);
    CartesianCoordinatesSequencePtr predictedCAlphaTrace = predictedObject.dynamicCast<CartesianCoordinatesSequence>();
    jassert(predictedCAlphaTrace);
    Vector3 predictedPosition = predictedCAlphaTrace->getPosition(index);

    if (currentTarget != protein || currentPredictedCAlphaTrace != predictedCAlphaTrace)
    {
      CartesianCoordinatesSequencePtr correctCAlphaTrace = protein->getCAlphaTrace();
      jassert(predictedCAlphaTrace && correctCAlphaTrace);

      ProteinCAlphaTraceUpdateInferenceStep* nonConstThis = const_cast<ProteinCAlphaTraceUpdateInferenceStep* >(this);
      nonConstThis->currentTarget = protein;
      nonConstThis->currentPredictedCAlphaTrace = predictedCAlphaTrace;
      computeSupervision(predictedCAlphaTrace, correctCAlphaTrace, nonConstThis->currentSupervision, 50);
    }
    else
      jassert(currentTarget->getName() == protein->getName());

    jassert(index < currentSupervision.size());
    if (!currentSupervision[index].exists())
      return ObjectPtr();
    jassert(predictedPosition.exists());
    /*if (index == 51)
    {
      std::cout << ">>Current position: " << predictedPosition.toString() << " supervision target: " << currentSupervision[index].toString() << std::endl;
    }*/
    return new Vector3Object(currentSupervision[index] - predictedPosition);
  }

  virtual void setSubOutput(ObjectPtr output, size_t index, ObjectPtr subOutput) const
  {
    CartesianCoordinatesSequencePtr calphaTrace = output.dynamicCast<CartesianCoordinatesSequence>();
    Vector3ObjectPtr delta = subOutput.dynamicCast<Vector3Object>();
    jassert(calphaTrace && delta);
    //std::cout << calphaTrace->getPosition(index).toString() << " + " << delta->getValue().toString() << " => ";
    calphaTrace->setPosition(index, calphaTrace->getPosition(index) + delta->getValue());
    //std::cout << calphaTrace->getPosition(index).toString() << std::endl;
    
    //if (index == 51)
    //  std::cout << ">>Predicted Delta: " << delta->getValue().toString() << " new position: " << calphaTrace->getPosition(index).toString() << std::endl;
    //jassert(index < currentSupervision.size());
    //calphaTrace->setPosition(index, currentSupervision[index]);

    //if (index == 51)
    //  std::cout << ">>Hack to supervision target: " << currentSupervision[index].toString() << std::endl;
  }

private:
  ProteinPtr currentTarget;
  CartesianCoordinatesSequencePtr currentPredictedCAlphaTrace;
  std::vector<Vector3> currentSupervision;
};

class KDTree : public Object
{
public:
  KDTree(size_t dimension)
    {tree = kd_create(dimension);}

  virtual ~KDTree()
  {
    if (tree)
      kd_free(tree);
  }

  void insert(size_t index, const Vector3& position)
    {jassert(position.exists()); kd_insert3(tree, position.getX(), position.getY(), position.getZ(), (void*)index);}

  void findPointsInSphere(const Vector3& center, double radius, std::vector<size_t>& results)
  {
    jassert(center.exists());
    struct kdres* res = kd_nearest_range3(tree, center.getX(), center.getY(), center.getZ(), radius);
    results.resize(kd_res_size(res));
    for (size_t i = 0; i < results.size(); ++i)
    {
      jassert(!kd_res_end(res));
      results[i] = (size_t)kd_res_item_data(res);
      kd_res_next(res);
    }
    kd_res_free(res);
  }

private:
  struct kdtree* tree;
};
typedef ReferenceCountedObjectPtr<KDTree> KDTreePtr;

class MyCalphaUpdateFeatures : public ProteinResidueFeatures
{
public:
  featureGenerator deltaFeatures(const Vector3& current, const Vector3& target)
  {
    jassert(current.exists() && target.exists());
    featureSense(0, target.getX() - current.getX());
    featureSense(1, target.getY() - current.getY());
    featureSense(2, target.getZ() - current.getZ());
  }

  virtual featureGenerator compute(ProteinPtr protein, size_t position)
  {
    LabelSequencePtr aminoAcids = protein->getAminoAcidSequence();
    CartesianCoordinatesSequencePtr calphaTrace = protein->getCAlphaTrace();
    jassert(calphaTrace && aminoAcids);

    if (currentInputCAlphaTrace != calphaTrace)
    {
      gravityCenter = calphaTrace->getGravityCenter();
      currentInputCAlphaTrace = calphaTrace;
      kdTree = new KDTree(3);
      for (size_t i = 0; i < calphaTrace->size(); ++i)
      {
        Vector3 position = calphaTrace->getPosition(i);
        if (position.exists())
          kdTree->insert(i, position);
      }
    }

    Vector3 currentPosition = calphaTrace->getPosition(position);
    jassert(currentPosition.exists());

    std::vector<size_t> pointsInSphere;
    kdTree->findPointsInSphere(currentPosition, 20, pointsInSphere);
   // std::cout << "Points in sphere: " << pointsInSphere.size() << std::endl;

    size_t n = calphaTrace->size();
    //  featureScope(position)
    //    featureSense(0);

    featureScope(protein->getVersionNumber())
    //featureScope(aminoAcids->getIndex(position))
    { 
      /*
      for (int i = (int)position - 10; i < (int)position + 10; ++i)
        if (i >= 0 && i < (int)n && i != (int)position)
        {
          Vector3 otherPosition = calphaTrace->getPosition(i);
          if (otherPosition.exists())
          {
            int ii = i - (position - 10);
            jassert(ii >= 0);
            //featureScope(aminoAcids->getIndex(ii))
              featureCall((size_t)ii) deltaFeatures(currentPosition, otherPosition);
          }
        }*/

      featureCall(0) deltaFeatures(currentPosition, gravityCenter);
      for (size_t i = 0; i < pointsInSphere.size(); ++i)
      {
        Vector3 pointInSphere = calphaTrace->getPosition(pointsInSphere[i]);
        jassert(pointInSphere.exists());

        double distance = (pointInSphere - currentPosition).l2norm();
        if (distance == 0)
          continue;
        jassert(distance < 20.0);
        size_t discreteSize = (size_t)(distance / 2.0);
        //featureScope(aminoAcids->getIndex(pointsInSphere[i]))
          featureCall(1 + discreteSize) deltaFeatures(currentPosition, pointInSphere);
      }
    }
  }

protected:
  CartesianCoordinatesSequencePtr currentInputCAlphaTrace;
  Vector3 gravityCenter;
  KDTreePtr kdTree;
};

/////////////////////////////////////////////////////////////////////

class GeometricConstraint : public Object
{
public:
  GeometricConstraint(double importance = 1.0) : importance(importance) {}

  virtual void apply(std::vector<Vector3>& coordinates, double amount) = 0;
  virtual double computeError(const std::vector<Vector3>& coordinates) = 0;

protected:
  double importance;
};

typedef ReferenceCountedObjectPtr<GeometricConstraint> GeometricConstraintPtr;

class BinaryGeometricConstraint : public GeometricConstraint
{
public:
  BinaryGeometricConstraint(size_t i, size_t j, double importance)
    : GeometricConstraint(importance), i(i), j(j) {}

protected:
  size_t i;
  size_t j;
};

class AngleGeometricConstraint : public GeometricConstraint
{
public:
  AngleGeometricConstraint(size_t index, double minAngle, double maxAngle, double importance)
    : GeometricConstraint(importance), index(index), minAngle(minAngle), maxAngle(maxAngle) {}

  virtual void apply(std::vector<Vector3>& coordinates, double amount)
  {
    jassert(index > 0 && index < coordinates.size() - 1);
    Vector3 a = coordinates[index - 1];
    Vector3 b = coordinates[index];
    Vector3 c = coordinates[index + 1];
    Vector3 t = (a + c) / 2.0;
    jassert(a.exists() && b.exists() && c.exists());

    int numIters = (int)(10.0 * importance);
    for (int i = 0; (b - a).angle(c - a) < minAngle && i < numIters; ++i)
      a += (t - a) * 0.1 * amount * importance;
    for (int i = 0; (b - a).angle(c - a) > maxAngle && i < numIters; ++i)
      a -= (t - a) * 0.1 * amount * importance;
  }

  virtual double computeError(const std::vector<Vector3>& coordinates)
    {return 0.0;}

protected:
  size_t index;
  double minAngle;
  double maxAngle;
};

class LengthGeometricConstraint : public BinaryGeometricConstraint
{
public:
  LengthGeometricConstraint(size_t i, size_t j, double minLength, double maxLength, double importance)
    : BinaryGeometricConstraint(i, j, importance), minLength(minLength), maxLength(maxLength) {}

  virtual void apply(std::vector<Vector3>& coordinates, double amount)
  {
    Vector3 A = coordinates[i];
    Vector3 B = coordinates[j];
    jassert(A.exists() && B.exists());
    Vector3 D = (B - A);
    double oldNorm = D.l2norm();
    jassert(oldNorm);
    if (!oldNorm)
      return;
    double length = juce::jlimit(minLength, maxLength, oldNorm);
    if (length == oldNorm)
      return;
    double newNorm = oldNorm + importance * amount * (length - oldNorm);
    D *= newNorm / (2 * oldNorm);
    Vector3 M = (A + B) / 2.0;
    coordinates[i] = M - D;
    coordinates[j] = M + D;
  }

  virtual double computeError(const std::vector<Vector3>& coordinates)
  {
    Vector3 A = coordinates[i];
    Vector3 B = coordinates[j];
    jassert(A.exists() && B.exists());
    double l = (A - B).l2norm();
    if (l < minLength)
      return fabs(l - minLength);
    else if (l > maxLength)
      return fabs(l - maxLength);
    else
      return 0.0;
  }

protected:
  double minLength, maxLength;
};

class RefineCAlphaPositionsInferenceStep : public SharedParallelInferenceStep
{
public:
  RefineCAlphaPositionsInferenceStep(const String& name, ProteinResiduePairFeaturesPtr featureFunction)
    : SharedParallelInferenceStep(name, new RegressionInferenceStep(name)), featureFunction(featureFunction) {}

  virtual size_t getNumSubInferences(ObjectPtr input) const
  {
    ProteinPtr protein = input.dynamicCast<Protein>();
    if (protein != currentInputProtein)
    {
      RefineCAlphaPositionsInferenceStep* nonConstThis = const_cast<RefineCAlphaPositionsInferenceStep* >(this);
      nonConstThis->currentInputProtein = protein;
      nonConstThis->inputProteinChangedCallback(protein);
    }
    return pairsInContact.size();// + protein->getLength() - 2;
  }

  virtual ObjectPtr getSubInput(ObjectPtr input, size_t index) const
    {return featureFunction->compute(input.dynamicCast<Protein>(), pairsInContact[index].first, pairsInContact[index].second);}

  ProteinPtr currentSupervisionProtein;

  virtual ObjectPtr getSubSupervision(ObjectPtr supervision, size_t index, ObjectPtr predictedObject) const
  {
    ProteinPtr protein = supervision.dynamicCast<Protein>();
    const_cast<RefineCAlphaPositionsInferenceStep*>(this)->currentSupervisionProtein = protein;
    jassert(protein);
    CartesianCoordinatesSequencePtr correctCalphaTrace = protein->getCAlphaTrace();
    jassert(correctCalphaTrace); 

    double target;
    if (index < pairsInContact.size())
    {
      size_t i = pairsInContact[index].first;
      size_t j = pairsInContact[index].second;
      jassert(j > i);

      if (!correctCalphaTrace->hasPosition(i) || !correctCalphaTrace->hasPosition(j))
        return ObjectPtr();

      target = (correctCalphaTrace->getPosition(i) - correctCalphaTrace->getPosition(j)).l2norm();
    }
    else
    {
      index -= pairsInContact.size();
      jassert(index < protein->getLength() - 2);
      Vector3 a = correctCalphaTrace->getPosition(index);
      Vector3 b = correctCalphaTrace->getPosition(index + 1);
      Vector3 c = correctCalphaTrace->getPosition(index + 2);
      if (!a.exists() || !b.exists() || !c.exists())
        return ObjectPtr();
      target = (a - b).angle(c - b);
    }
    return squareFunction(addConstantScalarFunction(-target));
  }

  virtual ObjectPtr createEmptyOutput(ObjectPtr input) const
  {
    VectorObjectContainerPtr res = new VectorObjectContainer(T("Constraints"));
   /* ProteinPtr protein = input.dynamicCast<Protein>();
    size_t n = protein->getLength();
    for (size_t i = 0; i < n - 1; ++i)
    {
      res->append(new LengthGeometricConstraint(i, i + 1, 3.65, 3.95, 1.0));
      res->append(new LengthGeometricConstraint(i, i + 1, 3.8, 3.8, 0.1));
      if (i > 0)
      {
        res->append(new AngleGeometricConstraint(i, 0.95, 2.75, 1.0));
        res->append(new AngleGeometricConstraint(i, 1.85, 1.85, 0.1));
      }
    }*/
    return res;
  }

  virtual void setSubOutput(ObjectPtr output, size_t index, ObjectPtr subOutput) const
  {
    VectorObjectContainerPtr constraints = output.dynamicCast<VectorObjectContainer>();
    ScalarPtr scalar = subOutput.dynamicCast<Scalar>();
    jassert(constraints && scalar);
    if (scalar->getValue() <= 0.0)
      return;

   /* CartesianCoordinatesSequencePtr correct = currentSupervisionProtein->getCAlphaTrace();
    if (!correct->hasPosition(i) || !correct->hasPosition(j))
      return;
    double pouet = (correct->getPosition(i) - correct->getPosition(j)).l2norm();
    if (scalar->getValue() && fabs(scalar->getValue() - pouet) > 0.1)
      std::cout << "ERROR = " << fabs(scalar->getValue() - pouet) << " correct = " << pouet << " predicted = " << scalar->getValue() << std::endl;
*/
    if (index < pairsInContact.size())
    {
      size_t i = pairsInContact[index].first;
      size_t j = pairsInContact[index].second;

      if (j == i + 1)
        return;
      double value = scalar->getValue();
      constraints->append(new LengthGeometricConstraint(i, j, scalar->getValue(), scalar->getValue(), 1.0));
    }
    else
    {
      index -= pairsInContact.size();
      constraints->append(new AngleGeometricConstraint(index + 1, scalar->getValue(), scalar->getValue(), 100.0));
    }
  }

  virtual ObjectPtr run(InferenceContextPtr context, ObjectPtr input, ObjectPtr supervision, ReturnCode& returnCode)
  {
    ObjectPtr res = SharedParallelInferenceStep::run(context, input, supervision, returnCode);
    VectorObjectContainerPtr constraints = res.dynamicCast<VectorObjectContainer>();
    jassert(constraints && currentInputCalphaTrace);

    CartesianCoordinatesSequencePtr predictedCalphaTrace = currentInputCalphaTrace->clone();
    for (size_t iteration = 0; iteration < 10; ++iteration)
    {
      std::vector<size_t> order;
      RandomGenerator::getInstance().sampleOrder(constraints->size(), order);
      double error = 0.0;
      for (size_t i = 0; i < order.size(); ++i)
      {
        GeometricConstraintPtr constraint = constraints->getAndCast<GeometricConstraint>(i);
        jassert(constraint);
        error += constraint->computeError(predictedCalphaTrace->getVectorOfPositions());
        constraint->apply(predictedCalphaTrace->getVectorOfPositions(), 1.0);
      }
      //std::cout << iteration << " Mean error before : " << error / order.size() << std::endl;
    }
    return predictedCalphaTrace;// ProteinCAlphaTraceUpdateInferenceStep::applyCAlphaConstraints(predictedCalphaTrace, true, false);
  }

private:
  ProteinResiduePairFeaturesPtr featureFunction;

  ProteinPtr currentInputProtein;
  CartesianCoordinatesSequencePtr currentInputCalphaTrace;
  KDTreePtr kdTree;
  std::vector< std::pair<size_t, size_t> > pairsInContact;

  void inputProteinChangedCallback(ProteinPtr protein)
  {
    double contactRadius = 12.0;

    kdTree = new KDTree(3);
    currentInputCalphaTrace = protein->getCAlphaTrace();
    jassert(currentInputCalphaTrace);
    size_t n = protein->getLength();
    for (size_t i = 0; i < n; ++i)
    {
      Vector3 p = currentInputCalphaTrace->getPosition(i);
      if (p.exists())
        kdTree->insert(i, p);
    }

    pairsInContact.clear();
    for (size_t i = 0; i < n; ++i)
    {
      Vector3 p = currentInputCalphaTrace->getPosition(i);
      if (p.exists())
      {
        std::vector<size_t> indices;
        while (indices.size() < 2)
        {
          indices.clear();
          kdTree->findPointsInSphere(p, contactRadius, indices);
          contactRadius *= 1.5;
        }

        // add some randomly selected contacts
        //for (size_t k = 0; k < 30; ++k)
        //  indices.push_back(RandomGenerator::getInstance().sampleSize(n));

        for (size_t jj = 0; jj < indices.size(); ++jj)
        {
          size_t j = indices[jj];
          if (j <= i)
            continue;
        //  if (abs((int)i - (int)j) <= 6 && RandomGenerator::getInstance().sampleBool(0.9))
        //    continue; // skip short links
          pairsInContact.push_back(std::make_pair(i, j));
        }
      }
    }
  }
};

typedef ReferenceCountedObjectPtr<RefineCAlphaPositionsInferenceStep> RefineCAlphaPositionsInferenceStepPtr;

class TriDimProteinResiduePairFeatures : public ProteinResiduePairFeatures
{
public:
  featureGenerator pairGeometricFeatures(const Vector3& s1, const Vector3& s2, const Vector3& s3,
                                        const Vector3& d1, const Vector3& d2, const Vector3& d3)
  {
    if (!s2.exists() || !d2.exists())
      return;
    featureCall(0) numberLogFeatures((s2 - d2).l2norm());
    if (!s1.exists() || !d1.exists())
      return;
    featureCall(1) numberLogFeatures((s2 - s1).dotProduct(d2 - d1));
    if (!s3.exists() || !d3.exists())
      return;
    featureCall(2) numberLogFeatures((s3 - s1).dotProduct(d3 - d1));
    Vector3 snormal = (s2 - s1).crossProduct(s3 - s2);
    Vector3 dnormal = (d2 - d1).crossProduct(d3 - d2);
    featureCall(3) numberLogFeatures(snormal.dotProduct(dnormal));
  }

  featureGenerator directedFeatures(CartesianCoordinatesSequencePtr calphaTrace, size_t sourceIndex, size_t targetIndex)
  {
    size_t n = calphaTrace->size();
    Vector3 beforeTarget = calphaTrace->getPositionChecked((int)targetIndex - 1);
    Vector3 target = calphaTrace->getPosition(targetIndex);
    Vector3 afterTarget = calphaTrace->getPositionChecked((int)targetIndex + 1);

    for (int delta = -5; delta <= 5; ++delta)
    {
      int i = (int)sourceIndex + delta;
      Vector3 beforeSource = calphaTrace->getPositionChecked(i - 1);
      Vector3 source = calphaTrace->getPositionChecked(i);
      Vector3 afterSource = calphaTrace->getPositionChecked(i + 1);
      featureCall(delta + 5) pairGeometricFeatures(beforeSource, source, afterSource, beforeTarget, target, afterTarget);
    }
  }

  virtual featureGenerator compute(ProteinPtr protein, size_t firstPosition, size_t secondPosition)
  {
    CartesianCoordinatesSequencePtr calphaTrace = protein->getCAlphaTrace();
    LabelSequencePtr aminoAcidSequence = protein->getAminoAcidSequence();
    Vector3 p1 = calphaTrace->getPosition(firstPosition);
    Vector3 p2 = calphaTrace->getPosition(secondPosition);
    jassert(p1.exists() && p2.exists());
    
    featureScope(aminoAcidSequence->getIndex(firstPosition))
      featureScope(aminoAcidSequence->getIndex(secondPosition))
      {
        featureCall(0) positiveNumberLogFeatures((double)abs((int)secondPosition - (int)firstPosition), 5);
        featureCall(1) positiveNumberLogFeatures((p1 - p2).l2norm());  
      }

    //featureCall(aminoAcidSequence->getIndex(secondPosition)) directedFeatures(calphaTrace, firstPosition, secondPosition);
    //featureCall(aminoAcidSequence->getIndex(firstPosition)) directedFeatures(calphaTrace, secondPosition, firstPosition);*/
  }
};


///////////////////////////////////////////////////////////////////////////////////////////

/*
class PrintClassifiersSummaryVisitor : public DefaultInferenceVisitor
{
public:
  PrintClassifiersSummaryVisitor() : hop(0) {}

  virtual void visit(ClassificationInferenceStepPtr inference)
  {
    ++hop;
    std::cout << "ClassificationInferenceStep " << hop << ": ";
    ClassifierPtr classifier = inference->getClassifier();
    if (!classifier)
      std::cout << "<no classifier>" << std::endl;
    else
    {
      GradientBasedClassifierPtr gbc = classifier.dynamicCast<GradientBasedClassifier>();
      if (gbc)
      {
        DenseVectorPtr parameters = gbc->getParameters();
        std::cout << parameters->l0norm() << " parameters, norm = " << parameters->l2norm() << std::endl;
        this->parameters.push_back(parameters);
      }
      else
        std::cout << "<unknown classifier>" << std::endl;
    }
  }

  std::vector<DenseVectorPtr> parameters;

private:
  size_t hop;
};

typedef ReferenceCountedObjectPtr<PrintClassifiersSummaryVisitor> PrintClassifiersSummaryVisitorPtr;
*/
class MyInferenceLearnerCallback : public InferenceLearnerCallback
{
public:
  MyInferenceLearnerCallback(ObjectContainerPtr trainingData, ObjectContainerPtr testingData, bool useCacheOnTestingData = true)
    : trainingData(trainingData), testingData(testingData), startingTime(Time::getMillisecondCounter())
  {
    if (useCacheOnTestingData)
      cache = new InferenceResultCache();
  }

  virtual InferenceContextPtr createContext()
    {return singleThreadedInferenceContext();}
  
  virtual double getProbabilityToCreateAnExample(InferenceStackPtr stack, ObjectPtr input, ObjectPtr supervision)
  {
    String inferenceStepName = stack->getInference(1)->getName();
    if (inferenceStepName == T("Init Step"))
      return 0.0;
    if (inferenceStepName == T("CA Update Pass"))
    {
      //RefineCAlphaPositionsInferenceStepPtr step = stack->getParentInference().dynamicCast<RefineCAlphaPositionsInferenceStep>();
      return 0.01;
    }
    if (inferenceStepName.startsWith(T("RR")) || inferenceStepName.startsWith(T("DR")))
    {
      LabelPtr label = supervision.dynamicCast<Label>();
      if (label->getIndex() == 1)
        return 1.0;
      else
        return inferenceStepName.startsWith(T("RR")) 
          ? 0.05 // 5% probability for negative residue-residue contact examples
          : 0.2; // 20% probability for negative disorder examples

    }
    return 1.0;
  }

  virtual ClassifierPtr createClassifier(InferenceStackPtr stack, FeatureDictionaryPtr labels)
  {
    std::cout << "CreateClassifier for step " << stack->getInference(1)->getName() << std::endl;
    if (labels == BinaryClassificationDictionary::getInstance())
    {
      IterationFunctionPtr learningRate = invLinearIterationFunction(0.5, 250000);
      GradientBasedLearnerPtr learner = stochasticDescentLearner(learningRate);  
      GradientBasedBinaryClassifierPtr classifier = linearSVMBinaryClassifier(learner, labels);
      classifier->setL2Regularizer(0.01);
      return classifier;
    }
    else
    {
      IterationFunctionPtr learningRate = invLinearIterationFunction(2.0, 250000);
      GradientBasedLearnerPtr learner = stochasticDescentLearner(learningRate);  
      return maximumEntropyClassifier(learner, labels, 20.0);
    }
  }

  virtual RegressorPtr createRegressor(InferenceStackPtr stack)
  {
    String inferenceStepName = stack->getInference(1)->getName();
      
    std::cout << "CreateRegressor for step " << inferenceStepName << std::endl;
    static const double regularizer = 0.0;

    IterationFunctionPtr learningRate;
    if (inferenceStepName.startsWith(T("BBB")))
      learningRate = constantIterationFunction(0.1);
    else if (inferenceStepName.startsWith(T("CA")))
      learningRate = constantIterationFunction(0.5);
    else if (inferenceStepName.startsWith(T("TS")))
      learningRate = constantIterationFunction(0.0001);
    else
      learningRate = invLinearIterationFunction(0.5, 150000);

    GradientBasedLearnerPtr learner = stochasticDescentLearner(learningRate);  
    return generalizedLinearRegressor(learner, regularizer);
  }

  virtual void preLearningIterationCallback(size_t iterationNumber)
    {std::cout << std::endl << " ================== ITERATION " << iterationNumber << " ================== " << (Time::getMillisecondCounter() - startingTime) / 1000.0 << " s" <<  std::endl;}

  // returns false if learning should stop
  virtual bool postLearningIterationCallback(InferenceStepPtr inference, size_t iterationNumber)
  {
    InferenceContextPtr validationContext = createContext();
    ProteinEvaluationCallbackPtr evaluation = new ProteinEvaluationCallback();
    validationContext->appendCallback(evaluation);
    if (cache)
      validationContext->appendCallback(new AutoSubStepsCacheInferenceCallback(cache, inference));

    validationContext->runWithSupervisedExamples(inference, trainingData);
    std::cout << "Train evaluation: " << evaluation->toString() << std::endl;
    //double trainRmse = 
    
    validationContext->runWithSupervisedExamples(inference, testingData);
    std::cout << "Test evaluation: " << evaluation->toString() << std::endl;

   /* static double bestTestAcc = 0.0;
    double testAcc = evaluation->getDefaultScoreForTarget(T("SecondaryStructureSequence"));
    if (testAcc > bestTestAcc)
      bestTestAcc = testAcc;
    std::cout << "Best Test Accuracy: " << String(bestTestAcc * 100, 2) << "%" << std::endl;
*/
    /*double testRmse = evaluation->getPSSMRootMeanSquareError();

    if (trainRmse < bestTrainRmse)
    {
      bestTrainRmse = trainRmse;
      bestTestRmse = testRmse;
    }*/

    // stopping criterion
    return iterationNumber < 50;
  }

  virtual void preLearningStepCallback(InferenceStepPtr step)
  {
    String passName = step->getName();
    std::cout << std::endl << "=====================================================" << std::endl;
    std::cout << "======= LEARNING PASS " << passName << " ==========" << (Time::getMillisecondCounter() - startingTime) / 1000 << " s" << std::endl;
    std::cout << "=====================================================" << std::endl;
    //bestTrainRmse = bestTestRmse = DBL_MAX;
  }

  virtual void postLearningStepCallback(InferenceStepPtr step)
  {
    //std::cout << "Best Train RMSE: " << bestTrainRmse << std::endl;
    //std::cout << "Best Test RMSE: " << bestTestRmse << std::endl;
  }

private:
  ObjectContainerPtr trainingData;
  ObjectContainerPtr testingData;
  InferenceResultCachePtr cache;
  juce::uint32 startingTime;

//  double bestTrainRmse, bestTestRmse;
};

class SampleRandomCAlphaTraceInferenceStep : public InferenceStep
{
public:
  SampleRandomCAlphaTraceInferenceStep() : InferenceStep(T("SampleRandomCAlphaTrace")) {}

  virtual void accept(InferenceVisitorPtr visitor) {}

  virtual ObjectPtr run(InferenceContextPtr context, ObjectPtr input, ObjectPtr supervision, ReturnCode& returnCode)
  {
    ProteinPtr protein = input.dynamicCast<Protein>();
    jassert(protein);
    RandomGenerator random(0);

    size_t n = protein->getLength();
    BondCoordinatesSequencePtr bonds = new BondCoordinatesSequence(T("CA bonds"), n - 1);
    for (size_t i = 0; i < n - 1; ++i)
    {
      BondCoordinates coordinates;
      coordinates.setLength(random.sampleDoubleFromGaussian(3.8, 0.05));
      coordinates.setThetaAngle(random.sampleDoubleFromGaussian(1.85, 0.3));
      coordinates.setPhiDihedralAngle(random.sampleDouble(-M_PI, M_PI));
      bonds->setCoordinates(i, coordinates);
    }
    return bonds->makeCartesianCoordinates(T("CAlphaTrace"));
  }
};

class ProteinToInputOutputPair : public ObjectFunction
{
public:
  virtual String getOutputClassName(const String& inputClassName) const
    {return T("ObjectPair");}

  virtual ObjectPtr function(ObjectPtr input) const
  {
    return new ObjectPair(input, input);
   /* ProteinPtr protein = input.dynamicCast<Protein>();
    jassert(protein);
    ProteinPtr inputProtein = new Protein(protein->getName());
    inputProtein->setObject(protein->getAminoAcidSequence());
    inputProtein->setObject(protein->getPositionSpecificScoringMatrix());
    inputProtein->setObject(sampleRandomCalphaTrace(protein));
    return new ObjectPair(inputProtein, protein);*/
  }
};

ObjectContainerPtr loadProteins(const File& directory, size_t maxCount = 0)
{
  ObjectStreamPtr proteinsStream = directoryObjectStream(directory, T("*.protein"));
#ifdef JUCE_DEBUG
  ObjectContainerPtr res = proteinsStream->load(maxCount ? maxCount : 7)->randomize();
#else
  ObjectContainerPtr res = proteinsStream->load(maxCount)->randomize();
#endif
  for (size_t i = 0; i < res->size(); ++i)
  {
    ProteinPtr protein = res->getAndCast<Protein>(i);
    jassert(protein);
    protein->computeMissingFields();
  }
  return res;
}

int main(int argc, char** argv)
{
  declareProteinClasses();

  File modelDirectory(T("C:\\Projets\\LBC++\\projects\\temp\\Models\\CALPHA.model"));

  /*File cb513Directory(T("C:\\Projets\\LBC++\\projects\\temp\\CB513"));
  ObjectContainerPtr cb513Proteins = loadProteins(cb513Directory);
  File outputDirectory(T("C:\\Projets\\LBC++\\projects\\temp\\CB513"));
  for (size_t i = 0; i < cb513Proteins->size(); ++i)
  {
    ProteinPtr protein = cb513Proteins->getAndCast<Protein>(i);
    jassert(protein);
    std::cout << protein->getName() << std::endl;
    protein->computeMissingFields();
    protein->saveToFile(outputDirectory.getChildFile(protein->getName() + T(".protein")));
  }
  return 0;

  std::cout << "CB513 " << ProteinStatisticsCalculator::computeStatistics(cb513Proteins) << std::endl;*/

  File smallPDBDirectory(T("C:\\Projets\\LBC++\\projects\\temp\\SmallPDB\\protein"));
  ObjectContainerPtr smallPDBProteins = loadProteins(smallPDBDirectory, 70);
  std::cout << "SmallPDB " << ProteinStatisticsCalculator::computeStatistics(smallPDBProteins) << std::endl;
  smallPDBProteins = smallPDBProteins->apply(new ProteinToInputOutputPair());

  //proteins = proteins->apply(new ProteinToInputOutputPair());

  ObjectContainerPtr trainingData = smallPDBProteins->size() >= 7 ? smallPDBProteins->invFold(0,7) : smallPDBProteins;
  ObjectContainerPtr testingData = smallPDBProteins->size() >= 7 ? smallPDBProteins->fold(0,7) : smallPDBProteins;

  std::cout << trainingData->size() << " Training Proteins "
            << testingData->size() << " Testing Proteins" << std::endl;


#if 0
  ProteinPtr protein = smallPDBProteins->getAndCast<ObjectPair>(0)->getSecond().dynamicCast<Protein>();
  CartesianCoordinatesSequencePtr correctCAlphaTrace = protein->getCAlphaTrace();
  ProteinTertiaryStructurePtr correctTS = protein->getTertiaryStructure();
  
  for (int i = 0; i < 100; ++i)
  {
    CartesianCoordinatesSequencePtr calphaTrace;
    if (i == 0)
    {
      InferenceStepPtr step = InferenceStep::createFromFileAndCast<InferenceStep>(modelDirectory.getChildFile(T("0_Initial c-alpha bonds.inference")));
      jassert(step);
      
      //SampleRandomCAlphaTraceInferenceStep pouet;
      InferenceStep::ReturnCode returnCode;
      BondCoordinatesSequencePtr bonds = step->run(singleThreadedInferenceContext(), protein, ObjectPtr(), returnCode).dynamicCast<BondCoordinatesSequence>();
      jassert(bonds);
      calphaTrace = bonds->makeCartesianCoordinates(T("CAlphaTrace"));//  pouet.run(InferenceContextPtr(), protein, ObjectPtr(), returnCode).dynamicCast<CartesianCoordinatesSequence>();
      protein->setObject(calphaTrace);
      protein->setObject(ProteinTertiaryStructure::createFromCAlphaTrace(protein->getAminoAcidSequence(), calphaTrace));
    }

    protein->saveToPDBFile(File(T("C:\\Projets\\LBC++\\projects\\temp\\pdbs\\prot") + String(i) + T(".pdb")));

    calphaTrace = protein->getCAlphaTrace();
    jassert(calphaTrace);
    std::vector<Vector3> v;
    ProteinCAlphaTraceUpdateInferenceStep::computeSupervision(calphaTrace, correctCAlphaTrace, v, 50);
    CartesianCoordinatesSequencePtr newCAlphaTrace = new CartesianCoordinatesSequence(T("CAlphaTrace"), v);
    protein->setObject(newCAlphaTrace);
    ProteinTertiaryStructurePtr predictedTS = ProteinTertiaryStructure::createFromCAlphaTrace(protein->getAminoAcidSequence(), newCAlphaTrace);
    protein->setObject(predictedTS);
    std::cout << "RMSE = " << predictedTS->computeCAlphaAtomsRMSE(correctTS) << std::endl;
  }
  return 0;
#endif // 0


  /*
  ** Creation of the feature function
  */
  CompositeProteinResidueFeaturesPtr featureFunction = new CompositeProteinResidueFeatures();

  featureFunction->addSubFeatures(proteinUnitResidueFeature());
//  featureFunction->addSubFeatures(proteinPositionIndexResidueFeature()); // DEBUG !!

  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("AminoAcidSequence"), 8, 8, true));
  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("PositionSpecificScoringMatrix"), 8, 8, true));
  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("SecondaryStructureSequence"), 5, 5, true));
  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("DSSPSecondaryStructureSequence"), 5, 5, true));
  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("SolventAccessibilityThreshold20"), 5, 5, true));
  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("DisorderProbabilitySequence"), 5, 5, true));
  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("BackboneBondSequence"), 5, 5, true));

  CompositeProteinResidueFeaturesPtr tertiaryStructureFeatureFunction = new CompositeProteinResidueFeatures();
  tertiaryStructureFeatureFunction->addSubFeatures(proteinUnitResidueFeature());
  tertiaryStructureFeatureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("TertiaryStructure"), 5, 5, true));

 /* featureFunction->addSubFeatures(proteinFrequencyWindowFeatures(T("DisorderProbabilitySequence"), 5, true));
  featureFunction->addSubFeatures(proteinFrequencyWindowFeatures(T("DisorderProbabilitySequence"), 10, true));
  featureFunction->addSubFeatures(proteinFrequencyWindowFeatures(T("DisorderProbabilitySequence"), 20, true));

  // New features :
  featureFunction->addSubFeatures(proteinPositionFeatures());
  //featureFunction->addSubFeatures(proteinLengthFeatures());
  */
  featureFunction->addSubFeatures(proteinSegmentConjunctionFeatures(T("SecondaryStructureSequence"), 5));

  CompositeProteinResiduePairFeaturesPtr pairFeatureFunction = new CompositeProteinResiduePairFeatures();
  pairFeatureFunction->addSubFeatures(proteinPointResiduePairFeatures(featureFunction));
  pairFeatureFunction->addSubFeatures(separationLengthResiduePairFeatures());
  pairFeatureFunction->addSubFeatures(new TriDimProteinResiduePairFeatures());
  //pairFeatureFunction->addSubFeatures(proteinPositionIndexResiduePairFeature());

  ProteinResidueFeaturesPtr calphaUpdateFeatures = new MyCalphaUpdateFeatures();

  /*
  ** Creation of the inference 
  */
  ProteinInferencePtr proteinInference = new ProteinInference();
  //proteinInference->loadSubInferencesFromDirectory(modelDirectory);
  proteinInference->setPDBDebugDirectory(File(T("C:\\Projets\\LBC++\\projects\\temp\\pdbs")));

  //proteinInference->appendStep(new SampleRandomCAlphaTraceInferenceStep());
  //proteinInference->appendStep(new ProteinCAlphaBondSequenceInferenceStep(T("Initial c-alpha bonds"), featureFunction));

  InferenceStepPtr initStep
    = InferenceStep::createFromFileAndCast<InferenceStep>(modelDirectory.getChildFile(T("0_Initial c-alpha bonds.inference")));
    //= new SampleRandomCAlphaTraceInferenceStep();
  initStep->setName(T("Init Step"));
  proteinInference->appendStep(initStep);
  //InferenceStepPtr calphaUpdateStep = new ProteinCAlphaTraceUpdateInferenceStep(T("CA Update Pass"), calphaUpdateFeatures);
  InferenceStepPtr calphaUpdateStep = new RefineCAlphaPositionsInferenceStep(T("CA Update Pass"), pairFeatureFunction);

  for (size_t i = 0; i < 10; ++i)
  {
    proteinInference->appendStep(calphaUpdateStep);
    continue;
    {
      //Protein2DInferenceStepPtr step = new ProteinContactMapInferenceStep(T("RR Pass ") + lbcpp::toString(i),
       //                                                   pairFeatureFunction, T("ResidueResidueContactMatrix8Cb"));
      //proteinInference->appendStep(step);
    }
    {
      //Protein1DInferenceStepPtr step;

      //step = new ProteinTertiaryStructureRefinementInferenceStep(T("TS Pass ") + lbcpp::toString(i), tertiaryStructureFeatureFunction);
      //proteinInference->appendStep(step);
     
#if 0
      step = new ProteinSequenceLabelingInferenceStep(T("SS3 Pass ") + lbcpp::toString(i), featureFunction, /*T("SecondaryStructureProbabilities"), */T("SecondaryStructureSequence"));
      proteinInference->appendStep(step);
      step = new ProteinSequenceLabelingInferenceStep(T("DR Pass ") + lbcpp::toString(i), featureFunction, T("DisorderProbabilitySequence"), T("DisorderSequence"));
      proteinInference->appendStep(step);
      step = new ProteinSequenceLabelingInferenceStep(T("SA Pass ") + lbcpp::toString(i), featureFunction, T("SolventAccessibilityThreshold20"));
      proteinInference->appendStep(step);
      step = new ProteinBackboneBondSequenceInferenceStep(T("BBB Pass ") + lbcpp::toString(i), featureFunction);
      proteinInference->appendStep(step);
#endif // 0

      //step = new ProteinSequenceLabelingInferenceStep(T("SS8 Pass ") + lbcpp::toString(i), featureFunction, /*T("DSSPSecondaryStructureProbabilities"), */T("DSSPSecondaryStructureSequence"));
      //proteinInference->appendStep(step);

    }
  }
  //std::cout << "Inference: " << proteinInference->toString() << std::endl;

  /*
  ** Learning
  */
  InferenceLearnerCallbackPtr callback = new MyInferenceLearnerCallback(trainingData, testingData, false);
  //InferenceLearnerPtr learner = stepByStepDeterministicSimulationLearner(callback, true, modelDirectory, true);
  InferenceLearnerPtr learner = globalSimulationLearner(callback);
  learner->train(proteinInference, trainingData);

  /*
  ** Evaluation
  */
  InferenceContextPtr validationContext = singleThreadedInferenceContext();
  ProteinEvaluationCallbackPtr evaluation = new ProteinEvaluationCallback();
  validationContext->appendCallback(evaluation);

  validationContext->runWithSupervisedExamples(proteinInference, trainingData);
  std::cout << "Train evaluation: " << evaluation->toString() << std::endl;

  validationContext->runWithSupervisedExamples(proteinInference, testingData);
  std::cout << "Test evaluation: " << evaluation->toString() << std::endl;

  return 0;
}
