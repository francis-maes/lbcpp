/*-----------------------------------------.---------------------------------.
| Filename: SandBox.lcpp                   | Test Learning                   |
| Author  : Francis Maes                   |                                 |
| Started : 08/04/2010 16:27               |                                 |
`------------------------------------------/                                 |
                               |                                             |
                               `--------------------------------------------*/

#include <lbcpp/lbcpp.h>
#include "InferenceData/ScoreSymmetricMatrix.h"
#include "InferenceData/CommonFeatureGenerators.h"
#include "Protein/Evaluation/ProteinEvaluationCallback.h"
#include "Protein/Evaluation/ProteinStatisticsCalculator.h"
#include "Protein/SecondaryStructureDictionary.h"
#include "Protein/Inference/Protein1DTargetInference.h"
#include "Protein/Inference/ProteinBackboneBondSequenceInference.h"
#include "Protein/Inference/ProteinContactMapInference.h"
#include "Protein/Inference/ProteinTertiaryStructureInference.h"
#include "Protein/Inference/ProteinGlobalFeatures.h"
#include "Protein/Inference/ProteinInference.h"
#include <fstream>
using namespace lbcpp;

extern void declareProteinClasses();

class MyInferenceCallback : public InferenceCallback
{
public:
  MyInferenceCallback(InferencePtr inference, ObjectContainerPtr trainingData, ObjectContainerPtr testingData)
    : inference(inference), trainingData(trainingData), testingData(testingData) {}

  virtual void preInferenceCallback(InferenceStackPtr stack, Variable& input, Variable& supervision, Variable& output, ReturnCode& returnCode)
  {
    String inferenceClassName = stack->getCurrentInference()->getClassName();

    if (stack->getDepth() == 1)
    {
      // top-level learning is beginning
      startingTime = Time::getMillisecondCounter();
      bestTrainContactMap = bestTestContactMap = 0.0;
      iterationNumber = 0;
    }
    else if (inferenceClassName == T("SimulationInferenceBatchLearner"))
    {
      // simulation-based learning is beginning
      if (input.getType()->inheritsFrom(pairClass()))
      {
        String inferenceName = input[0].getObject()->getName();
        std::cout << std::endl << "=====================================================" << std::endl;
        std::cout << "======= " << inferenceName << " ==========" << (Time::getMillisecondCounter() - startingTime) / 1000 << " s" << std::endl;
        std::cout << "=====================================================" << std::endl;
      }
      iterationNumber = 0;
    }
    else if (inferenceClassName == T("RunOnSupervisedExamplesInference"))
    {
      // learning iteration is beginning
      std::cout << std::endl << " ================== ITERATION " << ++iterationNumber << " ================== " << (Time::getMillisecondCounter() - startingTime) / 1000.0 << " s" <<  std::endl;
    }
  }
  
  virtual void postInferenceCallback(InferenceStackPtr stack, const Variable& input, const Variable& supervision, Variable& output, ReturnCode& returnCode)
  {
    String inferenceClassName = stack->getCurrentInference()->getClassName();

    if (inferenceClassName == T("RunOnSupervisedExamplesInference"))
    {
      // end of learning iteration
      InferenceContextPtr validationContext = singleThreadedInferenceContext();
      ProteinEvaluationCallbackPtr evaluation = new ProteinEvaluationCallback();
      validationContext->appendCallback(evaluation);
      
      validationContext->runInference(runOnSupervisedExamplesInference(inference), trainingData, ObjectPtr(), returnCode);
      processResults(evaluation, true);
      
      evaluation->reset();

      validationContext->runInference(runOnSupervisedExamplesInference(inference), testingData, ObjectPtr(), returnCode);
      processResults(evaluation, false);      
    }
    else if (stack->getDepth() == 1)
    {
      // end of top-level learning
      std::cout << "Best train: " << bestTrainContactMap << " test: " << bestTestContactMap << std::endl;
      std::cout << "Bye." << std::endl;
    }
  }

  void processResults(ProteinEvaluationCallbackPtr evaluation, bool isTrainingData)
  {
    /*{
      EvaluatorPtr bbbEvaluator = evaluation->getEvaluatorForTarget(T("BackboneBondSequence"));
      jassert(bbbEvaluator);
      std::cout << (isTrainingData ? "Train: " : "Test: ") << evaluation->toString() << std::endl;
    }*/

    EvaluatorPtr contactMapEvaluator = evaluation->getEvaluatorForTarget(T("ResidueResidueContactMatrix8Ca"));
    jassert(contactMapEvaluator);
    std::cout << (isTrainingData ? "Train: " : "Test: ") << contactMapEvaluator->toString() << std::endl;
      
    std::vector< std::pair<String, double> > scores;
    contactMapEvaluator->getScores(scores);
    for (size_t i = 0; i < scores.size(); ++i)
      std::cout << scores[i].first << ": " << scores[i].second << std::endl;
  }

private:
  InferencePtr inference;
  ObjectContainerPtr trainingData, testingData;
  size_t iterationNumber;
  juce::uint32 startingTime;

  double bestTrainContactMap, bestTestContactMap;

  void updateBestScore(double score, double& bestScore)
    {if (score > bestScore) bestScore = score;}
};

ObjectContainerPtr loadProteins(const File& directory, size_t maxCount = 0)
{
  ObjectStreamPtr proteinsStream = directoryObjectStream(directory, T("*.protein"));
#ifdef JUCE_DEBUG
  ObjectContainerPtr res = proteinsStream->load(maxCount ? maxCount : 7)->randomize();
#else
  ObjectContainerPtr res = proteinsStream->load(maxCount)->randomize();
#endif
  for (size_t i = 0; i < res->size(); ++i)
  {
    ProteinObjectPtr protein = res->getAndCast<ProteinObject>(i);
    jassert(protein);
    protein->computeMissingFields();
  }
  return res;
}

InferenceOnlineLearnerPtr createOnlineLearner(const String& name, double initialLearningRate = 1.0)
{
  StoppingCriterionPtr stoppingCriterion = maxIterationsStoppingCriterion(10);/*logicalOr(
    maxIterationsStoppingCriterion(100),  
    maxIterationsWithoutImprovementStoppingCriterion(1));*/

  if (name == T("CM"))
    return gradientDescentInferenceOnlineLearner(
      InferenceOnlineLearner::perEpisode,                                                 // randomization
      InferenceOnlineLearner::perStep, invLinearIterationFunction(initialLearningRate, 100000), true, // learning steps
      InferenceOnlineLearner::perStepMiniBatch20, sumOfSquaresFunction(0.0),         // regularizer
      InferenceOnlineLearner::perPass, stoppingCriterion, true);                     // stopping criterion
  else
    return gradientDescentInferenceOnlineLearner(
      InferenceOnlineLearner::never,                                                 // randomization
      InferenceOnlineLearner::perStep, invLinearIterationFunction(initialLearningRate, 10000), true, // learning steps
      InferenceOnlineLearner::perStepMiniBatch20, sumOfSquaresFunction(0.0),         // regularizer
      InferenceOnlineLearner::perPass, stoppingCriterion, true);                     // stopping criterion

}

InferencePtr createBinaryClassifier(const String& name = T("Unnamed"))
  {return binaryLinearSVMInference(createOnlineLearner(name), name);}

InferencePtr createMultiClassClassifier(const String& outputEnumerationName)
{
  EnumerationPtr enumeration = Enumeration::get(outputEnumerationName);
  jassert(enumeration);
  InferencePtr binaryClassifier = createBinaryClassifier();
  return oneAgainstAllClassificationInference(T("MultiClass"), enumeration, binaryClassifier);
}

InferencePtr createLeastSquaresRegressor(const String& name = T("Unnamed"))
  {return squareRegressionInference(createOnlineLearner(name, 0.1), name);}

InferencePtr createDihedralRegressor(const String& name = T("Unnamed"))
  {return dihedralAngleRegressionInference(createOnlineLearner(name, 0.1), name);}


int main(int argc, char** argv)
{
  lbcpp::initialize();
  declareProteinClasses();
  
  File workingDirectory(T("C:\\Projets\\LBC++\\projects\\temp"));
  //File workingDirectory(T("/Users/francis/tmp"));

  //File smallPDBDirectory = workingDirectory.getChildFile(T("SmallPDB"));
  //File smallPDBDirectory(T("/Users/francis/tmp/SmallPDB"));
  
//  ObjectContainerPtr smallPDBProteins = loadProteins(smallPDBDirectory.getChildFile(T("protein")), 7);
//  
  
  /*ObjectContainerPtr smallPDBProteins = directoriesObjectPairStream(
        smallPDBDirectory.getChildFile(T("smallProteinWithSS3DR")),
        smallPDBDirectory.getChildFile(T("protein")))->load();*/

  ObjectContainerPtr smallPDBProteins = loadProteins(workingDirectory.getChildFile(T("L50DB")));
  smallPDBProteins = smallPDBProteins->apply(new ProteinToInputOutputPairFunction());

  ObjectContainerPtr trainingData = smallPDBProteins->size() >= 7 ? smallPDBProteins->invFold(0,7) : smallPDBProteins;
  ObjectContainerPtr testingData = smallPDBProteins->size() >= 7 ? smallPDBProteins->fold(0,7) : smallPDBProteins;

  std::cout << trainingData->size() << " Training Proteins "
            << testingData->size() << " Testing Proteins" << std::endl;

  /*
  ** Global features
  */
  CompositeProteinGlobalFeaturesPtr globalFeatureFunction = new CompositeProteinGlobalFeatures();
  globalFeatureFunction->addSubFeatures(proteinLengthFeatures());
  globalFeatureFunction->addSubFeatures(proteinGlobalCompositionFeatures(T("AminoAcidSequence")));
  globalFeatureFunction->addSubFeatures(proteinGlobalCompositionFeatures(T("PositionSpecificScoringMatrix")));

  /*
  ** Residue features
  */
  CompositeProteinResidueFeaturesPtr featureFunction = new CompositeProteinResidueFeatures();

  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("AminoAcidSequence"), 5, 5, true));
  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("PositionSpecificScoringMatrix"), 5, 5, true));
  //featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("SecondaryStructureSequence"), 5, 5, true));
  //featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("DisorderProbabilitySequence"), 5, 5, true));
  /*featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("DSSPSecondaryStructureSequence"), 5, 5, true));
  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("SolventAccessibilityThreshold20"), 5, 5, true));
  */
  //featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("BackboneBondSequence"), 5, 5, true));


  /*
  ** Residue-pair features
  */
  CompositeProteinResiduePairFeaturesPtr pairFeatureFunction = new CompositeProteinResiduePairFeatures();
  pairFeatureFunction->addSubFeatures(proteinUnitResiduePairFeature());
  pairFeatureFunction->addSubFeatures(conjunctionResiduePairFeatures(aaResiduePairConjunction, proteinUnitResiduePairFeature()));
//  pairFeatureFunction->addSubFeatures(conjunctionResiduePairFeatures(aaResiduePairConjunction, separationDistanceResiduePairFeatures(4)));
  pairFeatureFunction->addSubFeatures(conjunctionResiduePairFeatures(aaResiduePairConjunction, separationLengthResiduePairFeatures(4)));
  pairFeatureFunction->addSubFeatures(proteinPointResiduePairFeatures(featureFunction));
  pairFeatureFunction->addSubFeatures(proteinCentralCompositionResiduePairFeatures(T("AminoAcidSequence")));

  // structure:
  pairFeatureFunction->addSubFeatures(/*conjunctionResiduePairFeatures(aaResiduePairConjunction,*/ contactMapResiduePairFeatures(T("ResidueResidueContactMatrix8Ca"), 10));

  //pairFeatureFunction->addSubFeatures(conjunctionResiduePairFeatures(aaResiduePairConjunction, separationLengthResiduePairFeatures(5)));
  //pairFeatureFunction->addSubFeatures(conjunctionResiduePairFeatures(aaResiduePairConjunction, proteinPointResiduePairFeatures(featureFunction)));
  
  //pairFeatureFunction->addSubFeatures(separationLengthResiduePairFeatures(1));
//  pairFeatureFunction->addSubFeatures(conjunctionResiduePairFeatures(aaResiduePairConjunction, separationLengthResiduePairFeatures(2)));

//  ProteinInferencePtr proteinInference = new ProteinInference();
//  proteinInference->appendInference(Inference::createFromFile(workingDirectory.getChildFile(T("Models//BBB.inference"))));
//  proteinInference->appendInference(Inference::createFromFile(workingDirectory.getChildFile(T("Models//CM_CO.inference"))));

  ProteinInferencePtr learnedProteinInference = new ProteinInference();
//  proteinInference->setPDBDebugDirectory(File(T("C:\\Projets\\LBC++\\projects\\temp\\pdbs")));
  learnedProteinInference->setProteinDebugDirectory(workingDirectory.getChildFile(T("ProteinDebug")));
  for (size_t i = 0; i < 5; ++i)
  {
    if (false)
    {
      learnedProteinInference->appendInference(
        new ProteinSequenceLabelingInferenceStep(T("DR Pass ") + lbcpp::toString(i),
                             createBinaryClassifier(T("DR")),
                             featureFunction,
                             T("DisorderProbabilitySequence"), T("DisorderSequence")));
    }

    if (false)
    {
      learnedProteinInference->appendInference(
        new ProteinSequenceLabelingInferenceStep(T("SS3 Pass ") + lbcpp::toString(i),
                               createMultiClassClassifier(T("SecondaryStructureElement")),
                               featureFunction, T("SecondaryStructureSequence")));
    }

    if (false)
    {
      learnedProteinInference->appendInference(
        new ProteinBackboneBondSequenceInferenceStep(T("BBB Pass ") + lbcpp::toString(i), featureFunction,
                createLeastSquaresRegressor(), createLeastSquaresRegressor(), createDihedralRegressor()));
    }

    if (true)
    {  
      learnedProteinInference->appendInference(
        new ProteinContactMapInference(T("CM Pass ") + lbcpp::toString(i),
                            createBinaryClassifier(T("CM")),
                            pairFeatureFunction,
                            T("ResidueResidueContactMatrix8Ca")));
    }
  }

  InferenceContextPtr learningContext = singleThreadedInferenceContext();
  learningContext->appendCallback(new MyInferenceCallback(learnedProteinInference, trainingData, testingData));
  learningContext->train(learnedProteinInference, trainingData);
  learnedProteinInference->saveToFile(workingDirectory.getChildFile(T("Models//CM-5Pass.inference")));
  return 0;
}
