/*-----------------------------------------.---------------------------------.
| Filename: SandBox.lcpp                   | Test Learning                   |
| Author  : Francis Maes                   |                                 |
| Started : 08/04/2010 16:27               |                                 |
`------------------------------------------/                                 |
                               |                                             |
                               `--------------------------------------------*/

#include <lbcpp/lbcpp.h>
#include "InferenceStep/RegressionInferenceStep.h"
#include "InferenceStep/ParallelSharedMultiRegressionInferenceStep.h"
#include "InferenceLearner/InferenceLearner.h"
#include "InferenceLearner/InferenceLearnerCallback.h"
#include "InferenceContext/CacheInferenceCallback.h"
#include "InferenceData/ScoreSymmetricMatrix.h"
#include "Protein/Evaluation/ProteinEvaluationCallback.h"
#include "Protein/Evaluation/ProteinStatisticsCalculator.h"
#include "Protein/SecondaryStructureDictionary.h"
#include "Protein/Inference/Protein1DInferenceStep.h"
#include "Protein/Inference/ProteinBackboneBondSequenceInferenceStep.h"
#include "Protein/Inference/ProteinContactMapInferenceStep.h"
#include "Protein/Inference/ProteinTertiaryStructureInferenceStep.h"
#include "Protein/Inference/ProteinInference.h"
using namespace lbcpp;

extern void declareProteinClasses();

// Input: Features
// Output: direction Vector3Object 
// Supervision: target Vector3Object
class Vector3InferenceStep : public VectorParallelInferenceStep
{
public:
  Vector3InferenceStep(const String& name)
    : VectorParallelInferenceStep(name)
  {
    appendRegressionStep(T("x"));
    appendRegressionStep(T("y"));
    appendRegressionStep(T("z"));
  }

  void appendRegressionStep(const String& name)
  {
    RegressionInferenceStepPtr regressionInference = new RegressionInferenceStep(getName() + T(" ") + name);
    //appendStep(new TransferRegressionInferenceStep(regressionInference->getName(), regressionInference, new ScaledSigmoidScalarFunction(-1.0, 1.1)));
    appendStep(regressionInference);
  }

  virtual ObjectPtr createEmptyOutput(ObjectPtr input) const
    {return new Vector3Object(0.0);}
 
  virtual ObjectPtr getSubInput(ObjectPtr input, size_t index) const
    {return input;}

  virtual ObjectPtr getSubSupervision(ObjectPtr supervision, size_t index, ObjectPtr predictedObject) const
  {
    Vector3ObjectPtr vo = supervision.dynamicCast<Vector3Object>();
    jassert(vo);
    Vector3 v = vo->getValue();
    double target = (index == 0 ? v.getX() : (index == 1 ? v.getY() : v.getZ()));
    // loss(prediction) = (target - prediction)^2
    return squareFunction(addConstantScalarFunction(-target));
  }

  virtual void setSubOutput(ObjectPtr output, size_t index, ObjectPtr subOutput) const
  {
    Vector3ObjectPtr res = output.dynamicCast<Vector3Object>();
    ScalarPtr value = subOutput.dynamicCast<Scalar>();
    jassert(res && value);
    if (index == 0)
      res->getValue().setX(value->getValue());
    else if (index == 1)
      res->getValue().setY(value->getValue());
    else if (index == 2)
      res->getValue().setZ(value->getValue());
  }
};

class ProteinCAlphaTraceUpdateInferenceStep : public Protein1DInferenceStep
{
public:
  ProteinCAlphaTraceUpdateInferenceStep(const String& name, ProteinResidueFeaturesPtr features)
    : Protein1DInferenceStep(name, new Vector3InferenceStep(name + T(" Pos")), features, T("CAlphaTrace")) {}
  
  ProteinCAlphaTraceUpdateInferenceStep() {}

  virtual ObjectPtr createEmptyOutput(ObjectPtr input) const
  {
    ProteinPtr protein = getProtein(input);
    CartesianCoordinatesSequencePtr calphaTrace = protein->getCAlphaTrace();
    jassert(calphaTrace);
    return calphaTrace->clone();
  }

  virtual ObjectPtr getSubSupervision(ObjectPtr supervision, size_t index, ObjectPtr predictedObject) const
  {
    ProteinPtr protein = getProtein(supervision);
    CartesianCoordinatesSequencePtr predictedCAlphaTrace = predictedObject.dynamicCast<CartesianCoordinatesSequence>();
    CartesianCoordinatesSequencePtr correctCAlphaTrace = protein->getCAlphaTrace();
    jassert(correctCAlphaTrace && predictedCAlphaTrace);
    Vector3 predictedPosition = predictedCAlphaTrace->getPosition(index);
    Vector3 correctPosition = correctCAlphaTrace->getPosition(index);
    jassert(predictedPosition.exists());
    if (!correctPosition.exists())
      return ObjectPtr();
    Vector3 delta = correctPosition - predictedPosition;
  /*  double norm = delta.l2norm();
    if (norm > 10.0)
      delta *= 10.0 / norm;*/
    return new Vector3Object(delta);
  }

  virtual void setSubOutput(ObjectPtr output, size_t index, ObjectPtr subOutput) const
  {
    CartesianCoordinatesSequencePtr calphaTrace = output.dynamicCast<CartesianCoordinatesSequence>();
    Vector3ObjectPtr direction = subOutput.dynamicCast<Vector3Object>();
    jassert(calphaTrace && direction);
    calphaTrace->setPosition(index, calphaTrace->getPosition(index) + direction->getValue());
  }
};

class MyCalphaUpdateFeatures : public ProteinResidueFeatures
{
public:
  virtual featureGenerator compute(ProteinPtr protein, size_t position)
  {
    CartesianCoordinatesSequencePtr calphaTrace = protein->getCAlphaTrace();
    jassert(calphaTrace);
    Vector3 currentPosition = calphaTrace->getPosition(position);
    jassert(currentPosition.exists());
   // featureSense(0, currentPosition.getX());
   // featureSense(1, currentPosition.getY());
   // featureSense(2, currentPosition.getZ());
    featureSense(position + 3);
    
    /*Vector3 gravityCenter = calphaTrace->getGravityCenter();
    featureSense(0, gravityCenter.getX() - currentPosition.getX());
    featureSense(1, gravityCenter.getY() - currentPosition.getY());
    featureSense(2, gravityCenter.getZ() - currentPosition.getZ());*/
  }
};

///////////////////////////////////////////////////////////////////////////////////////////

/*
class PrintClassifiersSummaryVisitor : public DefaultInferenceVisitor
{
public:
  PrintClassifiersSummaryVisitor() : hop(0) {}

  virtual void visit(ClassificationInferenceStepPtr inference)
  {
    ++hop;
    std::cout << "ClassificationInferenceStep " << hop << ": ";
    ClassifierPtr classifier = inference->getClassifier();
    if (!classifier)
      std::cout << "<no classifier>" << std::endl;
    else
    {
      GradientBasedClassifierPtr gbc = classifier.dynamicCast<GradientBasedClassifier>();
      if (gbc)
      {
        DenseVectorPtr parameters = gbc->getParameters();
        std::cout << parameters->l0norm() << " parameters, norm = " << parameters->l2norm() << std::endl;
        this->parameters.push_back(parameters);
      }
      else
        std::cout << "<unknown classifier>" << std::endl;
    }
  }

  std::vector<DenseVectorPtr> parameters;

private:
  size_t hop;
};

typedef ReferenceCountedObjectPtr<PrintClassifiersSummaryVisitor> PrintClassifiersSummaryVisitorPtr;
*/
class MyInferenceLearnerCallback : public InferenceLearnerCallback
{
public:
  MyInferenceLearnerCallback(ObjectContainerPtr trainingData, ObjectContainerPtr testingData, bool useCacheOnTestingData = true)
    : trainingData(trainingData), testingData(testingData), startingTime(Time::getMillisecondCounter())
  {
    if (useCacheOnTestingData)
      cache = new InferenceResultCache();
  }

  virtual InferenceContextPtr createContext()
    {return singleThreadedInferenceContext();}
  
  virtual double getProbabilityToCreateAnExample(InferenceStackPtr stack, ObjectPtr input, ObjectPtr supervision)
  {
    String inferenceStepName = stack->getInference(1)->getName();
    if (inferenceStepName.startsWith(T("RR")) || inferenceStepName.startsWith(T("DR")))
    {
      LabelPtr label = supervision.dynamicCast<Label>();
      if (label->getIndex() == 1)
        return 1.0;
      else
        return inferenceStepName.startsWith(T("RR")) 
          ? 0.05 // 5% probability for negative residue-residue contact examples
          : 0.2; // 20% probability for negative disorder examples

    }
    return 1.0;
  }

  virtual ClassifierPtr createClassifier(InferenceStackPtr stack, FeatureDictionaryPtr labels)
  {
    std::cout << "CreateClassifier for step " << stack->getInference(1)->getName() << std::endl;
    if (labels == BinaryClassificationDictionary::getInstance())
    {
      IterationFunctionPtr learningRate = invLinearIterationFunction(0.5, 250000);
      GradientBasedLearnerPtr learner = stochasticDescentLearner(learningRate);  
      GradientBasedBinaryClassifierPtr classifier = linearSVMBinaryClassifier(learner, labels);
      classifier->setL2Regularizer(0.01);
      return classifier;
    }
    else
    {
      IterationFunctionPtr learningRate = invLinearIterationFunction(2.0, 250000);
      GradientBasedLearnerPtr learner = stochasticDescentLearner(learningRate);  
      return maximumEntropyClassifier(learner, labels, 20.0);
    }
  }

  virtual RegressorPtr createRegressor(InferenceStackPtr stack)
  {
    String inferenceStepName = stack->getInference(1)->getName();
      
    std::cout << "CreateRegressor for step " << inferenceStepName << std::endl;
    static const double regularizer = 0.0;

    IterationFunctionPtr learningRate;
    if (inferenceStepName.startsWith(T("BBB")))
      learningRate = constantIterationFunction(0.1);
    else if (inferenceStepName.startsWith(T("CA")))
      learningRate = constantIterationFunction(0.1);
    else if (inferenceStepName.startsWith(T("TS")))
      learningRate = constantIterationFunction(0.0001);
    else
      learningRate = invLinearIterationFunction(0.5, 150000);

    GradientBasedLearnerPtr learner = stochasticDescentLearner(learningRate);  
    return generalizedLinearRegressor(learner, regularizer);
  }

  virtual void preLearningIterationCallback(size_t iterationNumber)
    {std::cout << std::endl << " ================== ITERATION " << iterationNumber << " ================== " << (Time::getMillisecondCounter() - startingTime) / 1000.0 << " s" <<  std::endl;}

  // returns false if learning should stop
  virtual bool postLearningIterationCallback(InferenceStepPtr inference, size_t iterationNumber)
  {
    InferenceContextPtr validationContext = createContext();
    ProteinEvaluationCallbackPtr evaluation = new ProteinEvaluationCallback();
    validationContext->appendCallback(evaluation);
    if (cache)
      validationContext->appendCallback(new AutoSubStepsCacheInferenceCallback(cache, inference));

    validationContext->runWithSupervisedExamples(inference, trainingData);
    std::cout << "Train evaluation: " << evaluation->toString() << std::endl;
    //double trainRmse = 
    
    validationContext->runWithSupervisedExamples(inference, testingData);
    std::cout << "Test evaluation: " << evaluation->toString() << std::endl;

   /* static double bestTestAcc = 0.0;
    double testAcc = evaluation->getDefaultScoreForTarget(T("SecondaryStructureSequence"));
    if (testAcc > bestTestAcc)
      bestTestAcc = testAcc;
    std::cout << "Best Test Accuracy: " << String(bestTestAcc * 100, 2) << "%" << std::endl;
*/
    /*double testRmse = evaluation->getPSSMRootMeanSquareError();

    if (trainRmse < bestTrainRmse)
    {
      bestTrainRmse = trainRmse;
      bestTestRmse = testRmse;
    }*/

    // stopping criterion
    return iterationNumber < 15;
  }

  virtual void preLearningStepCallback(InferenceStepPtr step)
  {
    String passName = step->getName();
    std::cout << std::endl << "=====================================================" << std::endl;
    std::cout << "======= LEARNING PASS " << passName << " ==========" << (Time::getMillisecondCounter() - startingTime) / 1000 << " s" << std::endl;
    std::cout << "=====================================================" << std::endl;
    //bestTrainRmse = bestTestRmse = DBL_MAX;
  }

  virtual void postLearningStepCallback(InferenceStepPtr step)
  {
    //std::cout << "Best Train RMSE: " << bestTrainRmse << std::endl;
    //std::cout << "Best Test RMSE: " << bestTestRmse << std::endl;
  }

private:
  ObjectContainerPtr trainingData;
  ObjectContainerPtr testingData;
  InferenceResultCachePtr cache;
  juce::uint32 startingTime;

//  double bestTrainRmse, bestTestRmse;
};

class SampleRandomCAlphaTraceInferenceStep : public InferenceStep
{
public:
  SampleRandomCAlphaTraceInferenceStep() : InferenceStep(T("SampleRandomCAlphaTrace")) {}

  virtual void accept(InferenceVisitorPtr visitor) {}

  virtual ObjectPtr run(InferenceContextPtr context, ObjectPtr input, ObjectPtr supervision, ReturnCode& returnCode)
  {
    ProteinPtr protein = input.dynamicCast<Protein>();
    jassert(protein);
    RandomGenerator random((long long)input.get());

    size_t n = protein->getLength();
    BondCoordinatesSequencePtr bonds = new BondCoordinatesSequence(T("CA bonds"), n - 1);
    for (size_t i = 0; i < n - 1; ++i)
    {
      BondCoordinates coordinates;
      coordinates.setLength(random.sampleDoubleFromGaussian(3.8, 0.05));
      coordinates.setThetaAngle(random.sampleDoubleFromGaussian(1.85, 0.3));
      coordinates.setPhiDihedralAngle(random.sampleDouble(-M_PI, M_PI));
      bonds->setCoordinates(i, coordinates);
    }
    return bonds->makeCartesianCoordinates(T("CAlphaTrace"));
  }
};

class ProteinToInputOutputPair : public ObjectFunction
{
public:
  virtual String getOutputClassName(const String& inputClassName) const
    {return T("ObjectPair");}

  virtual ObjectPtr function(ObjectPtr input) const
  {
    return new ObjectPair(input, input);
   /* ProteinPtr protein = input.dynamicCast<Protein>();
    jassert(protein);
    ProteinPtr inputProtein = new Protein(protein->getName());
    inputProtein->setObject(protein->getAminoAcidSequence());
    inputProtein->setObject(protein->getPositionSpecificScoringMatrix());
    inputProtein->setObject(sampleRandomCalphaTrace(protein));
    return new ObjectPair(inputProtein, protein);*/
  }
};

ObjectContainerPtr loadProteins(const File& directory, size_t maxCount = 0)
{
  ObjectStreamPtr proteinsStream = directoryObjectStream(directory, T("*.protein"));
#ifdef JUCE_DEBUG
  ObjectContainerPtr res = proteinsStream->load(maxCount ? maxCount : 7)->randomize();
#else
  ObjectContainerPtr res = proteinsStream->load(maxCount)->randomize();
#endif
  for (size_t i = 0; i < res->size(); ++i)
  {
    ProteinPtr protein = res->getAndCast<Protein>(i);
    jassert(protein);
    protein->computeMissingFields();
  }
  return res;
}

int main(int argc, char** argv)
{
  declareProteinClasses();

  File modelDirectory(T("C:\\Projets\\LBC++\\projects\\temp\\Models\\YO.model"));

  /*File cb513Directory(T("C:\\Projets\\LBC++\\projects\\temp\\CB513"));
  ObjectContainerPtr cb513Proteins = loadProteins(cb513Directory);
  File outputDirectory(T("C:\\Projets\\LBC++\\projects\\temp\\CB513"));
  for (size_t i = 0; i < cb513Proteins->size(); ++i)
  {
    ProteinPtr protein = cb513Proteins->getAndCast<Protein>(i);
    jassert(protein);
    std::cout << protein->getName() << std::endl;
    protein->computeMissingFields();
    protein->saveToFile(outputDirectory.getChildFile(protein->getName() + T(".protein")));
  }
  return 0;

  std::cout << "CB513 " << ProteinStatisticsCalculator::computeStatistics(cb513Proteins) << std::endl;*/

  File smallPDBDirectory(T("C:\\Projets\\LBC++\\projects\\temp\\SmallPDB\\protein"));
  ObjectContainerPtr smallPDBProteins = loadProteins(smallPDBDirectory);
  std::cout << "SmallPDB " << ProteinStatisticsCalculator::computeStatistics(smallPDBProteins) << std::endl;
  smallPDBProteins = smallPDBProteins->apply(new ProteinToInputOutputPair());

  //proteins = proteins->apply(new ProteinToInputOutputPair());

  ObjectContainerPtr trainingData = smallPDBProteins->range(0,1);
  ObjectContainerPtr testingData = smallPDBProteins->range(0,1);

  std::cout << trainingData->size() << " Training Proteins "
            << testingData->size() << " Testing Proteins" << std::endl;


  /*
  ** Creation of the feature function
  */
  CompositeProteinResidueFeaturesPtr featureFunction = new CompositeProteinResidueFeatures();

  featureFunction->addSubFeatures(proteinUnitResidueFeature());
//  featureFunction->addSubFeatures(proteinPositionIndexResidueFeature()); // DEBUG !!

  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("AminoAcidSequence"), 8, 8, true));
  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("PositionSpecificScoringMatrix"), 8, 8, true));
  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("SecondaryStructureSequence"), 5, 5, true));
  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("DSSPSecondaryStructureSequence"), 5, 5, true));
  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("SolventAccessibilityThreshold20"), 5, 5, true));
  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("DisorderProbabilitySequence"), 5, 5, true));
  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("BackboneBondSequence"), 5, 5, true));

  CompositeProteinResidueFeaturesPtr tertiaryStructureFeatureFunction = new CompositeProteinResidueFeatures();
  tertiaryStructureFeatureFunction->addSubFeatures(proteinUnitResidueFeature());
  tertiaryStructureFeatureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("TertiaryStructure"), 5, 5, true));

 /* featureFunction->addSubFeatures(proteinFrequencyWindowFeatures(T("DisorderProbabilitySequence"), 5, true));
  featureFunction->addSubFeatures(proteinFrequencyWindowFeatures(T("DisorderProbabilitySequence"), 10, true));
  featureFunction->addSubFeatures(proteinFrequencyWindowFeatures(T("DisorderProbabilitySequence"), 20, true));

  // New features :
  featureFunction->addSubFeatures(proteinPositionFeatures());
  //featureFunction->addSubFeatures(proteinLengthFeatures());
  */
  featureFunction->addSubFeatures(proteinSegmentConjunctionFeatures(T("SecondaryStructureSequence"), 5));

  CompositeProteinResiduePairFeaturesPtr pairFeatureFunction = new CompositeProteinResiduePairFeatures();
  pairFeatureFunction->addSubFeatures(proteinPointResiduePairFeatures(featureFunction));
  pairFeatureFunction->addSubFeatures(separationLengthResiduePairFeatures());

  ProteinResidueFeaturesPtr calphaUpdateFeatures = new MyCalphaUpdateFeatures();

  /*
  ** Creation of the inference 
  */
  ProteinInferencePtr proteinInference = new ProteinInference();
  //proteinInference->loadSubInferencesFromDirectory(modelDirectory);
  proteinInference->setPDBDebugDirectory(File(T("C:\\Projets\\LBC++\\projects\\temp\\pdbs")));

  proteinInference->appendStep(new SampleRandomCAlphaTraceInferenceStep());
  for (size_t i = 1; i < 10; ++i)
  {
    InferenceStepPtr calphaUpdateStep = new ProteinCAlphaTraceUpdateInferenceStep(T("CA Update Pass ") + lbcpp::toString(i), calphaUpdateFeatures);
    proteinInference->appendStep(calphaUpdateStep);
    continue;

    {
      //Protein2DInferenceStepPtr step = new ProteinContactMapInferenceStep(T("RR Pass ") + lbcpp::toString(i),
       //                                                   pairFeatureFunction, T("ResidueResidueContactMatrix8Cb"));
      //proteinInference->appendStep(step);
    }
    {
      Protein1DInferenceStepPtr step;

      //step = new ProteinTertiaryStructureRefinementInferenceStep(T("TS Pass ") + lbcpp::toString(i), tertiaryStructureFeatureFunction);
      proteinInference->appendStep(step);
     
#if 0
      step = new ProteinSequenceLabelingInferenceStep(T("SS3 Pass ") + lbcpp::toString(i), featureFunction, /*T("SecondaryStructureProbabilities"), */T("SecondaryStructureSequence"));
      proteinInference->appendStep(step);
      step = new ProteinSequenceLabelingInferenceStep(T("DR Pass ") + lbcpp::toString(i), featureFunction, T("DisorderProbabilitySequence"), T("DisorderSequence"));
      proteinInference->appendStep(step);
      step = new ProteinSequenceLabelingInferenceStep(T("SA Pass ") + lbcpp::toString(i), featureFunction, T("SolventAccessibilityThreshold20"));
      proteinInference->appendStep(step);
      step = new ProteinBackboneBondSequenceInferenceStep(T("BBB Pass ") + lbcpp::toString(i), featureFunction);
      proteinInference->appendStep(step);
#endif // 0

      //step = new ProteinSequenceLabelingInferenceStep(T("SS8 Pass ") + lbcpp::toString(i), featureFunction, /*T("DSSPSecondaryStructureProbabilities"), */T("DSSPSecondaryStructureSequence"));
      //proteinInference->appendStep(step);

    }
  }
  std::cout << "Inference: " << proteinInference->toString() << std::endl;

  /*
  ** Learning
  */
  InferenceLearnerCallbackPtr callback = new MyInferenceLearnerCallback(trainingData, testingData, true);
  InferenceLearnerPtr learner = stepByStepDeterministicSimulationLearner(callback, true, modelDirectory, true);
  learner->train(proteinInference, trainingData);

  /*
  ** Evaluation
  */
  InferenceContextPtr validationContext = singleThreadedInferenceContext();
  ProteinEvaluationCallbackPtr evaluation = new ProteinEvaluationCallback();
  validationContext->appendCallback(evaluation);

  validationContext->runWithSupervisedExamples(proteinInference, trainingData);
  std::cout << "Train evaluation: " << evaluation->toString() << std::endl;

  validationContext->runWithSupervisedExamples(proteinInference, testingData);
  std::cout << "Test evaluation: " << evaluation->toString() << std::endl;

  return 0;
}
