/*-----------------------------------------.---------------------------------.
| Filename: SandBox.lcpp                   | Test Learning                   |
| Author  : Francis Maes                   |                                 |
| Started : 08/04/2010 16:27               |                                 |
`------------------------------------------/                                 |
                               |                                             |
                               `--------------------------------------------*/

#include <lbcpp/lbcpp.h>
#include "InferenceData/ScoreSymmetricMatrix.h"
#include "InferenceData/CommonFeatureGenerators.h"
#include "Protein/Evaluation/ProteinEvaluationCallback.h"
#include "Protein/Evaluation/ProteinStatisticsCalculator.h"
#include "Protein/SecondaryStructureDictionary.h"
#include "Protein/Inference/Protein1DInferenceStep.h"
#include "Protein/Inference/ProteinBackboneBondSequenceInferenceStep.h"
#include "Protein/Inference/ProteinContactMapInferenceStep.h"
#include "Protein/Inference/ProteinTertiaryStructureInferenceStep.h"
#include "Protein/Inference/ProteinInference.h"
#include <fstream>
using namespace lbcpp;

extern void declareProteinClasses();

class MyInferenceLearnerCallback : public InferenceLearnerCallback
{
public:
  MyInferenceLearnerCallback(ObjectContainerPtr trainingData, ObjectContainerPtr testingData, bool useCacheOnTestingData = true)
    : trainingData(trainingData), testingData(testingData), startingTime(Time::getMillisecondCounter())
  {
    if (useCacheOnTestingData)
      cache = new InferenceResultCache();
  }

  virtual InferenceContextPtr createContext()
    {return singleThreadedInferenceContext();}

  virtual double getProbabilityToCreateAnExample(InferenceStackPtr stack, ObjectPtr input, ObjectPtr supervision)
  {
    //String inferenceStepName = stack->getInference(1)->getName();
    return 1.0;
  }


  virtual ClassifierPtr createClassifier(InferenceStackPtr stack, FeatureDictionaryPtr labels)
  {
    std::cout << "CreateClassifier for step " << stack->getInference(1)->getName() << std::endl;
    if (labels == BinaryClassificationDictionary::getInstance())
    {
      IterationFunctionPtr learningRate = invLinearIterationFunction(0.5, 250000);
      GradientBasedLearnerPtr learner = stochasticDescentLearner(learningRate);  
      GradientBasedBinaryClassifierPtr classifier = linearSVMBinaryClassifier(learner, labels);
      classifier->setL2Regularizer(0.01);
      return classifier;
    }
    jassert(false); return ClassifierPtr();
  }

  virtual RegressorPtr createRegressor(InferenceStackPtr stack)
    {jassert(false); return RegressorPtr();}

  virtual void preLearningIterationCallback(size_t iterationNumber)
    {std::cout << std::endl << " ================== ITERATION " << iterationNumber << " ================== " << (Time::getMillisecondCounter() - startingTime) / 1000.0 << " s" <<  std::endl;}

  // returns false if learning should stop
  virtual bool postLearningIterationCallback(InferencePtr inference, size_t iterationNumber)
  {
    InferenceContextPtr validationContext = createContext();
    ProteinEvaluationCallbackPtr evaluation = new ProteinEvaluationCallback();
    validationContext->appendCallback(evaluation);
    if (cache)
      validationContext->appendCallback(cacheInferenceCallback(cache, inference));

    juce::uint32 startTime = Time::getMillisecondCounter();
    validationContext->runWithSupervisedExamples(inference, trainingData);
    double length = (Time::getMillisecondCounter() - startTime) / 1000.0;
    std::cout << "Train evaluation time: " << length << "s" << std::endl;
    std::cout << "Train evaluation: " << evaluation->toString() << std::endl;

    // stopping criterion
    return iterationNumber < 5;
  }
  
  virtual InferenceCallbackPtr createLearningCallback(LearnableAtomicInferencePtr inference, InferencePtr parentInference)
  {
    return stochasticDescentLearningCallback(inference,
      LearningInferenceCallback::never,                                   // randomization
      LearningInferenceCallback::perStep, invLinearIterationFunction(1.0, 10000), true, // learning
      LearningInferenceCallback::perStepMiniBatch20, sumOfSquaresFunction(0.01));    // regularizer
  }
  
  virtual void preLearningStepCallback(InferencePtr step)
  {
    String passName = step->getName();
    std::cout << std::endl << "=====================================================" << std::endl;
    std::cout << "======= LEARNING PASS " << passName << " ==========" << (Time::getMillisecondCounter() - startingTime) / 1000 << " s" << std::endl;
    std::cout << "=====================================================" << std::endl;
  }

  virtual void postLearningStepCallback(InferencePtr step)
    {}

private:
  ObjectContainerPtr trainingData;
  ObjectContainerPtr testingData;
  InferenceResultCachePtr cache;
  juce::uint32 startingTime;
};

ObjectContainerPtr loadProteins(const File& directory, size_t maxCount = 0)
{
  ObjectStreamPtr proteinsStream = directoryObjectStream(directory, T("*.protein"));
#ifdef JUCE_DEBUG
  ObjectContainerPtr res = proteinsStream->load(maxCount ? maxCount : 7)->randomize();
#else
  ObjectContainerPtr res = proteinsStream->load(maxCount)->randomize();
#endif
  for (size_t i = 0; i < res->size(); ++i)
  {
    ProteinPtr protein = res->getAndCast<Protein>(i);
    jassert(protein);
    protein->computeMissingFields();
  }
  return res;
}

class BinaryClassificationInference : public DecoratorInference
{
public:
  BinaryClassificationInference(const String& name, InferencePtr scoreInference)
    : DecoratorInference(name, scoreInference) {}
  BinaryClassificationInference() {}

  virtual ScalarFunctionPtr getLoss(size_t correctLabel) const = 0;

  virtual ObjectPtr run(InferenceContextPtr context, ObjectPtr input, ObjectPtr supervision, ReturnCode& returnCode)
  {
    FeatureDictionaryPtr labelDictionary = BinaryClassificationDictionary::getInstance();
    LabelPtr correctLabel = supervision.dynamicCast<Label>();
    jassert(!supervision || (correctLabel && correctLabel->getDictionary() == labelDictionary));
    ObjectPtr res = DecoratorInference::run(context, input, correctLabel ? getLoss(correctLabel->getIndex()) : ScalarFunctionPtr(), returnCode);
    if (!res)
      return res;
    ScalarPtr scalar = res.dynamicCast<Scalar>();
    jassert(scalar);
    return new Label(labelDictionary, scalar->getValue() > 0 ? 1 : 0);
  }
};

class BinaryLinearSVMInference : public BinaryClassificationInference
{
public:
  BinaryLinearSVMInference()
    : negativeLoss(hingeLoss(0)), positiveLoss(hingeLoss(1)) {}

  BinaryLinearSVMInference(const String& name)
    : BinaryClassificationInference(name, linearScalarInference(name)),
      negativeLoss(hingeLoss(0)), positiveLoss(hingeLoss(1)) {}

  virtual ScalarFunctionPtr getLoss(size_t correctLabel) const
    {return correctLabel ? positiveLoss : negativeLoss;}
  
private:
  ScalarFunctionPtr negativeLoss;
  ScalarFunctionPtr positiveLoss;
};

int main(int argc, char** argv)
{
  declareProteinClasses();

  File smallPDBDirectory(T("C:\\Projets\\LBC++\\projects\\temp\\SmallPDB"));
  ObjectContainerPtr smallPDBProteins = loadProteins(smallPDBDirectory.getChildFile(T("protein")));
  smallPDBProteins = smallPDBProteins->apply(new ProteinToInputOutputPairFunction());
  
/*  ObjectContainerPtr smallPDBProteins = directoriesObjectPairStream(
        smallPDBDirectory.getChildFile(T("proteinWithSS3DR")),
        smallPDBDirectory.getChildFile(T("protein")))->load(7);
*/

  ObjectContainerPtr trainingData = smallPDBProteins->size() >= 7 ? smallPDBProteins->invFold(0,7) : smallPDBProteins;
  ObjectContainerPtr testingData = smallPDBProteins->size() >= 7 ? smallPDBProteins->fold(0,7) : smallPDBProteins;

  std::cout << trainingData->size() << " Training Proteins "
            << testingData->size() << " Testing Proteins" << std::endl;

  CompositeProteinResidueFeaturesPtr featureFunction = new CompositeProteinResidueFeatures();

  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("AminoAcidSequence"), 8, 8, true));
  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("PositionSpecificScoringMatrix"), 8, 8, true));
  /*featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("SecondaryStructureSequence"), 5, 5, true));
  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("DSSPSecondaryStructureSequence"), 5, 5, true));
  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("SolventAccessibilityThreshold20"), 5, 5, true));
  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("DisorderProbabilitySequence"), 5, 5, true));
  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("BackboneBondSequence"), 5, 5, true));*/

  ProteinInferencePtr proteinInference = new ProteinInference();
  for (size_t i = 0; i < 1; ++i)
  {
    proteinInference->appendStep(
      new ProteinSequenceLabelingInferenceStep(T("SA20 Pass ") + lbcpp::toString(i), new BinaryLinearSVMInference(T("SA20")),
                                               featureFunction, T("SolventAccessibilityThreshold20")));
  }

  InferenceLearnerCallbackPtr callback = new MyInferenceLearnerCallback(trainingData, testingData, true);
  //InferenceLearnerPtr learner = stepByStepDeterministicSimulationLearner(callback, true);//, modelDirectory, true);
  InferenceLearnerPtr learner = globalSimulationLearner(callback);
  learner->train(proteinInference, trainingData);

  return 0;
}
