/*-----------------------------------------.---------------------------------.
| Filename: SandBox.lcpp                   | Test Learning                   |
| Author  : Francis Maes                   |                                 |
| Started : 08/04/2010 16:27               |                                 |
`------------------------------------------/                                 |
                               |                                             |
                               `--------------------------------------------*/

#include <lbcpp/lbcpp.h>
#include "InferenceStep/RegressionInferenceStep.h"
#include "InferenceStep/ParallelSharedMultiRegressionInferenceStep.h"
#include "InferenceLearner/InferenceLearner.h"
#include "InferenceLearner/InferenceLearnerCallback.h"
#include "InferenceContext/CacheInferenceCallback.h"
#include "Protein/Evaluation/ProteinEvaluationCallback.h"
#include "Protein/Evaluation/ProteinStatisticsCalculator.h"
#include "Protein/SecondaryStructureDictionary.h"
#include "Protein/Inference/ProteinSequenceInferenceStep.h"
#include "Protein/Inference/ProteinBackboneBondSequenceInferenceStep.h"
#include "Protein/Inference/ProteinInference.h"
using namespace lbcpp;

extern void declareProteinClasses();


///////////////////////////////////////////////////////////////////////////////////////////

/*
class PrintClassifiersSummaryVisitor : public DefaultInferenceVisitor
{
public:
  PrintClassifiersSummaryVisitor() : hop(0) {}

  virtual void visit(ClassificationInferenceStepPtr inference)
  {
    ++hop;
    std::cout << "ClassificationInferenceStep " << hop << ": ";
    ClassifierPtr classifier = inference->getClassifier();
    if (!classifier)
      std::cout << "<no classifier>" << std::endl;
    else
    {
      GradientBasedClassifierPtr gbc = classifier.dynamicCast<GradientBasedClassifier>();
      if (gbc)
      {
        DenseVectorPtr parameters = gbc->getParameters();
        std::cout << parameters->l0norm() << " parameters, norm = " << parameters->l2norm() << std::endl;
        this->parameters.push_back(parameters);
      }
      else
        std::cout << "<unknown classifier>" << std::endl;
    }
  }

  std::vector<DenseVectorPtr> parameters;

private:
  size_t hop;
};

typedef ReferenceCountedObjectPtr<PrintClassifiersSummaryVisitor> PrintClassifiersSummaryVisitorPtr;
*/
class MyInferenceLearnerCallback : public InferenceLearnerCallback
{
public:
  MyInferenceLearnerCallback(ObjectContainerPtr trainingData, ObjectContainerPtr testingData, bool useCacheOnTestingData = true)
    : trainingData(trainingData), testingData(testingData), startingTime(Time::getMillisecondCounter())
  {
    if (useCacheOnTestingData)
      cache = new InferenceResultCache();
  }

  virtual InferenceContextPtr createContext()
    {return singleThreadedInferenceContext();}
  
  virtual ClassifierPtr createClassifier(ClassificationInferenceStepPtr step, FeatureDictionaryPtr labels)
  {
    static const double regularizer = 0.0;
    static const bool useConstantLearningRate = false;

    IterationFunctionPtr learningRate = useConstantLearningRate ? invLinearIterationFunction(2.0, 250000) : constantIterationFunction(1.0);
    GradientBasedLearnerPtr learner = stochasticDescentLearner(learningRate);  
    GradientBasedClassifierPtr classifier = maximumEntropyClassifier(learner, labels);
    classifier->setL2Regularizer(regularizer);
    return classifier;
  }

  virtual RegressorPtr createRegressor(RegressionInferenceStepPtr step)
  {
    static const double regularizer = 0.0;
    static const bool useConstantLearningRate = true;

    IterationFunctionPtr learningRate = useConstantLearningRate ? invLinearIterationFunction(0.5, 150000) : constantIterationFunction(0.05);
    GradientBasedLearnerPtr learner = stochasticDescentLearner(learningRate);  
    return generalizedLinearRegressor(learner, regularizer);
  }

  virtual void preLearningIterationCallback(size_t iterationNumber)
    {std::cout << std::endl << " ================== ITERATION " << iterationNumber << " ================== " << (Time::getMillisecondCounter() - startingTime) / 1000.0 << " s" <<  std::endl;}

  // returns false if learning should stop
  virtual bool postLearningIterationCallback(InferenceStepPtr inference, size_t iterationNumber)
  {
    InferenceContextPtr validationContext = createContext();
    ProteinEvaluationCallbackPtr evaluation = new ProteinEvaluationCallback();
    validationContext->appendCallback(evaluation);
    if (cache)
      validationContext->appendCallback(new AutoSubStepsCacheInferenceCallback(cache, inference));

    validationContext->runWithSupervisedExamples(inference, trainingData);
    std::cout << "Train evaluation: " << evaluation->toString() << std::endl;
    //double trainRmse = evaluation->getPSSMRootMeanSquareError();
    
    validationContext->runWithSupervisedExamples(inference, testingData);
    std::cout << "Test evaluation: " << evaluation->toString() << std::endl;
    /*double testRmse = evaluation->getPSSMRootMeanSquareError();

    if (trainRmse < bestTrainRmse)
    {
      bestTrainRmse = trainRmse;
      bestTestRmse = testRmse;
    }*/

    // stopping criterion
    return iterationNumber < 10;
  }

  virtual void preLearningStepCallback(InferenceStepPtr step)
  {
    String passName = step->getName();
    std::cout << std::endl << "=====================================================" << std::endl;
    std::cout << "======= LEARNING PASS " << passName << " ==========" << (Time::getMillisecondCounter() - startingTime) / 1000 << " s" << std::endl;
    std::cout << "=====================================================" << std::endl;
    //bestTrainRmse = bestTestRmse = DBL_MAX;
  }

  virtual void postLearningStepCallback(InferenceStepPtr step)
  {
    //std::cout << "Best Train RMSE: " << bestTrainRmse << std::endl;
    //std::cout << "Best Test RMSE: " << bestTestRmse << std::endl;
  }

private:
  ObjectContainerPtr trainingData;
  ObjectContainerPtr testingData;
  InferenceResultCachePtr cache;
  juce::uint32 startingTime;

//  double bestTrainRmse, bestTestRmse;
};
/*
class ProteinToInputOutputPair : public ObjectFunction
{
public:
  virtual String getOutputClassName(const String& inputClassName) const
    {return T("ObjectPair");}

  virtual ObjectPtr function(ObjectPtr input) const
  {
    ProteinPtr protein = input.dynamicCast<Protein>();
    jassert(protein);
    ProteinPtr inputProtein = new Protein(protein->getName());
    inputProtein->setObject(protein->getAminoAcidSequence());
    return new ObjectPair(inputProtein, protein);
  }
};*/

ObjectContainerPtr loadProteins(const File& directory, size_t maxCount = 0)
{
  ObjectStreamPtr proteinsStream = directoryObjectStream(directory, T("*.protein"));
#ifdef JUCE_DEBUG
  ObjectContainerPtr res = proteinsStream->load(maxCount ? maxCount : 7)->randomize();
#else
  ObjectContainerPtr res = proteinsStream->load(maxCount)->randomize();
#endif
  for (size_t i = 0; i < res->size(); ++i)
    res->getAndCast<Protein>(i)->computeMissingFields();
  return res;
}

int main(int argc, char** argv)
{
  declareProteinClasses();

  File modelDirectory(T("C:\\Projets\\LBC++\\projects\\temp\\Models"));
  File contentOnlyModel = modelDirectory.getChildFile(T("0_PSSM-0.inference"));

  File cb513Directory(T("C:\\Projets\\LBC++\\projects\\temp\\CB513"));
  ObjectContainerPtr cb513Proteins = loadProteins(cb513Directory);
  /*File outputDirectory(T("C:\\Projets\\LBC++\\projects\\temp\\CB513"));
  for (size_t i = 0; i < cb513Proteins->size(); ++i)
  {
    ProteinPtr protein = cb513Proteins->getAndCast<Protein>(i);
    jassert(protein);
    std::cout << protein->getName() << std::endl;
    protein->computeMissingFields();
    protein->saveToFile(outputDirectory.getChildFile(protein->getName() + T(".protein")));
  }
  return 0;*/

  std::cout << "CB513 " << ProteinStatisticsCalculator::computeStatistics(cb513Proteins) << std::endl;

  File smallPDBDirectory(T("C:\\Projets\\LBC++\\projects\\temp\\SmallPDB\\protein"));
  ObjectContainerPtr smallPDBProteins = loadProteins(smallPDBDirectory);
  std::cout << "SmallPDB " << ProteinStatisticsCalculator::computeStatistics(smallPDBProteins) << std::endl;

  //proteins = proteins->apply(new ProteinToInputOutputPair());

  ObjectContainerPtr trainingData = cb513Proteins->fold(0,2)->apply(new ObjectToObjectPairFunction());
  ObjectContainerPtr testingData = cb513Proteins->fold(1,2)->apply(new ObjectToObjectPairFunction());

  std::cout << trainingData->size() << " Training Proteins "
            << testingData->size() << " Testing Proteins" << std::endl;


  /*
  ** Creation of the feature function
  */
  CompositeProteinResidueFeaturesPtr featureFunction = new CompositeProteinResidueFeatures();

  featureFunction->addSubFeatures(proteinUnitResidueFeature());
//  featureFunction->addSubFeatures(proteinPositionIndexResidueFeature()); // DEBUG !!

  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("AminoAcidSequence"), 8, 8, true));
  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("PositionSpecificScoringMatrix"), 8, 8, true));
  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("SecondaryStructureSequence"), 5, 5, true));
  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("DSSPSecondaryStructureSequence"), 5, 5, true));
  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("SolventAccessibilityThreshold20"), 5, 5, true));

  /*
  ** Creation of the inference 
  */
  ProteinInferencePtr proteinInference = new ProteinInference();
  for (size_t i = 0; i < 5; ++i)
  {
    ProteinSequenceInferenceStepPtr step;

    // the same feature function is used for CO and for subsequent passes
    step = new ProteinSequenceLabelingInferenceStep(T("SA Pass ") + lbcpp::toString(i), featureFunction, T("SolventAccessibilityThreshold20"));
    proteinInference->appendStep(step);
    step = new ProteinSequenceLabelingInferenceStep(T("SS3 Pass ") + lbcpp::toString(i), featureFunction, T("SecondaryStructureSequence"));
    proteinInference->appendStep(step);
    step = new ProteinSequenceLabelingInferenceStep(T("SS8 Pass ") + lbcpp::toString(i), featureFunction, T("DSSPSecondaryStructureSequence"));
    proteinInference->appendStep(step);
    step = new ProteinBackboneBondSequenceInferenceStep(T("Backbone Pass ") + lbcpp::toString(i), featureFunction);
    proteinInference->appendStep(step);

  }

  /*
  ** Learning
  */
  InferenceLearnerCallbackPtr callback = new MyInferenceLearnerCallback(trainingData, testingData, true);
  InferenceLearnerPtr learner = stepByStepDeterministicSimulationLearner(callback, true, 0);
  learner->train(proteinInference, trainingData);

#if 0 // PSSMs


#define TRAIN_AND_SAVE

#ifdef TRAIN_AND_SAVE 
  proteinInference->appendStep(Object::createFromFileAndCast<InferenceStep>(contentOnlyModel));
  proteinInference->appendStep(new PSSMPredictionInferenceStep(T("PSSM-1")));

  InferenceLearnerCallbackPtr callback = new MyInferenceLearnerCallback(trainingData, testingData, true);
  InferenceLearnerPtr learner = stepByStepDeterministicSimulationLearner(callback, true, 1);
  learner->train(proteinInference, trainingData);

  proteinInference->saveToFile(modelDirectory);
#else
  
  proteinInference->appendStep(Object::createFromFileAndCast<InferenceStep>(contentOnlyModel));
  InferenceContextPtr validationContext = singleThreadedInferenceContext();
  ProteinEvaluationCallbackPtr evaluation = new ProteinEvaluationCallback();
  validationContext->appendCallback(evaluation);

  validationContext->runWithSupervisedExamples(proteinInference, trainingData);
  std::cout << "Train evaluation: " << evaluation->toString() << std::endl;
  double trainRmse = evaluation->getPSSMRootMeanSquareError();

  validationContext->runWithSupervisedExamples(proteinInference, testingData);
  std::cout << "Test evaluation: " << evaluation->toString() << std::endl;
  double testRmse = evaluation->getPSSMRootMeanSquareError();
  
  std::cout << "Train: " << trainRmse << " Test: " << testRmse << std::endl;
  
#endif

#endif // PSSMS
  return 0;
}
