/*-----------------------------------------.---------------------------------.
| Filename: SandBox.lcpp                   | Test Learning                   |
| Author  : Francis Maes                   |                                 |
| Started : 08/04/2010 16:27               |                                 |
`------------------------------------------/                                 |
                               |                                             |
                               `--------------------------------------------*/

#include <lbcpp/lbcpp.h>
#include "InferenceStep/RegressionInferenceStep.h"
#include "InferenceStep/ParallelSharedMultiRegressionInferenceStep.h"
#include "InferenceStep/ParallelSequenceMultiRegressionInferenceStep.h"
#include "InferenceLearner/InferenceLearner.h"
#include "InferenceLearner/InferenceLearnerCallback.h"
#include "InferenceContext/CacheInferenceCallback.h"
#include "Protein/ProteinEvaluationCallback.h"
#include "Protein/ProteinInference.h"
using namespace lbcpp;

extern void declareProteinClasses();

///////////////////////////////////////////////////////////////////////////////////////////

class PSSMRowPredictionInput : public Object
{
public:
  PSSMRowPredictionInput(ProteinPtr protein, size_t position)
    : protein(protein), position(position) {}

  ProteinPtr getProtein() const
    {return protein;}

  size_t getPosition() const
    {return position;}

  featureGenerator getCommonFeaturesImpl() const
  {
    LabelSequencePtr aminoAcidSequence = protein->getAminoAcidSequence();
    ScoreVectorSequencePtr pssm = protein->getPositionSpecificScoringMatrix();

    jassert(aminoAcidSequence);
    jassert(position < aminoAcidSequence->size());
    //featureCall(0) aminoAcidSequence->elementFeatures(position);
    featureCall(0) aminoAcidSequence->windowFeatures(position, 7, 7, true);
    //featureCall(1) sequenceMultiScaleCenteredConjunctionFeatures(aminoAcidSequence, position, 1, 3, false);
    //featureCall(0) aminoAcidSequence->multiScaleSymetricFrequencyFeatures(position, 1, 2, 8, true);

    if (pssm)
    {
      featureCall(1) pssm->windowFeatures(position, 5, 5, true);
    }
  }

  featureGenerator sequenceMultiScaleCenteredConjunctionFeatures(SequencePtr sequence, size_t position, size_t minConjunctionSize, size_t maxConjunctionSize, bool onlyConjunctionsWherePositionAppears) const
  {
    jassert(maxConjunctionSize >= minConjunctionSize);
    for (size_t i = minConjunctionSize; i <= maxConjunctionSize; ++i)
      featureCall(i - minConjunctionSize) sequenceCenteredConjunctionFeatures(sequence, position, i, onlyConjunctionsWherePositionAppears ? i : maxConjunctionSize);
  }

  featureGenerator sequenceCenteredConjunctionFeatures(SequencePtr sequence, size_t position, size_t conjunctionSize, size_t windowSize) const
  {
    int p = (int)position - (windowSize - 1);
    for (size_t i = 0; i < windowSize; ++i)
      featureCall(i) sequenceConjunctionFeatures(sequence, p + (int)i, conjunctionSize);
  }
  
  featureGenerator sequenceConjunctionFeatures(SequencePtr sequence, int firstPosition, size_t conjunctionSize) const
  {
    String str;
    for (size_t i = 0; i < conjunctionSize; ++i)
    {
      if (str.isNotEmpty())
        str += T("^");
      str += sequenceElementString(sequence, firstPosition + (int)i);
    }
    featureSense(str);
  }

  String sequenceElementString(SequencePtr sequence, int position) const
  {
    if (position < 0)
      return T("<");
    else if (position >= (int)sequence->size())
      return T(">");
    else
      return sequence->elementToString((size_t)position);
  }

  FeatureGeneratorPtr getCommonFeatures() const
  {
    if (!commonFeatures)
    {
      const_cast<PSSMRowPredictionInput* >(this)->commonFeatures = getCommonFeaturesImpl()->toSparseVector();
      //std::cout << commonFeatures->toString() << std::endl;
    }
    return commonFeatures;
  }
  
private:
  SparseVectorPtr commonFeatures;
  ProteinPtr protein;
  size_t position;
};

typedef ReferenceCountedObjectPtr<PSSMRowPredictionInput> PSSMRowPredictionInputPtr;

class PSSMRowPredictionInferenceStep : public ParallelSharedMultiRegressionInferenceStep
{
public:
  PSSMRowPredictionInferenceStep()
    : ParallelSharedMultiRegressionInferenceStep(T("PSSMRow"), AminoAcidDictionary::getInstance()) {}

  virtual size_t getNumSubInferences(ObjectPtr) const
    {return AminoAcidDictionary::numAminoAcids;}
 
  featureGenerator getInputFeatures(ObjectPtr input_, size_t scoreIndex) const
  {
    PSSMRowPredictionInputPtr input = input_.dynamicCast<PSSMRowPredictionInput>();
    jassert(input);
    featureSense(scoreIndex);
    featureCall(scoreIndex) input->getCommonFeatures();
  }
};

class PSSMPredictionInferenceStep : public ParallelSequenceMultiRegressionInferenceStep
{
public:
  PSSMPredictionInferenceStep(const String& name)
    : ParallelSequenceMultiRegressionInferenceStep(name, new PSSMRowPredictionInferenceStep()) {}
  PSSMPredictionInferenceStep() {}

  virtual size_t getNumSubInferences(ObjectPtr input) const
    {return getProtein(input)->getLength();}

  virtual ObjectPtr getSubInput(ObjectPtr input, size_t index) const
    {return new PSSMRowPredictionInput(getProtein(input), index);}

  virtual ObjectPtr getSubSupervision(ObjectPtr supervision, size_t index) const
  {
    if (!supervision)
      return ObjectPtr();
    ScoreVectorSequencePtr pssm = getProtein(supervision)->getPositionSpecificScoringMatrix();
    return ParallelSequenceMultiRegressionInferenceStep::getSubSupervision(pssm, index);
  }

  virtual ObjectPtr createEmptyOutput(ObjectPtr input) const
    {return new ScoreVectorSequence(T("PositionSpecificScoringMatrix"), AminoAcidDictionary::getInstance(), getProtein(input)->getLength(), AminoAcidDictionary::numAminoAcids);}

private:
  ProteinPtr getProtein(ObjectPtr object) const
  {
    ProteinPtr protein = object.dynamicCast<Protein>();
    jassert(protein);
    return protein;
  }
};


///////////////////////////////////////////////////////////////////////////////////////////

class MyProteinSequenceLabelingInferenceStep : public ProteinSequenceLabelingInferenceStep
{
public:
  MyProteinSequenceLabelingInferenceStep(const String& name, const String& target, FeatureDictionaryPtr targetDictionary)
    : ProteinSequenceLabelingInferenceStep(name), target(target), targetDictionary(targetDictionary) {}
  MyProteinSequenceLabelingInferenceStep() {}

  virtual String getTargetName() const
    {return target;}

  virtual FeatureDictionaryPtr getTargetDictionary() const
  {
    jassert(targetDictionary);
    return targetDictionary;
  }

  virtual featureGenerator getInputFeatures(ObjectPtr input, size_t index) const
  {
    ProteinPtr protein = input.dynamicCast<Protein>();
    jassert(protein);
    LabelSequencePtr aminoAcidSequence = protein->getAminoAcidSequence();
    ScoreVectorSequencePtr positionSpecificScores = protein->getPositionSpecificScoringMatrix();

    featureCall("a") aminoAcidSequence->windowFeatures(index, 8, 8, true);
    featureCall("p") positionSpecificScores->windowFeatures(index, 8, 8, true);

    LabelSequencePtr secondaryStructure = protein->getSecondaryStructureSequence();
    if (secondaryStructure)
      {featureCall("s3") secondaryStructure->windowFeatures(index, 5, 5, true);}

    LabelSequencePtr dsspSecondaryStructure = protein->getDSSPSecondaryStructureSequence();
    if (dsspSecondaryStructure)
      {featureCall("s8") dsspSecondaryStructure->windowFeatures(index, 5, 5, true);}

    LabelSequencePtr solventAccesibility = protein->getSolventAccessibilitySequence();
    if (solventAccesibility)
      {featureCall("sa") solventAccesibility->windowFeatures(index, 5, 5, true);}

    //    featureCall("w8f") dsspSecondaryStructure->multiScaleSymetricFrequencyFeatures(index, 1, 2, 8, false); // 1, 2, 4, 8, 16, ..., 256
  }

protected:
  String target;
  FeatureDictionaryPtr targetDictionary;

  virtual bool load(InputStream& istr)
  {
    if (!ProteinSequenceLabelingInferenceStep::load(istr) ||
        !lbcpp::read(istr, target))
      return false;
    targetDictionary = FeatureDictionaryManager::getInstance().readDictionaryNameAndGet(istr);
    return targetDictionary != FeatureDictionaryPtr();
  }

  virtual void save(OutputStream& ostr) const
  {
    ProteinSequenceLabelingInferenceStep::save(ostr);
    lbcpp::write(ostr, target);
    lbcpp::write(ostr, targetDictionary->getName());
  }
};
/*
class PrintClassifiersSummaryVisitor : public DefaultInferenceVisitor
{
public:
  PrintClassifiersSummaryVisitor() : hop(0) {}

  virtual void visit(ClassificationInferenceStepPtr inference)
  {
    ++hop;
    std::cout << "ClassificationInferenceStep " << hop << ": ";
    ClassifierPtr classifier = inference->getClassifier();
    if (!classifier)
      std::cout << "<no classifier>" << std::endl;
    else
    {
      GradientBasedClassifierPtr gbc = classifier.dynamicCast<GradientBasedClassifier>();
      if (gbc)
      {
        DenseVectorPtr parameters = gbc->getParameters();
        std::cout << parameters->l0norm() << " parameters, norm = " << parameters->l2norm() << std::endl;
        this->parameters.push_back(parameters);
      }
      else
        std::cout << "<unknown classifier>" << std::endl;
    }
  }

  std::vector<DenseVectorPtr> parameters;

private:
  size_t hop;
};

typedef ReferenceCountedObjectPtr<PrintClassifiersSummaryVisitor> PrintClassifiersSummaryVisitorPtr;
*/
class MyInferenceLearnerCallback : public InferenceLearnerCallback
{
public:
  MyInferenceLearnerCallback(ObjectContainerPtr trainingData, ObjectContainerPtr testingData, bool useCacheOnTestingData = true)
    : trainingData(trainingData), testingData(testingData), startingTime(Time::getMillisecondCounter())
  {
    if (useCacheOnTestingData)
      cache = new InferenceResultCache();
  }

  virtual InferenceContextPtr createContext()
    {return singleThreadedInferenceContext();}
  
  virtual ClassifierPtr createClassifier(ClassificationInferenceStepPtr step, FeatureDictionaryPtr labels)
  {
    static const double regularizer = 10.0;
    static const bool useConstantLearningRate = false;

    IterationFunctionPtr learningRate = useConstantLearningRate ? invLinearIterationFunction(2.0, 250000) : constantIterationFunction(1.0);
    GradientBasedLearnerPtr learner = stochasticDescentLearner(learningRate);  
    GradientBasedClassifierPtr classifier = maximumEntropyClassifier(learner, labels);
    classifier->setL2Regularizer(regularizer);
    return classifier;
  }

  virtual RegressorPtr createRegressor(RegressionInferenceStepPtr step)
  {
    static const double regularizer = 0.0;
    static const bool useConstantLearningRate = true;

    IterationFunctionPtr learningRate = useConstantLearningRate ? invLinearIterationFunction(0.5, 150000) : constantIterationFunction(0.8);
    GradientBasedLearnerPtr learner = stochasticDescentLearner(learningRate);  
    return leastSquaresLinearRegressor(learner, regularizer);
  }

  virtual void preLearningIterationCallback(size_t iterationNumber)
    {std::cout << std::endl << " ================== ITERATION " << iterationNumber << " ================== " << (Time::getMillisecondCounter() - startingTime) / 1000.0 << " s" <<  std::endl;}

  // returns false if learning should stop
  virtual bool postLearningIterationCallback(InferenceStepPtr inference, size_t iterationNumber)
  {
    InferenceContextPtr validationContext = createContext();
    ProteinEvaluationCallbackPtr evaluation = new ProteinEvaluationCallback();
    validationContext->appendCallback(evaluation);
    if (cache)
      validationContext->appendCallback(new AutoSubStepsCacheInferenceCallback(cache, inference));

    validationContext->runWithSupervisedExamples(inference, trainingData);
    std::cout << "Train evaluation: " << evaluation->toString() << std::endl;
    double trainRmse = evaluation->getPSSMRootMeanSquareError();
    
    validationContext->runWithSupervisedExamples(inference, testingData);
    std::cout << "Test evaluation: " << evaluation->toString() << std::endl;
    double testRmse = evaluation->getPSSMRootMeanSquareError();

    if (trainRmse < bestTrainRmse)
    {
      bestTrainRmse = trainRmse;
      bestTestRmse = testRmse;
    }

    // stopping criterion
    return iterationNumber < 1;
  }

  virtual void preLearningStepCallback(InferenceStepPtr step)
  {
    String passName = step->getName();
    std::cout << std::endl << "=====================================================" << std::endl;
    std::cout << "======= LEARNING PASS " << passName << " ==========" << (Time::getMillisecondCounter() - startingTime) / 1000 << " s" << std::endl;
    std::cout << "=====================================================" << std::endl;
    bestTrainRmse = bestTestRmse = DBL_MAX;
  }

  virtual void postLearningStepCallback(InferenceStepPtr step)
  {
    std::cout << "Best Train RMSE: " << bestTrainRmse << std::endl;
    std::cout << "Best Test RMSE: " << bestTestRmse << std::endl;
  }

private:
  ObjectContainerPtr trainingData;
  ObjectContainerPtr testingData;
  InferenceResultCachePtr cache;
  juce::uint32 startingTime;

  double bestTrainRmse, bestTestRmse;
};
/*
class ProteinToInputOutputPair : public ObjectFunction
{
public:
  virtual String getOutputClassName(const String& inputClassName) const
    {return T("ObjectPair");}

  virtual ObjectPtr function(ObjectPtr input) const
  {
    ProteinPtr protein = input.dynamicCast<Protein>();
    jassert(protein);
    ProteinPtr inputProtein = new Protein(protein->getName());
    inputProtein->setObject(protein->getAminoAcidSequence());
    return new ObjectPair(inputProtein, protein);
  }
};*/

ObjectContainerPtr loadProteins(const File& directory)
{
  ObjectStreamPtr proteinsStream = directoryObjectStream(directory, T("*.protein"));
#ifdef JUCE_DEBUG
  ObjectContainerPtr res = proteinsStream->load(7)->randomize();
#else
  ObjectContainerPtr res = proteinsStream->load()->randomize();
#endif
  for (size_t i = 0; i < res->size(); ++i)
    res->getAndCast<Protein>(i)->computeMissingFields();
  return res;
}

class ProteinStatisticsCalculator : public ObjectConsumer
{
public:
  ProteinStatisticsCalculator() : numProteins(0),
    aminoAcidsPerProtein(T("Amino Acids / Protein")),
    secondaryStructureElementsPerProtein(T("Secondary Structure / Protein")),
    dsspElementsPerProtein(T("DSSP Secondary Structure / Protein")),
    solventAccesibilityElementsPerProtein(T("Solvent Accesibility / Protein")),
    atomsPerProtein(T("Atoms / Protein")),
    residuesPerProtein(T("Residues / Protein")),
    nCalphaLength(T("N--CA length")),
    calphaCLength(T("CA--C length")), 
    cnLength(T("C--N length")),
    calphaCalphaLength(T("CA--CA length")),
    calphaAngle(T("N--CA--C angle")),
    carbonAngle(T("CA--C--N' angle")),
    nitrogenAngle(T("C--N'--CA' angle"))
  {
  }

  static String computeStatistics(ObjectContainerPtr proteins)
  {
    ReferenceCountedObjectPtr<ProteinStatisticsCalculator> calculator = new ProteinStatisticsCalculator();
    calculator->consumeContainer(proteins);
    return calculator->toString();
  }

  virtual void consume(ObjectPtr object)
  {
    ProteinPtr protein = object.dynamicCast<Protein>();
    jassert(protein);

    ++numProteins;

    aminoAcidsPerProtein.push(countNumberOfElements(protein->getAminoAcidSequence()));
    secondaryStructureElementsPerProtein.push(countNumberOfElements(protein->getSecondaryStructureSequence()));
    dsspElementsPerProtein.push(countNumberOfElements(protein->getDSSPSecondaryStructureSequence()));
    solventAccesibilityElementsPerProtein.push(countNumberOfElements(protein->getSolventAccessibilitySequence()));

    ProteinTertiaryStructurePtr tertiaryStructure = protein->getTertiaryStructure();
    residuesPerProtein.push(countNumberOfElements(tertiaryStructure));

    size_t numAtoms = 0;
    if (tertiaryStructure)
      for (size_t i = 0; i < tertiaryStructure->size(); ++i)
      {
        ProteinResiduePtr residue = tertiaryStructure->getResidue(i);
        if (residue)
          numAtoms += residue->getNumAtoms();
      }
    atomsPerProtein.push(numAtoms);
  }

  static size_t countNumberOfElements(SequencePtr sequence)
  {
    if (!sequence)
      return 0;
    size_t n = sequence->size();
    size_t res = 0;
    for (size_t i = 0; i < n; ++i)
      if (sequence->get(i) != ObjectPtr())
        ++res;
    return res;
  }

  /*
      for (size_t i = 0; i < tertiaryStructure->size(); ++i)
    {
      ProteinResiduePtr residue = tertiaryStructure->getResidue(i);

      Vector3 nitrogen = residue->getNitrogenAtom()->getPosition();
      Vector3 calpha = residue->getCAlphaAtom()->getPosition();
      Vector3 carbon = residue->getCarbonAtom()->getPosition();

      nCalphaLength.push((calpha - nitrogen).l2norm());
      calphaCLength.push((carbon - calpha).l2norm());
      ProteinResiduePtr nextResidue = i < tertiaryStructure->size() - 1 ? tertiaryStructure->getResidue(i + 1) : ProteinResiduePtr();
      if (nextResidue)
      {
        Vector3 nextNitrogen = nextResidue->getNitrogenAtom()->getPosition();
        cnLength.push((nextNitrogen - carbon).l2norm());

        Vector3 nextCalpha = nextResidue->getCAlphaAtom()->getPosition();
        calphaCalphaLength.push((nextCalpha - calpha).l2norm());

        carbonAngle.push((carbon - calpha).angle(nextNitrogen - carbon));
        nitrogenAngle.push((nextNitrogen - carbon).angle(nextCalpha - nextNitrogen));
      }

      calphaAngle.push((calpha - nitrogen).angle(carbon - calpha));
    }
    */

  virtual String toString() const
  {
    String res = T("Statistics on ") + lbcpp::toString(numProteins) + T(" protein(s)\n");
    res += countsPerProteinToString(aminoAcidsPerProtein);
    res += countsPerProteinToString(secondaryStructureElementsPerProtein);
    res += countsPerProteinToString(dsspElementsPerProtein);
    res += countsPerProteinToString(solventAccesibilityElementsPerProtein);
    res += countsPerProteinToString(atomsPerProtein);
    res += countsPerProteinToString(residuesPerProtein);
    return res;
  }

  static String countsPerProteinToString(const ScalarVariableStatistics& stats)
    {return stats.getName() + T(" average = ") + String(stats.getMean()) + T(" total = ") + String(stats.getSum()) + T("\n");}

private:
  size_t numProteins;

  ScalarVariableStatistics aminoAcidsPerProtein;
  ScalarVariableStatistics secondaryStructureElementsPerProtein;
  ScalarVariableStatistics dsspElementsPerProtein;
  ScalarVariableStatistics solventAccesibilityElementsPerProtein;
  ScalarVariableStatistics atomsPerProtein;
  ScalarVariableStatistics residuesPerProtein;

  ScalarVariableStatistics nCalphaLength;
  ScalarVariableStatistics calphaCLength;
  ScalarVariableStatistics cnLength;
  ScalarVariableStatistics calphaCalphaLength;

  ScalarVariableStatistics calphaAngle;
  ScalarVariableStatistics carbonAngle;
  ScalarVariableStatistics nitrogenAngle;
};

int main(int argc, char** argv)
{
  declareProteinClasses();
  LBCPP_DECLARE_CLASS(MyProteinSequenceLabelingInferenceStep);
  LBCPP_DECLARE_CLASS(PSSMRowPredictionInferenceStep);
  LBCPP_DECLARE_CLASS(PSSMPredictionInferenceStep);


  File modelDirectory(T("C:\\Projets\\LBC++\\projects\\temp\\Models"));
  File contentOnlyModel = modelDirectory.getChildFile(T("0_PSSM-0.inference"));

  File cb513Directory(T("C:\\Projets\\LBC++\\projects\\temp\\CB513New"));
  
  ObjectContainerPtr cb513Proteins = loadProteins(cb513Directory);
  std::cout << "CB513 " << ProteinStatisticsCalculator::computeStatistics(cb513Proteins) << std::endl;

  File smallPDBDirectory(T("C:\\Projets\\LBC++\\projects\\temp\\SmallPDBCompiled"));
  ObjectContainerPtr smallPDBProteins = loadProteins(smallPDBDirectory);
  std::cout << "SmallPDB " << ProteinStatisticsCalculator::computeStatistics(smallPDBProteins) << std::endl;

  //proteins = proteins->apply(new ProteinToInputOutputPair());

  ObjectContainerPtr trainingData = cb513Proteins->invFold(0, 7)->apply(new ObjectToObjectPairFunction());
  ObjectContainerPtr testingData = smallPDBProteins->apply(new ObjectToObjectPairFunction());

  std::cout << trainingData->size() << " Training Proteins "
            << testingData->size() << " Testing Proteins" << std::endl;

  ProteinInferencePtr proteinInference = new ProteinInference();
  
  ProteinSequenceLabelingInferenceStepPtr step;

  for (size_t i = 0; i < 2; ++i)
  {
    step = new MyProteinSequenceLabelingInferenceStep(T("SS3 Pass ") + lbcpp::toString(i), T("SecondaryStructureSequence"), SecondaryStructureDictionary::getInstance());
    proteinInference->appendStep(step);
    step = new MyProteinSequenceLabelingInferenceStep(T("SA Pass ") + lbcpp::toString(i), T("SolventAccessibilitySequence"), SolventAccesibility2StateDictionary::getInstance());
    proteinInference->appendStep(step);
    step = new MyProteinSequenceLabelingInferenceStep(T("SS8 Pass ") + lbcpp::toString(i), T("DSSPSecondaryStructureSequence"), DSSPSecondaryStructureDictionary::getInstance());
    proteinInference->appendStep(step);
  }

  InferenceLearnerCallbackPtr callback = new MyInferenceLearnerCallback(trainingData, testingData, true);
  InferenceLearnerPtr learner = stepByStepDeterministicSimulationLearner(callback, true, 0);
  learner->train(proteinInference, trainingData);


#if 0 // PSSMs


#define TRAIN_AND_SAVE

#ifdef TRAIN_AND_SAVE 
  proteinInference->appendStep(Object::createFromFileAndCast<InferenceStep>(contentOnlyModel));
  proteinInference->appendStep(new PSSMPredictionInferenceStep(T("PSSM-1")));

  InferenceLearnerCallbackPtr callback = new MyInferenceLearnerCallback(trainingData, testingData, true);
  InferenceLearnerPtr learner = stepByStepDeterministicSimulationLearner(callback, true, 1);
  learner->train(proteinInference, trainingData);

  proteinInference->saveToFile(modelDirectory);
#else
  
  proteinInference->appendStep(Object::createFromFileAndCast<InferenceStep>(contentOnlyModel));
  InferenceContextPtr validationContext = singleThreadedInferenceContext();
  ProteinEvaluationCallbackPtr evaluation = new ProteinEvaluationCallback();
  validationContext->appendCallback(evaluation);

  validationContext->runWithSupervisedExamples(proteinInference, trainingData);
  std::cout << "Train evaluation: " << evaluation->toString() << std::endl;
  double trainRmse = evaluation->getPSSMRootMeanSquareError();

  validationContext->runWithSupervisedExamples(proteinInference, testingData);
  std::cout << "Test evaluation: " << evaluation->toString() << std::endl;
  double testRmse = evaluation->getPSSMRootMeanSquareError();
  
  std::cout << "Train: " << trainRmse << " Test: " << testRmse << std::endl;
  
#endif

#endif // PSSMS
  return 0;
}
