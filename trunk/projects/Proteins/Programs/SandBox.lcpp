/*-----------------------------------------.---------------------------------.
| Filename: SandBox.lcpp                   | Test Learning                   |
| Author  : Francis Maes                   |                                 |
| Started : 08/04/2010 16:27               |                                 |
`------------------------------------------/                                 |
                               |                                             |
                               `--------------------------------------------*/

#include <lbcpp/lbcpp.h>
#include "InferenceData/ScoreSymmetricMatrix.h"
#include "InferenceData/CommonFeatureGenerators.h"
#include "Protein/Evaluation/ProteinEvaluationCallback.h"
#include "Protein/Evaluation/ProteinStatisticsCalculator.h"
#include "Protein/SecondaryStructureDictionary.h"
#include "Protein/Inference/Protein1DTargetInference.h"
#include "Protein/Inference/ProteinBackboneBondSequenceInference.h"
#include "Protein/Inference/ProteinContactMapInference.h"
#include "Protein/Inference/ProteinTertiaryStructureInference.h"
#include "Protein/Inference/ProteinInference.h"
#include <fstream>
using namespace lbcpp;

extern void declareProteinClasses();

class MyInferenceCallback : public InferenceCallback
{
public:
  MyInferenceCallback(InferencePtr inference, ObjectContainerPtr trainingData, ObjectContainerPtr testingData)
    : inference(inference), trainingData(trainingData), testingData(testingData) {}

  virtual void preInferenceCallback(InferenceStackPtr stack, ObjectPtr& input, ObjectPtr& supervision, ObjectPtr& output, ReturnCode& returnCode)
  {
    String inferenceClassName = stack->getCurrentInference()->getClassName();

    if (stack->getDepth() == 1)
    {
      startingTime = Time::getMillisecondCounter();
      bestTrainContactMap = bestTestContactMap = 0.0;
    }
    else if (stack->getDepth() == 2)
    {
      InferencePtr learnedInference = input.dynamicCast<Inference>();
      if (learnedInference)
      {
        String inferenceName = learnedInference->getName();
        std::cout << std::endl << "=====================================================" << std::endl;
        std::cout << "======= " << inferenceName << " ==========" << (Time::getMillisecondCounter() - startingTime) / 1000 << " s" << std::endl;
        std::cout << "=====================================================" << std::endl;
      }
      iterationNumber = 0;
    }
    else if (inferenceClassName == T("RunOnSupervisedExamplesInference"))
    {
      std::cout << std::endl << " ================== ITERATION " << ++iterationNumber << " ================== " << (Time::getMillisecondCounter() - startingTime) / 1000.0 << " s" <<  std::endl;
    }
  }
  
  virtual void postInferenceCallback(InferenceStackPtr stack, ObjectPtr input, ObjectPtr supervision, ObjectPtr& output, ReturnCode& returnCode)
  {
    String inferenceClassName = stack->getCurrentInference()->getClassName();

    if (inferenceClassName == T("RunOnSupervisedExamplesInference"))
    {
      InferenceContextPtr validationContext = singleThreadedInferenceContext();
      ProteinEvaluationCallbackPtr evaluation = new ProteinEvaluationCallback();
      validationContext->appendCallback(evaluation);
      validationContext->runWithSupervisedExamples(inference, trainingData);
      processResults(evaluation, true);
      validationContext->runWithSupervisedExamples(inference, testingData);
      processResults(evaluation, false);
    }
    else if (stack->getDepth() == 1)
    {
      std::cout << "Best train: " << bestTrainContactMap << " test: " << bestTestContactMap << std::endl;
      std::cout << "Bye." << std::endl;
    }
  }

  void processResults(ProteinEvaluationCallbackPtr evaluation, bool isTrainingData)
  {
    EvaluatorPtr contactMapEvaluator = evaluation->getEvaluatorForTarget(T("ResidueResidueContactMatrix8Ca"));
    jassert(contactMapEvaluator);
    std::cout << (isTrainingData ? "Train: " : "Test: ") << contactMapEvaluator->toString() << std::endl;
      
    std::vector< std::pair<String, double> > scores;
    contactMapEvaluator->getScores(scores);
    for (size_t i = 0; i < scores.size(); ++i)
      std::cout << scores[i].first << ": " << scores[i].second << std::endl;
  }

private:
  InferencePtr inference;
  ObjectContainerPtr trainingData, testingData;
  size_t iterationNumber;
  juce::uint32 startingTime;

  double bestTrainContactMap, bestTestContactMap;

  void updateBestScore(double score, double& bestScore)
    {if (score > bestScore) bestScore = score;}
};

ObjectContainerPtr loadProteins(const File& directory, size_t maxCount = 0)
{
  ObjectStreamPtr proteinsStream = directoryObjectStream(directory, T("*.protein"));
#ifdef JUCE_DEBUG
  ObjectContainerPtr res = proteinsStream->load(maxCount ? maxCount : 7)->randomize();
#else
  ObjectContainerPtr res = proteinsStream->load(maxCount)->randomize();
#endif
  for (size_t i = 0; i < res->size(); ++i)
  {
    ProteinPtr protein = res->getAndCast<Protein>(i);
    jassert(protein);
    protein->computeMissingFields();
  }
  return res;
}

InferenceOnlineLearnerPtr createOnlineLearner(double initialLearningRate = 1.0)
{
  StoppingCriterionPtr stoppingCriterion = maxIterationsStoppingCriterion(25);/*logicalOr(
    maxIterationsStoppingCriterion(100),  
    maxIterationsWithoutImprovementStoppingCriterion(1));*/
  return gradientDescentInferenceOnlineLearner(
    InferenceOnlineLearner::never,                                                 // randomization
    InferenceOnlineLearner::perStep, invLinearIterationFunction(initialLearningRate, 10000), true, // learning steps
    InferenceOnlineLearner::perStepMiniBatch20, sumOfSquaresFunction(0.0),         // regularizer
    InferenceOnlineLearner::perPass, stoppingCriterion, true);                     // stopping criterion
}

InferencePtr createBinaryClassifier(const String& name = T("Unnamed"))
  {return binaryLinearSVMInference(createOnlineLearner(), name);}

InferencePtr createMultiClassClassifier(FeatureDictionaryPtr dictionary)
{
  InferencePtr binaryClassifier = createBinaryClassifier();
  return oneAgainstAllClassificationInference(T("MultiClass"), dictionary, binaryClassifier);
}

InferencePtr createLeastSquaresRegressor(const String& name = T("Unnamed"))
  {return squareRegressionInference(createOnlineLearner(0.1), name);}

InferencePtr createDihedralRegressor(const String& name = T("Unnamed"))
  {return dihedralAngleRegressionInference(createOnlineLearner(0.1), name);}


int main(int argc, char** argv)
{
  declareProteinClasses();
  
  File workingDirectory(T("C:\\Projets\\LBC++\\projects\\temp"));
  //File workingDirectory(T("/Users/francis/tmp"));

  File smallPDBDirectory = workingDirectory.getChildFile(T("SmallPDB"));
  //File smallPDBDirectory(T("/Users/francis/tmp/SmallPDB"));
  
//  ObjectContainerPtr smallPDBProteins = loadProteins(smallPDBDirectory.getChildFile(T("protein")), 7);
//  smallPDBProteins = smallPDBProteins->apply(new ProteinToInputOutputPairFunction());
  
  ObjectContainerPtr smallPDBProteins = directoriesObjectPairStream(
        smallPDBDirectory.getChildFile(T("smallProteinWithSS3DR")),
        smallPDBDirectory.getChildFile(T("protein")))->load();


  ObjectContainerPtr trainingData = smallPDBProteins->size() >= 7 ? smallPDBProteins->invFold(0,7) : smallPDBProteins;
  ObjectContainerPtr testingData = smallPDBProteins->size() >= 7 ? smallPDBProteins->fold(0,7) : smallPDBProteins;

  std::cout << trainingData->size() << " Training Proteins "
            << testingData->size() << " Testing Proteins" << std::endl;

  CompositeProteinResidueFeaturesPtr featureFunction = new CompositeProteinResidueFeatures();

  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("AminoAcidSequence"), 8, 8, true));
  //featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("PositionSpecificScoringMatrix"), 5, 5, true));
  //featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("SecondaryStructureSequence"), 5, 5, true));
  //featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("DisorderProbabilitySequence"), 5, 5, true));
  /*featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("DSSPSecondaryStructureSequence"), 5, 5, true));
  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("SolventAccessibilityThreshold20"), 5, 5, true));
  */
  //featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("BackboneBondSequence"), 5, 5, true));


  CompositeProteinResiduePairFeaturesPtr pairFeatureFunction = new CompositeProteinResiduePairFeatures();
  pairFeatureFunction->addSubFeatures(proteinUnitResiduePairFeature());
  pairFeatureFunction->addSubFeatures(conjunctionResiduePairFeatures(aaResiduePairConjunction, proteinUnitResiduePairFeature()));
  //pairFeatureFunction->addSubFeatures(conjunctionResiduePairFeatures(aaResiduePairConjunction, separationLengthResiduePairFeatures(5)));
  pairFeatureFunction->addSubFeatures(conjunctionResiduePairFeatures(aaResiduePairConjunction, proteinPointResiduePairFeatures(featureFunction)));
  //pairFeatureFunction->addSubFeatures(proteinCentralCompositionResiduePairFeatures(T("PositionSpecificScoringMatrix")));
  //pairFeatureFunction->addSubFeatures(separationLengthResiduePairFeatures(1));
//  pairFeatureFunction->addSubFeatures(conjunctionResiduePairFeatures(aaResiduePairConjunction, separationLengthResiduePairFeatures(2)));

  ProteinInferencePtr proteinInference = new ProteinInference();
//  proteinInference->setPDBDebugDirectory(File(T("C:\\Projets\\LBC++\\projects\\temp\\pdbs")));
  for (size_t i = 0; i < 1; ++i)
  {
    if (false)
    {
      proteinInference->appendInference(
        new ProteinBackboneBondSequenceInferenceStep(T("BBB Pass ") + lbcpp::toString(i), featureFunction,
                createLeastSquaresRegressor(), createLeastSquaresRegressor(), createDihedralRegressor()));
    }

    if (false)
    {
      proteinInference->appendInference(
        new ProteinSequenceLabelingInferenceStep(T("SS3 Pass ") + lbcpp::toString(i),
                               createMultiClassClassifier(SecondaryStructureDictionary::getInstance()),
                               featureFunction, T("SecondaryStructureSequence")));
    }

    if (false)
    {
      proteinInference->appendInference(
        new ProteinSequenceLabelingInferenceStep(T("DR Pass ") + lbcpp::toString(i),
                             binaryLabelToProbabilityInference(T("DR-prob"), createBinaryClassifier(T("DR"))),
                             featureFunction,
                             T("DisorderProbabilitySequence"), T("DisorderSequence")));
    }

    if (true)
    {
      proteinInference->appendInference(
        new ProteinContactMapInference(T("CM Pass ") + lbcpp::toString(i),
                            binaryLabelToProbabilityInference(T("CM-prob"), createBinaryClassifier(T("CM"))),
                            pairFeatureFunction,
                            T("ResidueResidueContactMatrix8Ca")));
    }
  }

  InferenceContextPtr learningContext = singleThreadedInferenceContext();
  learningContext->appendCallback(new MyInferenceCallback(proteinInference, trainingData, testingData));

  InferenceBatchLearnerPtr learner;
  // Exemple 1) Pour tout apprendre en global:
  // learner = simulationInferenceBatchLearner();

  // Exemple 2) Pour tout appendre en step by step:
  learner = sharedSequentialInferenceBatchLearner(simulationInferenceBatchLearner());

  // Exemple 3) Pour n'apprendre que le deuxieme step:
  //             stepLearners[0] reste vide (on suppose que le premier step ‡ dÈja ÈtÈ appris)
  //std::vector<InferenceBatchLearnerPtr> stepLearners(2);
  //stepLearners[1] = simulationInferenceBatchLearner();
  //learner = vectorSequentialInferenceBatchLearner(stepLearners);
  
  learningContext->train(learner, proteinInference, trainingData);
  proteinInference->saveToFile(workingDirectory.getChildFile(T("Models//NewStyle.inference")));
  return 0;
}
