/*-----------------------------------------.---------------------------------.
| Filename: TestLearning.cpp               | Test Learning                   |
| Author  : Francis Maes                   |                                 |
| Started : 28/03/2010 12:31               |                                 |
`------------------------------------------/                                 |
                               |                                             |
                               `--------------------------------------------*/

#include <lbcpp/lbcpp.h>
#include "GeneratedCode/Data/Bio/Protein.lh"
#include "VariableSetModel.h"
using namespace lbcpp;

extern void declareProteinsClasses();
extern void declareVariableSetClasses();

class SecondaryStructureVariableSetExample : public VariableSetExample
{
public:
  SecondaryStructureVariableSetExample(ProteinPtr protein)
    : aminoAcidSequence(protein->getAminoAcidSequence()),
      positionSpecificScores(protein->getPositionSpecificScoringMatrix()),
      secondaryStructure(protein->getSecondaryStructureSequence(false))
    {}
  
  virtual VariableSetPtr getTargetVariables() const
    {return secondaryStructure;}

  virtual VariableSetPtr createInitialPrediction() const
  {
    LabelSequencePtr res = new SecondaryStructureSequence(false);
    res->setLength(secondaryStructure->getLength());
    return res;
  }

  static featureGenerator numberLogFeatures(double positiveNumber, double weight)
  {
    static const double clog2 = log10(2.0);
    static const double clog5 = log10(5.0);
    double l = log10(positiveNumber);
    double fl = floor(l);

    static const double minLog10 = -4.0;
    if (fl < minLog10)
      featureSense (0, weight); // very small number
    else
    {
      double frac = l - fl;
      double base = pow(10.0, fl);
      int fracCase;
      double valMin, valMax;
      if (frac < clog2)
        fracCase = 0, valMin = 0.0, valMax = clog2;
      else if (frac < clog5)
        fracCase = 1, valMin = clog2, valMax = clog5;
      else
        fracCase = 2, valMin = clog5, valMax = 1.0;

      int featureNumber = 1 + (int)(fl - minLog10) * fracCase;
      jassert(featureNumber > 0);
      featureSense ((size_t)featureNumber, (frac - valMin) / (valMax - valMin) * weight);
    }
  }

  static featureGenerator numberFeatures(double value, double weight)
  {
    if (value > 0)
      featureCall("positive") inline numberLogFeatures(value, weight);
    else if (value < 0)
      featureCall("negative") inline numberLogFeatures(-value, weight);
    else
      featureSense("nullValue", weight);
  }

  static featureGenerator percentFeatures(double percent, double weight)
  {
    jassert(percent >= 0.0 && percent <= 1.0);
    enum {valueCount = 10};
    double p = percent * valueCount;
    featureSense((size_t)p, (p - (int)p) * weight);
  }

  featureGenerator posAndLengthFeatures(size_t variableIndex, double weight) const
  {
    double length = (double)aminoAcidSequence->getNumVariables();
    featureCall("length") inline numberFeatures(length, weight);
    featureCall("position") inline numberFeatures((double)variableIndex / length, weight);
  }

  virtual featureGenerator getVariableFeatures(size_t variableIndex, VariableSetPtr prediction) const
  {
    featureCall inline posAndLengthFeatures(variableIndex, 1.0);

    // conjunctions with current amino acid
    featureCall(T("A") + String((int)aminoAcidSequence->getLabel(variableIndex))) inline posAndLengthFeatures(variableIndex, 1.0);

    /* conjunctions with current pssm entries
    size_t n = positionSpecificScores->getNumScores();
    for (size_t i = 0; i < n; ++i)
    {
      double score = positionSpecificScores->getScore(variableIndex, i);
      if (score)
        featureCall(T("SS") + String((int)i)) inline posAndLengthFeatures(variableIndex, score);
    }*/
    
    featureCall("a") inline aminoAcidSequence->windowFeatures(variableIndex, 7, 7, true);
    
    // conjunctions of AA of variable sizes, centred around the current position
    /*for (size_t i = 1; i < 4; ++i)
    {
      int p1 = (int)variableIndex - (int)i;
      int p2 = (int)variableIndex + (int)i;
      String featureName;
      for (int j = p1; j <= p2; ++j)
      {
        if (j < 0 || j >= (int)aminoAcidSequence->getLength())
          featureName += "_";
        else
          featureName += String(aminoAcidSequence->getLabel(j));
      }
      featureSense(featureName);
    }*/

    featureCall("p") inline positionSpecificScores->windowFeatures(variableIndex, 7, 7, true);
    if (prediction)
    {
      LabelSequencePtr predictedSecondaryStructure = prediction.dynamicCast<LabelSequence>();
      jassert(predictedSecondaryStructure);
      featureCall("pr") inline predictedSecondaryStructure->windowFeatures(variableIndex, 7, 7, false);
    }
  }
    
private:
  LabelSequencePtr aminoAcidSequence;
  ScoreVectorSequencePtr positionSpecificScores;
  LabelSequencePtr secondaryStructure;
};

class ProteinToVariableSetExample : public ObjectFunction
{
public:
  virtual String getOutputClassName(const String& inputClassName) const
    {return T("VariableSetExample");}

  virtual ObjectPtr function(ObjectPtr object) const
  {
    ProteinPtr protein = object.dynamicCast<Protein>();
    jassert(protein);
    return new SecondaryStructureVariableSetExample(protein);
  }
};

StoppingCriterionPtr createLearningStoppingCriterion(size_t nbIteration)
{
  return maxIterationsStoppingCriterion(nbIteration);
}

using juce::Time;

class TestTrainingProgressCallback : public TrainingProgressCallback
{
public:
  TestTrainingProgressCallback(StoppingCriterionPtr stoppingCriterion, ObjectContainerPtr validationData)
    : trainAccuracy(0.0), testAccuracy(0.0), stoppingCriterion(stoppingCriterion), validationData(validationData) {}
  
  double trainAccuracy;
  double testAccuracy;
  int iterationNumber;
  double startTime;
  
  virtual void progressStart(const String& description)
  {
    startTime = Time::getMillisecondCounter() / 1000.0;
    iterationNumber = 0;
    std::cout << description << std::endl;
    stoppingCriterion->reset();
  }
  
  virtual bool trainingProgressStep(LearningMachinePtr m, ObjectContainerPtr trainingData)
  {
    VariableSetModelPtr model = m.dynamicCast<VariableSetModel>();
    jassert(model);
    
    std::cout << std::endl << "Iteration " << iterationNumber << ", Time: " << (Time::getMillisecondCounter() / 1000.0 - startTime) << std::endl;

    std::cout << "Evaluating on training data..." << std::flush;
    trainAccuracy = model->evaluate(trainingData);
    std::cout << " => " << trainAccuracy << std::endl;

    std::cout << "Evaluating on testing data..." << std::flush;
    testAccuracy = model->evaluate(validationData);
    std::cout << " => " << testAccuracy << std::endl;
    
    double time = Time::getMillisecondCounter() / 1000.0;
    ++iterationNumber;
    
    return !stoppingCriterion->shouldOptimizerStop(trainAccuracy);
  }

  virtual void progressEnd()
    {std::cout << "Training finished." << std::endl;}
    
private:
  StoppingCriterionPtr stoppingCriterion;
  ObjectContainerPtr validationData;
};

GradientBasedClassifierPtr createMaxentClassifier(StringDictionaryPtr labels, double regularizer = 0.0001)
{
  IterationFunctionPtr learningRate = invLinearIterationFunction(2.0, 150000);
  GradientBasedLearnerPtr learner = stochasticDescentLearner(learningRate);  
  GradientBasedClassifierPtr classifier = maximumEntropyClassifier(learner, labels);
  classifier->setL2Regularizer(regularizer);
  return classifier;
}

int main(int argc, char** argv)
{
  File proteinsDirectory(T("C:\\Projets\\Proteins\\data\\CB513cool"));

  declareProteinsClasses();
  declareVariableSetClasses();

  ObjectStreamPtr proteinsStream = directoryObjectStream(proteinsDirectory, T("*.protein"));
  ObjectStreamPtr examplesStream = proteinsStream->apply(new ProteinToVariableSetExample());
  ObjectContainerPtr examples = examplesStream->load(21)->randomize();
  StringDictionaryPtr labels = examples->getAndCast<VariableSetExample>(0)->getTargetVariables()->getVariablesDictionary();

  VariableSetModelPtr model = independantClassificationVariableSetModel(createMaxentClassifier(labels));
  ObjectContainerPtr trainingData = examples->invFold(0, 7);
  ObjectContainerPtr testingData = examples->fold(0, 7);

  ReferenceCountedObjectPtr<TestTrainingProgressCallback> callback
    = new TestTrainingProgressCallback(createLearningStoppingCriterion(1), testingData);
  model->trainBatch(trainingData, callback);
  
  std::cout << "Train Accuracy = " << callback->trainAccuracy << std::endl;
  std::cout << "Test Accuracy = " << callback->testAccuracy << std::endl;
  File modelFile(T("C:\\Projets\\Proteins\\data\\models\\CB513_fold0_co.model"));
  model->saveToFile(modelFile);

  std::cout << model->toString() << std::endl;
  std::cout << "======================" << std::endl;

  VariableSetModelPtr model2 = Object::loadFromFileAndCast<VariableSetModel>(modelFile);
  std::cout << model2->toString() << std::endl;
  std::cout << "Train Accuracy = " << std::flush << model2->evaluate(trainingData) << std::endl;
  std::cout << "Test Accuracy = " << std::flush << model2->evaluate(testingData) << std::endl;
   
  return 0;
}
