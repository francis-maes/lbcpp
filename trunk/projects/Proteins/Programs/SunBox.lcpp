/*
 *  SunBox.lcpp
 *  LBCpp
 *
 *  Created by Becker Julien on 27/05/10.
 *  Copyright 2010 University of Li√®ge. All rights reserved.
 *
 */

#include <lbcpp/lbcpp.h>

#include "Programs/ArgumentSet.h"

#include "Protein/Protein.h"
#include "Protein/SecondaryStructureDictionary.h"

#include "Protein/Inference/ProteinBackboneBondSequenceInference.h"
#include "Protein/Inference/ProteinInference.h"
#include "Protein/Inference/Protein1DTargetInference.h"

#include "Protein/Evaluation/ProteinEvaluationCallback.h"

using namespace lbcpp;

extern void declareProteinClasses();

// Compute train and test score at given depth and defined public access methods to those scores.
// Avoid the need to compute scores more than once.
// Be sure to add this callback as the last callback (this assumption ensure that EvaluationInferenceCallback will be
// called *before* your callbacks ... ) 
class EvaluationInferenceCallback : public InferenceCallback
{
public:
  EvaluationInferenceCallback(InferencePtr inference, ObjectContainerPtr trainingData, ObjectContainerPtr testingData)
    : inference(inference)
    , trainingData(trainingData), testingData(testingData)
    , trainingEvaluation(new ProteinEvaluationCallback()), testingEvaluation(new ProteinEvaluationCallback) {}

  virtual void preInferenceCallback(InferenceStackPtr stack, ObjectPtr& input, ObjectPtr& supervision, ObjectPtr& output, ReturnCode& returnCode)
  {
//    std::cout << "Depth: " << stack->getDepth() << std::endl;
//    std::cout << "Current Inference ClassName: " << stack->getCurrentInference()->getClassName() << std::endl;
  }
    
  virtual void postInferenceCallback(InferenceStackPtr stack, ObjectPtr input, ObjectPtr supervision, ObjectPtr& output, ReturnCode& returnCode)
  {
    typedef ReferenceCountedObjectPtr<ProteinTargetInferenceHelper> ProteinTargetInferenceHelperPtr;
    ProteinTargetInferenceHelperPtr helper = stack->getCurrentInference().dynamicCast<ProteinTargetInferenceHelper>();
    
    if (helper)
    {
      target = helper->getTargetName();
    }
    
    if (stack->getCurrentInference()->getClassName() != T("RunOnSupervisedExamplesInference"))
      return;

    jassert(target != String::empty);
    InferenceContextPtr validationContext = singleThreadedInferenceContext();

    validationContext->appendCallback(trainingEvaluation);
    validationContext->runInference(runOnSupervisedExamplesInference(inference), trainingData, ObjectPtr(), returnCode);
    validationContext->removeCallback(trainingEvaluation);

    validationContext->appendCallback(testingEvaluation);
    validationContext->runInference(runOnSupervisedExamplesInference(inference), testingData, ObjectPtr(), returnCode);
  }
  
  String getTarget() const
    {return target;}
  
  double getTrainingScore() const
    {jassert(target != String::empty); return trainingEvaluation->getDefaultScoreForTarget(target);}
  
  double getTestingScore() const
    {jassert(target != String::empty); return testingEvaluation->getDefaultScoreForTarget(target);}
  
  double getTrainingScoreForTarget(const String& target) const
    {return trainingEvaluation->getDefaultScoreForTarget(target);}

  double getTestingScoreForTarget(const String& target) const
    {return testingEvaluation->getDefaultScoreForTarget(target);}

  String getTrainingScoreToString() const
    {return trainingEvaluation->toString();}
  
  String getTestingScoreToString() const
    {return testingEvaluation->toString();}

private:
  InferencePtr inference;
  String target;

  ObjectContainerPtr trainingData;
  ObjectContainerPtr testingData;

  ProteinEvaluationCallbackPtr trainingEvaluation;
  ProteinEvaluationCallbackPtr testingEvaluation;
};

typedef ReferenceCountedObjectPtr<EvaluationInferenceCallback> EvaluationInferenceCallbackPtr;

class StandardOutputInferenceCallback : public InferenceCallback
{
public:
  StandardOutputInferenceCallback(EvaluationInferenceCallbackPtr evaluation)
    : evaluation(evaluation), iterationNumber(0), startingTime(Time::getMillisecondCounter()) {}
  
  virtual void preInferenceCallback(InferenceStackPtr stack, ObjectPtr& input, ObjectPtr& supervision, ObjectPtr& output, ReturnCode& returnCode)
  {
    if (stack->getDepth() == 2)
    {
      InferencePtr learnedInference = input.dynamicCast<Inference>();
      if (learnedInference)
      {
        String inferenceName = learnedInference->getName();
        std::cout << std::endl << "=====================================================" << std::endl;
        std::cout << "======= LEARNING PASS " << inferenceName << " ========== " << (Time::getMillisecondCounter() - startingTime) / 1000 << " s" << std::endl;
        std::cout << "=====================================================" << std::endl;
      }
      iterationNumber = 0;
    }
    else if (stack->getCurrentInference()->getClassName() == T("RunOnSupervisedExamplesInference"))
    {
      std::cout << std::endl
                << " ================== ITERATION " << ++iterationNumber << " ================== " << (Time::getMillisecondCounter() - startingTime) / 1000.0 << " s" <<  std::endl;
    }
  }
  
  virtual void postInferenceCallback(InferenceStackPtr stack, ObjectPtr input, ObjectPtr supervision, ObjectPtr& output, ReturnCode& returnCode)
  {
    if (stack->getCurrentInference()->getClassName() == T("RunOnSupervisedExamplesInference"))
    {
      std::cout << "Train: " << evaluation->getTrainingScoreToString() << std::endl;
      std::cout << "Test: " << evaluation->getTestingScoreToString() << std::endl;
    }
    else if (stack->getDepth() == 1)
    {
      std::cout << "Bye." << std::endl;
    }
  }

private:
  EvaluationInferenceCallbackPtr evaluation;
  size_t iterationNumber;
  juce::uint32 startingTime;
};

class GlobalGnuPlotInferenceCallback : public InferenceCallback
{
public:
  GlobalGnuPlotInferenceCallback(EvaluationInferenceCallbackPtr evaluation, const String& prefix)
    : evaluation(evaluation), prefix(prefix)
    , startingTime(Time::getMillisecondCounter())
    , bestTraininScore(-DBL_MAX), bestTestingScore(-DBL_MAX) {}
  
  virtual ~GlobalGnuPlotInferenceCallback()
  {
    for (std::map< String, OutputStream* >::const_iterator iter = oStream.begin(); iter != oStream.end(); iter++)
      delete iter->second;
  }

  virtual void preInferenceCallback(InferenceStackPtr stack, ObjectPtr& input, ObjectPtr& supervision, ObjectPtr& output, ReturnCode& returnCode)
  {
    if (stack->getDepth() == 2)
    {
      bestTraininScore = -DBL_MAX;
      bestTestingScore = -DBL_MAX;
    }
  }
  
  virtual void postInferenceCallback(InferenceStackPtr stack, ObjectPtr input, ObjectPtr supervision, ObjectPtr& output, ReturnCode& returnCode)
  {
    if (stack->getCurrentInference()->getClassName() == T("SimulationInferenceBatchLearner"))
    {
      const String target = evaluation->getTarget();
      jassert(target != String::empty);
      if (!oStream.count(target))
      {
        File dst = File::getCurrentWorkingDirectory().getChildFile(prefix + T("..") + target);
        dst.deleteFile();
        oStream[target] = dst.createOutputStream();
        passes[target] = 0;
      }
      
      *oStream[target] << (int) passes[target] << '\t'
      << bestTraininScore << '\t'
      << bestTestingScore << '\t'
      << (juce::Time::getMillisecondCounter() - startingTime) / 1000. << '\n';
      oStream[target]->flush();

      ++passes[target];
    } 
    else if (stack->getCurrentInference()->getClassName() == T("RunOnSupervisedExamplesInference"))
    {
      if (evaluation->getTrainingScore() >= bestTraininScore)
      {
        bestTraininScore = evaluation->getTrainingScore();
        bestTestingScore = evaluation->getTestingScore();
      }
    }
  }

private:
  EvaluationInferenceCallbackPtr evaluation;
  const String prefix;
  juce::uint32 startingTime;
  
  std::map< String, OutputStream* > oStream;
  std::map< String, size_t > passes;

  double bestTraininScore;
  double bestTestingScore;
};

class GnuPlotInferenceCallback : public InferenceCallback
{
public:
  GnuPlotInferenceCallback(EvaluationInferenceCallbackPtr evaluation, const String& prefix, const String& target, const String& relatedTarget = String::empty)
  : evaluation(evaluation)
  , prefix(prefix), target(target), relatedTarget(relatedTarget.isEmpty() ? target : relatedTarget)
  , startingTime(Time::getMillisecondCounter())
  , oStream(NULL), passes(0) 
  , bestTrainingScore(-DBL_MAX), bestTestingScore(-DBL_MAX) {}

  virtual ~GnuPlotInferenceCallback()
    {delete oStream;}

  virtual void preInferenceCallback(InferenceStackPtr stack, ObjectPtr& input, ObjectPtr& supervision, ObjectPtr& output, ReturnCode& returnCode)
  {
    if (stack->getDepth() == 2)
    {
      bestTrainingScore = -DBL_MAX;
      bestTestingScore = -DBL_MAX;
    }
  }
  
  virtual void postInferenceCallback(InferenceStackPtr stack, ObjectPtr input, ObjectPtr supervision, ObjectPtr& output, ReturnCode& returnCode)
  {
    if (stack->getCurrentInference()->getClassName() == T("SimulationInferenceBatchLearner") && evaluation->getTarget() == relatedTarget)
    {
      if (!oStream)
      {
        File dst = File::getCurrentWorkingDirectory().getChildFile(prefix + T(".") + relatedTarget + T(".") + target);
        dst.deleteFile();
        oStream = dst.createOutputStream();
        passes = 0;
      }
      
      *oStream << (int) passes << '\t'
      << bestTrainingScore << '\t'
      << bestTestingScore << '\t'
      << (juce::Time::getMillisecondCounter() - startingTime) / 1000. << '\n';
      oStream->flush();

      ++passes;
    } 
    else if (stack->getCurrentInference()->getClassName() == T("RunOnSupervisedExamplesInference"))
    {
      if (evaluation->getTrainingScoreForTarget(target) >= bestTrainingScore)
      {
        bestTrainingScore = evaluation->getTrainingScoreForTarget(target);
        bestTestingScore = evaluation->getTestingScoreForTarget(target);
      }
    }
    
  }

private:
  EvaluationInferenceCallbackPtr evaluation;
  const String prefix;
  const String target;
  const String relatedTarget;
  juce::uint32 startingTime;
  OutputStream* oStream;
  size_t passes;
  double bestTrainingScore;
  double bestTestingScore;
};

static int stoppingIteration = 20;
static double regularizer = 0.0;

InferenceOnlineLearnerPtr createOnlineLearner(double learningRate, size_t learningStep)
{
  StoppingCriterionPtr stoppingCriterion = logicalOr(
    maxIterationsStoppingCriterion(stoppingIteration),
    maxIterationsWithoutImprovementStoppingCriterion(3));
  return gradientDescentInferenceOnlineLearner(
    InferenceOnlineLearner::never,                                                 // randomization
    InferenceOnlineLearner::perStep, invLinearIterationFunction(learningRate, learningStep), true, // learning steps
    InferenceOnlineLearner::perStepMiniBatch20, sumOfSquaresFunction(regularizer),         // regularizer
    InferenceOnlineLearner::perPass, stoppingCriterion, true);                     // stopping criterion
}

InferencePtr createMultiClassClassifier(FeatureDictionaryPtr dictionary, double learningRate, size_t learningStep)
{
  InferencePtr binaryClassifier = binaryLinearSVMInference(createOnlineLearner(learningRate, learningStep));
  return oneAgainstAllClassificationInference(T("MultiClass"), dictionary, binaryClassifier);
}

InferencePtr createLeastSquaresRegressor(double learningRate, size_t learningStep, const String& name = T("Unnamed"))
  {return squareRegressionInference(createOnlineLearner(learningRate, learningStep), name);}

InferencePtr createDihedralRegressor(double learningRate, size_t learningStep, const String& name = T("Unnamed"))
  {return dihedralAngleRegressionInference(createOnlineLearner(learningRate, learningStep), name);}

int main(int argc, char** argv)
{
  declareProteinClasses();
  
  enum {numFolds = 5};

  File proteinsDirectory(T("/Users/jbecker/Documents/Workspace/CASP9/SmallPDB/test_version"));
  
  File testingProteinsDirectory;
  int numProteinsToLoad = 0;
  std::vector<String> targets;
  String output(T("result"));
  File inputInference;
  bool saveInference = false;
  bool isTestVersion = false;
  String multiTaskFeatures;
  
  ArgumentSet arguments;
  arguments.insert(new FileArgument(T("ProteinsDirectory"), proteinsDirectory, true, true));
  arguments.insert(new IntegerArgument(T("NumProteinsToLoad"), numProteinsToLoad));
  arguments.insert(new FileArgument(T("TestingProteinsDirectory"), testingProteinsDirectory, true, true));
  arguments.insert(new TargetExpressionArgument(T("Targets"), targets), true);
  arguments.insert(new StringArgument(T("Output"), output));
  //arguments.insert(new DoubleArgument(T("LearningRate"), defaultLearningRate));
  //arguments.insert(new IntegerArgument(T("LearningStep"), defaultLearningStep));
  arguments.insert(new DoubleArgument(T("Regularizer"), regularizer));
  arguments.insert(new BooleanArgument(T("SaveInference"), saveInference));
  arguments.insert(new FileArgument(T("InputInference"), inputInference, true, true));
  arguments.insert(new BooleanArgument(T("IsTestVersion"), isTestVersion));
  arguments.insert(new StringArgument(T("MultiTaskFeatures"), multiTaskFeatures));
  
  
  if (!arguments.parse(argv, 1, argc-1))
  {
    std::cout << "Usage: " << argv[0] << " " << arguments.toString() << std::endl;
    return -1;
  }
  
  if (isTestVersion)
  {
    if (!numProteinsToLoad)
      numProteinsToLoad = numFolds;
    stoppingIteration = 2;
  }
  
  std::cout << "*---- Program Parameters -----" << std::endl;
  std::cout << arguments;
  std::cout << "*-----------------------------" << std::endl;

  // TODO Allows use of already learned proteins
  // TODO Randomize *before* loading
  ObjectContainerPtr trainingData = directoryObjectStream(proteinsDirectory, T("*.protein"))
    ->load(numProteinsToLoad)
    ->randomize()
    ->apply(new ProteinToInputOutputPairFunction());

  ObjectContainerPtr trainingDataPair = directoryObjectStream(proteinsDirectory, T("*.proteinPair"))
    ->load(numProteinsToLoad - trainingData->size())
    ->randomize()
    ->apply(new ComputeMissingFieldsOfProteinPairFunction());

  trainingData = append(trainingData, trainingDataPair);
  
/*  for (size_t i = 0; i < trainingData->size(); ++i)
    trainingData->get(i)->saveToFile(proteinsDirectory.getChildFile(trainingData->get(i)->getName() + T(".proteinPair")));
*/
  ObjectContainerPtr testingData;
  if (testingProteinsDirectory == File::nonexistent)
  {
    testingData = trainingData->fold(0, numFolds);
    trainingData = trainingData->invFold(0, numFolds);
  }
  else
  {
    testingData = directoryObjectStream(testingProteinsDirectory, T("*.protein"))
      ->load()
      ->apply(new ProteinToInputOutputPairFunction());
    
    ObjectContainerPtr testingDataPair = directoryObjectStream(testingProteinsDirectory, T("*.proteinPair"))
      ->load()
      ->apply(new ComputeMissingFieldsOfProteinPairFunction());
    
    testingData = append(testingData, testingDataPair);
  }

  std::cout << trainingData->size() << " Training Proteins & "
            << testingData->size()  << " Testing Proteins" << std::endl;

  /*
  ** Creation of features function
  */
  CompositeProteinResidueFeaturesPtr featureFunction = new CompositeProteinResidueFeatures();
/*  
  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("AminoAcidSequence"), 5, 5, true));
  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("PositionSpecificScoringMatrix"), 5, 5, true));
  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("SecondaryStructureSequence"), 5, 5, true));
*/
//  featureFunction->addSubFeatures(proteinUnitResidueFeature());
  
//  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("AminoAcidSequence"), 9, 9, true));
//  featureFunction->addSubFeatures(proteinFrequencyWindowFeatures(T("AminoAcidSequence"), 50, true));
  //featureFunction->addSubFeatures(proteinSequenceEntropyFeatures(T("AminoAcidSequence"), 10));
  
//  featureFunction->addSubFeatures(proteinPositionFeatures());
  
//  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("ReducedAminoAcidAlphabetSequence"), 9, 9, true));
//  featureFunction->addSubFeatures(proteinFrequencyWindowFeatures(T("ReducedAminoAcidAlphabetSequence"), 50, true));

  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("StructuralAlphabetSequence"), 20, 20, true));
//  featureFunction->addSubFeatures(proteinFrequencyWindowFeatures(T("StructuralAlphabetSequence"), 80, true));

//  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("PositionSpecificScoringMatrix"), 11, 11, true));
//  featureFunction->addSubFeatures(proteinFrequencyWindowFeatures(T("PositionSpecificScoringMatrix"), 150, true));
//  //featureFunction->addSubFeatures(proteinSequenceEntropyFeatures(T("PositionSpecificScoringMatrix"), 10));
//
//  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("SecondaryStructureSequence"), 10, 10, true));
//  featureFunction->addSubFeatures(proteinFrequencyWindowFeatures(T("SecondaryStructureSequence"), 100, true));
//  //featureFunction->addSubFeatures(proteinSequenceEntropyFeatures(T("SecondaryStructureSequence"), 10));
//
//
//  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("DSSPSecondaryStructureSequence"), 10, 10, true));
//  //featureFunction->addSubFeatures(proteinSequenceEntropyFeatures(T("DSSPSecondaryStructureSequence"), 10));
//
//  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("SolventAccessibilityThreshold20"), 10, 10, true));
//  //featureFunction->addSubFeatures(proteinSequenceEntropyFeatures(T("SolventAccessibilityThreshold20"), 10));
// 
//  //featureFunction->addSubFeatures(proteinFrequencyWindowFeatures(T("AminoAcidProperty"), 0, true));
//  
//  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("DisorderProbabilitySequence"), 5, 5, true));
//  
//  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("BackboneBondSequence"), 5, 5, true));
//
////  featureFunction->addSubFeatures(multiSequenceConjunctionFeatures(multiTaskFeatures));
//
//  //featureFunction->addSubFeatures(proteinSegmentConjunctionFeatures(T("SecondaryStructureSequence"), 2));
  //featureFunction->addSubFeatures(proteinGlobalToResidueFeatures(proteinLengthFeatures()));

  /*
  ** Creation of the inference
  */
  ProteinInferencePtr proteinInference = new ProteinInference();
  Protein1DTargetInferencePtr step;

  for (size_t i = 0; i < targets.size(); ++i)
  {
    if (targets[i].contains(T("SS3")))
    {
      step = new ProteinSequenceLabelingInferenceStep(T("SS3_Pass_") + lbcpp::toString(i)
          , createMultiClassClassifier(SecondaryStructureDictionary::getInstance(), 0.5, 5000)
          , featureFunction, T("SecondaryStructureSequence"));
      proteinInference->appendInference(step);
    }

    if (targets[i].contains(T("SS8")))
    {
      step = new ProteinSequenceLabelingInferenceStep(T("SS8_Pass_") + lbcpp::toString(i)
          , createMultiClassClassifier(DSSPSecondaryStructureDictionary::getInstance(), 0.5, 5000)
          , featureFunction, T("DSSPSecondaryStructureSequence"));
      proteinInference->appendInference(step);
    }
    
    if (targets[i].contains(T("SA")))
    {
      step = new ProteinSequenceLabelingInferenceStep(T("SA_Pass_") + lbcpp::toString(i)
          , binaryLinearSVMInference(createOnlineLearner(1.0, 10000))
          , featureFunction, T("SolventAccessibilityThreshold20"));
      proteinInference->appendInference(step);
    }
    
    if (targets[i].contains(T("DR")))
    {
      step = new ProteinSequenceLabelingInferenceStep(T("DR_Pass_") + lbcpp::toString(i)
          , binaryLabelToProbabilityInference(T("DR-prob"), binaryLinearSVMInference(createOnlineLearner(50.0, 1000000), T("DR")))
          , featureFunction
          , T("DisorderProbabilitySequence")
          , T("DisorderSequence"));
      proteinInference->appendInference(step);
    }
    
    if (targets[i].contains(T("BBB")))
    {
      step = new ProteinBackboneBondSequenceInferenceStep(T("BBB_Pass_") + lbcpp::toString(i)
          , featureFunction
          , createLeastSquaresRegressor(0.1, 1000)
          , createLeastSquaresRegressor(0.1, 1000)
          , createDihedralRegressor(0.1, 1000));
      proteinInference->appendInference(step);
    }
    
    if (targets[i].contains(T("StAl")))
    {
      step = new ProteinSequenceLabelingInferenceStep(T("StAl_Pass_") + lbcpp::toString(i)
          , createMultiClassClassifier(StructuralAlphabetDictionary::getInstance(), 0.03, 1000)
          , featureFunction, T("StructuralAlphabetSequence"));
      proteinInference->appendInference(step);
    }
  }
  
  //InferenceBatchLearnerPtr learner;
  
  if (inputInference != File::nonexistent)
  {
   // std::vector<InferenceBatchLearnerPtr> stepLearners(proteinInference->getNumSubInferences());
    std::cout << "Loading inference ..." << std::endl;

    size_t i = 0;
    // Load existing and contiguous inferences
    for (; i < proteinInference->getNumSubInferences(); ++i)
    {
      File f = proteinInference->getSubInferenceFile(i, inputInference);
      if (!f.exists())
        break;
      InferencePtr inference = Inference::createFromFile(f);
      if (!inference)
        break;
      proteinInference->setSubInference(i, inference);
      std::cout << "Inference " << f.getFileName().quoted() << " loaded !" << std::endl;
    }
    /* set a learner for the reminder inferences
    for (; i < proteinInference->getNumSubInferences(); ++i)
    {
      stepLearners[i] = simulationInferenceLearner();
    }

    learner = vectorSequentialInferenceBatchLearner(stepLearners);*/
  }/* else {
    learner = sharedSequentialInferenceBatchLearner(simulationInferenceLearner());
  }*/

  InferenceContextPtr learningContext = singleThreadedInferenceContext();
  EvaluationInferenceCallbackPtr evaluationCallback = new EvaluationInferenceCallback(proteinInference, trainingData, testingData);

  learningContext->appendCallback(new StandardOutputInferenceCallback(evaluationCallback));
  learningContext->appendCallback(new GlobalGnuPlotInferenceCallback(evaluationCallback, output));
  learningContext->appendCallback(new GnuPlotInferenceCallback(evaluationCallback, output, T("SecondaryStructureSequence"), T("DSSPSecondaryStructureSequence")));
  learningContext->appendCallback(new GnuPlotInferenceCallback(evaluationCallback, output, T("ResidueResidueContactMatrix8Ca"), T("BackboneBondSequence")));
  learningContext->appendCallback(new GnuPlotInferenceCallback(evaluationCallback, output, T("StructuralAlphabetSequence"), T("BackboneBondSequence")));
  learningContext->appendCallback(new GnuPlotInferenceCallback(evaluationCallback, output, T("TertiaryStructure"), T("BackboneBondSequence")));
  learningContext->appendCallback(evaluationCallback); // must be the last callback

  learningContext->train(proteinInference, trainingData);

  if (saveInference)
    proteinInference->saveToFile(File::getCurrentWorkingDirectory().getChildFile(output));

  return 0;
}
