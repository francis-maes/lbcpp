/*
 *  SunBox.lcpp
 *  LBCpp
 *
 *  Created by Becker Julien on 27/05/10.
 *  Copyright 2010 University of Li√®ge. All rights reserved.
 *
 */

#include <lbcpp/lbcpp.h>

#include "Programs/ArgumentSet.h"

#include "Protein/Protein.h"
#include "Protein/SecondaryStructureDictionary.h"

#include "Protein/Inference/ProteinBackboneBondSequenceInferenceStep.h"
#include "Protein/Inference/ProteinInference.h"
#include "Protein/Inference/Protein1DInferenceStep.h"

#include "Protein/Evaluation/ProteinEvaluationCallback.h"

using namespace lbcpp;

extern void declareProteinClasses();

// Compute train and test score at given depth and defined public access methods to those scores.
// Avoid the need to compute scores more than once.
// Be sure to add this callback as the last callback (this assumption ensure that EvaluationInferenceCallback will be
// called *before* your callbacks ... ) 
class EvaluationInferenceCallback : public InferenceCallback
{
public:
  EvaluationInferenceCallback(InferencePtr inference, ObjectContainerPtr trainingData, ObjectContainerPtr testingData)
    : inference(inference)
    , trainingData(trainingData), testingData(testingData)
    , trainingEvaluation(new ProteinEvaluationCallback()), testingEvaluation(new ProteinEvaluationCallback) {}

  virtual void preInferenceCallback(InferenceStackPtr stack, ObjectPtr& input, ObjectPtr& supervision, ObjectPtr& output, ReturnCode& returnCode)
  {
//    std::cout << "Depth: " << stack->getDepth() << std::endl;
//    std::cout << "Current Inference ClassName: " << stack->getCurrentInference()->getClassName() << std::endl;
  }
    
  virtual void postInferenceCallback(InferenceStackPtr stack, ObjectPtr input, ObjectPtr supervision, ObjectPtr& output, ReturnCode& returnCode)
  {
    typedef ReferenceCountedObjectPtr<ProteinInferenceStepHelper> ProteinInferenceStepHelperPtr;
    ProteinInferenceStepHelperPtr helper = stack->getCurrentInference().dynamicCast<ProteinInferenceStepHelper>();
    
    if (helper)
    {
      target = helper->getTargetName();
    }
    
    if (stack->getCurrentInference()->getClassName() != T("RunOnSupervisedExamplesInference"))
      return;

    jassert(target != String::empty);
    InferenceContextPtr validationContext = singleThreadedInferenceContext();

    validationContext->appendCallback(trainingEvaluation);
    validationContext->runWithSupervisedExamples(inference, trainingData);

    validationContext->removeCallback(trainingEvaluation);

    validationContext->appendCallback(testingEvaluation);
    validationContext->runWithSupervisedExamples(inference, testingData);
  }
  
  String getTarget() const
    {return target;}
  
  double getTrainingScore() const
    {jassert(target != String::empty); return trainingEvaluation->getDefaultScoreForTarget(target);}
  
  double getTestingScore() const
    {jassert(target != String::empty); return testingEvaluation->getDefaultScoreForTarget(target);}
  
  double getTrainingScoreForTarget(const String& target) const
    {return trainingEvaluation->getDefaultScoreForTarget(target);}

  double getTestingScoreForTarget(const String& target) const
    {return testingEvaluation->getDefaultScoreForTarget(target);}

  String getTrainingScoreToString() const
    {return trainingEvaluation->toString();}
  
  String getTestingScoreToString() const
    {return testingEvaluation->toString();}

private:
  InferencePtr inference;
  String target;

  ObjectContainerPtr trainingData;
  ObjectContainerPtr testingData;

  ProteinEvaluationCallbackPtr trainingEvaluation;
  ProteinEvaluationCallbackPtr testingEvaluation;
};

typedef ReferenceCountedObjectPtr<EvaluationInferenceCallback> EvaluationInferenceCallbackPtr;

class StandardOutputInferenceCallback : public InferenceCallback
{
public:
  StandardOutputInferenceCallback(EvaluationInferenceCallbackPtr evaluation)
    : evaluation(evaluation), iterationNumber(0), startingTime(Time::getMillisecondCounter()) {}
  
  virtual void preInferenceCallback(InferenceStackPtr stack, ObjectPtr& input, ObjectPtr& supervision, ObjectPtr& output, ReturnCode& returnCode)
  {
    if (stack->getDepth() == 2)
    {
      InferencePtr learnedInference = input.dynamicCast<Inference>();
      if (learnedInference)
      {
        String inferenceName = learnedInference->getName();
        std::cout << std::endl << "=====================================================" << std::endl;
        std::cout << "======= LEARNING PASS " << inferenceName << " ========== " << (Time::getMillisecondCounter() - startingTime) / 1000 << " s" << std::endl;
        std::cout << "=====================================================" << std::endl;
      }
      iterationNumber = 0;
    }
    else if (stack->getCurrentInference()->getClassName() == T("RunOnSupervisedExamplesInference"))
    {
      std::cout << std::endl
                << " ================== ITERATION " << ++iterationNumber << " ================== " << (Time::getMillisecondCounter() - startingTime) / 1000.0 << " s" <<  std::endl;
    }
  }
  
  virtual void postInferenceCallback(InferenceStackPtr stack, ObjectPtr input, ObjectPtr supervision, ObjectPtr& output, ReturnCode& returnCode)
  {
    if (stack->getCurrentInference()->getClassName() == T("RunOnSupervisedExamplesInference"))
    {
      std::cout << "Train: " << evaluation->getTrainingScoreToString() << std::endl;
      std::cout << "Test: " << evaluation->getTestingScoreToString() << std::endl;
    }
    else if (stack->getDepth() == 1)
    {
      std::cout << "Bye." << std::endl;
    }
  }

private:
  EvaluationInferenceCallbackPtr evaluation;
  size_t iterationNumber;
  juce::uint32 startingTime;
};

class GlobalGnuPlotInferenceCallback : public InferenceCallback
{
public:
  GlobalGnuPlotInferenceCallback(EvaluationInferenceCallbackPtr evaluation, const String& prefix)
    : evaluation(evaluation), prefix(prefix)
    , startingTime(Time::getMillisecondCounter())
    , bestTraininScore(-DBL_MAX), bestTestingScore(-DBL_MAX) {}
  
  virtual ~GlobalGnuPlotInferenceCallback()
  {
    for (std::map< String, OutputStream* >::const_iterator iter = oStream.begin(); iter != oStream.end(); iter++)
      delete iter->second;
  }

  virtual void preInferenceCallback(InferenceStackPtr stack, ObjectPtr& input, ObjectPtr& supervision, ObjectPtr& output, ReturnCode& returnCode)
  {
    if (stack->getDepth() == 2)
    {
      bestTraininScore = -DBL_MAX;
      bestTestingScore = -DBL_MAX;
    }
  }
  
  virtual void postInferenceCallback(InferenceStackPtr stack, ObjectPtr input, ObjectPtr supervision, ObjectPtr& output, ReturnCode& returnCode)
  {
    if (stack->getCurrentInference()->getClassName() == T("SimulationInferenceBatchLearner"))
    {
      const String target = evaluation->getTarget();
      jassert(target != String::empty);
      if (!oStream.count(target))
      {
        File dst = File::getCurrentWorkingDirectory().getChildFile(prefix + T(".") + target);
        dst.deleteFile();
        oStream[target] = dst.createOutputStream();
        passes[target] = 0;
      }
      
      *oStream[target] << (int) passes[target] << '\t'
      << bestTraininScore << '\t'
      << bestTestingScore << '\t'
      << (juce::Time::getMillisecondCounter() - startingTime) / 1000. << '\n';
      oStream[target]->flush();

      ++passes[target];
    } 
    else if (stack->getCurrentInference()->getClassName() == T("RunOnSupervisedExamplesInference"))
    {
      if (evaluation->getTrainingScore() >= bestTraininScore)
      {
        bestTraininScore = evaluation->getTrainingScore();
        bestTestingScore = evaluation->getTestingScore();
      }
    }
  }

private:
  EvaluationInferenceCallbackPtr evaluation;
  const String prefix;
  juce::uint32 startingTime;
  
  std::map< String, OutputStream* > oStream;
  std::map< String, size_t > passes;

  double bestTraininScore;
  double bestTestingScore;
};

class GnuPlotInferenceCallback : public InferenceCallback
{
public:
  GnuPlotInferenceCallback(EvaluationInferenceCallbackPtr evaluation, const String& prefix, const String& target, const String& relatedTarget = String::empty)
  : evaluation(evaluation)
  , prefix(prefix), target(target), relatedTarget(relatedTarget.isEmpty() ? target : relatedTarget)
  , startingTime(Time::getMillisecondCounter())
  , oStream(NULL), passes(0) 
  , bestTrainingScore(-DBL_MAX), bestTestingScore(-DBL_MAX) {}

  virtual ~GnuPlotInferenceCallback()
    {delete oStream;}

  virtual void preInferenceCallback(InferenceStackPtr stack, ObjectPtr& input, ObjectPtr& supervision, ObjectPtr& output, ReturnCode& returnCode)
  {
    if (stack->getDepth() == 2)
    {
      bestTrainingScore = -DBL_MAX;
      bestTestingScore = -DBL_MAX;
    }
  }
  
  virtual void postInferenceCallback(InferenceStackPtr stack, ObjectPtr input, ObjectPtr supervision, ObjectPtr& output, ReturnCode& returnCode)
  {
    if (stack->getCurrentInference()->getClassName() == T("SimulationInferenceBatchLearner") && evaluation->getTarget() == relatedTarget)
    {
      if (!oStream)
      {
        File dst = File::getCurrentWorkingDirectory().getChildFile(prefix + T(".") + relatedTarget + T(".") + target);
        dst.deleteFile();
        oStream = dst.createOutputStream();
        passes = 0;
      }
      
      *oStream << (int) passes << '\t'
      << bestTrainingScore << '\t'
      << bestTestingScore << '\t'
      << (juce::Time::getMillisecondCounter() - startingTime) / 1000. << '\n';
      oStream->flush();

      ++passes;
    } 
    else if (stack->getCurrentInference()->getClassName() == T("RunOnSupervisedExamplesInference"))
    {
      if (evaluation->getTrainingScoreForTarget(target) >= bestTrainingScore)
      {
        bestTrainingScore = evaluation->getTrainingScoreForTarget(target);
        bestTestingScore = evaluation->getTestingScoreForTarget(target);
      }
    }
    
  }

private:
  EvaluationInferenceCallbackPtr evaluation;
  const String prefix;
  const String target;
  const String relatedTarget;
  juce::uint32 startingTime;
  OutputStream* oStream;
  size_t passes;
  double bestTrainingScore;
  double bestTestingScore;
};

static double learningRate = 1.0;
static int learningStep = 10000;
static int stoppingIteration = 20;
static double regularizer = 0.0;
InferenceOnlineLearnerPtr createOnlineLearner()
{
  StoppingCriterionPtr stoppingCriterion = logicalOr(
    maxIterationsStoppingCriterion(stoppingIteration),
    maxIterationsWithoutImprovementStoppingCriterion(3));
  return gradientDescentInferenceOnlineLearner(
    InferenceOnlineLearner::never,                                                 // randomization
    InferenceOnlineLearner::perStep, invLinearIterationFunction(learningRate, learningStep), true, // learning steps
    InferenceOnlineLearner::perStepMiniBatch20, sumOfSquaresFunction(regularizer),         // regularizer
    InferenceOnlineLearner::perPass, stoppingCriterion, true);                     // stopping criterion
}

InferencePtr createMultiClassClassifier(FeatureDictionaryPtr dictionary)
{
  InferencePtr binaryClassifier = binaryLinearSVMInference(createOnlineLearner());
  return oneAgainstAllClassificationInference(T("MultiClass"), dictionary, binaryClassifier);
}

InferencePtr createBinaryClassifier(const String& name = T("Unnamed"))
  {return binaryLinearSVMInference(createOnlineLearner(), name);}

InferencePtr createLeastSquaresRegressor(const String& name = T("Unnamed"))
  {return squareRegressionInference(createOnlineLearner(/*0.1*/), name);}

InferencePtr createDihedralRegressor(const String& name = T("Unnamed"))
  {return dihedralAngleRegressionInference(createOnlineLearner(/*0.1*/), name);}

int main(int argc, char** argv)
{
  declareProteinClasses();
  
  enum {numFolds = 7};

  File proteinsDirectory(T("/Users/jbecker/Documents/Workspace/CASP9/SmallPDB/test_version"));
  File testingProteinsDirectory;
  int numProteinsToLoad = 0;
  std::vector<String> targets;
  String output(T("result"));
  File inputInference;
  bool saveInference = false;
  bool isTestVersion = false;
  
  ArgumentSet arguments;
  arguments.insert(new FileArgument(T("ProteinsDirectory"), proteinsDirectory, true, true));
  arguments.insert(new IntegerArgument(T("NumProteinsToLoad"), numProteinsToLoad));
  arguments.insert(new FileArgument(T("TestingProteinsDirectory"), testingProteinsDirectory, true, true));
  arguments.insert(new TargetExpressionArgument(T("Targets"), targets), true);
  arguments.insert(new StringArgument(T("Output"), output));
  arguments.insert(new DoubleArgument(T("LearningRate"), learningRate));
  arguments.insert(new IntegerArgument(T("LearningStep"), learningStep));
  arguments.insert(new BooleanArgument(T("SaveInference"), saveInference));
  arguments.insert(new FileArgument(T("InputInference"), inputInference, true, true));
  arguments.insert(new BooleanArgument(T("IsTestVersion"), isTestVersion));
  
  
  if (!arguments.parse(argv, 1, argc-1))
  {
    std::cout << "Usage: " << argv[0] << " " << arguments.toString() << std::endl;
    return -1;
  }
  
  if (isTestVersion)
  {
    if (!numProteinsToLoad)
      numProteinsToLoad = numFolds;
    stoppingIteration = 2;
  }
  
  std::cout << "*---- Program Parameters -----" << std::endl;
  std::cout << arguments;
  std::cout << "*-----------------------------" << std::endl;

  // TODO Allows use of already learned proteins
  // TODO Randomize *before* loading
  ObjectContainerPtr trainingData = directoryObjectStream(proteinsDirectory, T("*.protein"))
    ->load(numProteinsToLoad)
    ->randomize()
    ->apply(new ProteinToInputOutputPairFunction());

  ObjectContainerPtr testingData;
  if (testingProteinsDirectory == File::nonexistent)
  {
    testingData = trainingData->fold(0, numFolds);
    trainingData = trainingData->invFold(0, numFolds);
  }
  else
  {
    testingData = directoryObjectStream(testingProteinsDirectory, T("*.protein"))
      ->load()
      ->apply(new ProteinToInputOutputPairFunction());
  }

  std::cout << trainingData->size() << " Training Proteins & "
            << testingData->size()  << " Testing Proteins" << std::endl;

  /*
  ** Creation of features function
  */
  CompositeProteinResidueFeaturesPtr featureFunction = new CompositeProteinResidueFeatures();
  
  featureFunction->addSubFeatures(proteinUnitResidueFeature());
  
  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("AminoAcidSequence"), 9, 9, true));
  featureFunction->addSubFeatures(proteinFrequencyWindowFeatures(T("AminoAcidSequence"), 50, true));
  //featureFunction->addSubFeatures(proteinSequenceEntropyFeatures(T("AminoAcidSequence"), 10));
  
  featureFunction->addSubFeatures(proteinPositionFeatures());
  
  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("ReducedAminoAcidAlphabetSequence"), 9, 9, true));
  featureFunction->addSubFeatures(proteinFrequencyWindowFeatures(T("ReducedAminoAcidAlphabetSequence"), 50, true));

  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("StructuralAlphabetSequence"), 20, 20, true));
  featureFunction->addSubFeatures(proteinFrequencyWindowFeatures(T("StructuralAlphabetSequence"), 80, true));

  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("PositionSpecificScoringMatrix"), 11, 11, true));
  featureFunction->addSubFeatures(proteinFrequencyWindowFeatures(T("PositionSpecificScoringMatrix"), 150, true));
  //featureFunction->addSubFeatures(proteinSequenceEntropyFeatures(T("PositionSpecificScoringMatrix"), 10));

  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("SecondaryStructureSequence"), 10, 10, true));
  featureFunction->addSubFeatures(proteinFrequencyWindowFeatures(T("SecondaryStructureSequence"), 100, true));
  //featureFunction->addSubFeatures(proteinSequenceEntropyFeatures(T("SecondaryStructureSequence"), 10));


  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("DSSPSecondaryStructureSequence"), 10, 10, true));
  //featureFunction->addSubFeatures(proteinSequenceEntropyFeatures(T("DSSPSecondaryStructureSequence"), 10));

  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("SolventAccessibilityThreshold20"), 10, 10, true));
  //featureFunction->addSubFeatures(proteinSequenceEntropyFeatures(T("SolventAccessibilityThreshold20"), 10));
 
  //featureFunction->addSubFeatures(proteinFrequencyWindowFeatures(T("AminoAcidProperty"), 0, true));
  
  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("DisorderProbabilitySequence"), 5, 5, true));
  
  featureFunction->addSubFeatures(proteinSequenceWindowFeatures(T("BackboneBondSequence"), 5, 5, true));

  //featureFunction->addSubFeatures(multiSequenceConjunctionFeatures());


  //featureFunction->addSubFeatures(proteinSegmentConjunctionFeatures(T("SecondaryStructureSequence"), 2));
  //featureFunction->addSubFeatures(proteinGlobalToResidueFeatures(proteinLengthFeatures()));

  /*
  ** Creation of the inference
  */
  ProteinInferencePtr proteinInference = new ProteinInference();
  Protein1DInferenceStepPtr step;

  for (size_t i = 0; i < targets.size(); ++i)
  {
    if (targets[i].contains(T("SS3")))
    {
      step = new ProteinSequenceLabelingInferenceStep(T("SS3_Pass_") + lbcpp::toString(i)
          , createMultiClassClassifier(SecondaryStructureDictionary::getInstance())
          , featureFunction, T("SecondaryStructureSequence"));
      proteinInference->appendInference(step);
    }

    if (targets[i].contains(T("SS8")))
    {
      step = new ProteinSequenceLabelingInferenceStep(T("SS8_Pass_") + lbcpp::toString(i)
          , createMultiClassClassifier(DSSPSecondaryStructureDictionary::getInstance())
          , featureFunction, T("DSSPSecondaryStructureSequence"));
      proteinInference->appendInference(step);
    }
    
    if (targets[i].contains(T("SA")))
    {
      step = new ProteinSequenceLabelingInferenceStep(T("SA_Pass_") + lbcpp::toString(i)
          , binaryLinearSVMInference(createOnlineLearner())
          , featureFunction, T("SolventAccessibilityThreshold20"));
      proteinInference->appendInference(step);
    }
    
    if (targets[i].contains(T("DR")))
    {
      step = new ProteinSequenceLabelingInferenceStep(T("DR_Pass_") + lbcpp::toString(i)
          , binaryLabelToProbabilityInference(T("DR-prob"), createBinaryClassifier(T("DR")))
          , featureFunction
          , T("DisorderProbabilitySequence")
          , T("DisorderSequence"));
      proteinInference->appendInference(step);
    }
    
    if (targets[i].contains(T("BBB")))
    {
      step = new ProteinBackboneBondSequenceInferenceStep(T("BBB_Pass_") + lbcpp::toString(i)
          , featureFunction
          , createLeastSquaresRegressor()
          , createLeastSquaresRegressor()
          , createDihedralRegressor());
      proteinInference->appendInference(step);
    }
    
    if (targets[i].contains(T("StAl")))
    {
      step = new ProteinSequenceLabelingInferenceStep(T("StAl_Pass_") + lbcpp::toString(i)
          , createMultiClassClassifier(StructuralAlphabetDictionary::getInstance())
          , featureFunction, T("StructuralAlphabetSequence"));
      proteinInference->appendInference(step);
    }
  }
  
  
  if (inputInference != File::nonexistent)
  {
    //proteinInference = Object::createFromFileAndCast<ProteinInference>(inputInference);
    std::cout << "Loading inference ..." << std::endl;
    //proteinInference->loadSubInferencesFromDirectory(inputInference);

  }
  
  InferenceBatchLearnerPtr learner = sharedSequentialInferenceBatchLearner(simulationInferenceBatchLearner());

  InferenceContextPtr learningContext = singleThreadedInferenceContext();
  EvaluationInferenceCallbackPtr evaluationCallback = new EvaluationInferenceCallback(proteinInference, trainingData, testingData);

  learningContext->appendCallback(new StandardOutputInferenceCallback(evaluationCallback));
  learningContext->appendCallback(new GlobalGnuPlotInferenceCallback(evaluationCallback, output));
  learningContext->appendCallback(new GnuPlotInferenceCallback(evaluationCallback, output, T("SecondaryStructureSequence"), T("DSSPSecondaryStructureSequence")));
  learningContext->appendCallback(new GnuPlotInferenceCallback(evaluationCallback, output, T("ResidueResidueContactMatrix8Ca"), T("BackboneBondSequence")));
  learningContext->appendCallback(new GnuPlotInferenceCallback(evaluationCallback, output, T("StructuralAlphabetSequence"), T("BackboneBondSequence")));
  learningContext->appendCallback(new GnuPlotInferenceCallback(evaluationCallback, output, T("BackboneBondSequence"), T("TertiaryStructure")));
  learningContext->appendCallback(evaluationCallback); // must be the last callback

  learningContext->train(learner, proteinInference, trainingData);

  if (saveInference)
    proteinInference->saveToFile(File::getCurrentWorkingDirectory().getChildFile(output));

  return 0;
}
