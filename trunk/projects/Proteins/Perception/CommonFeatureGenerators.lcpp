/*-----------------------------------------.---------------------------------.
| Filename: CommonFeatureGenerators.lcpp   | Common Feature Generators       |
| Author  : Francis Maes                   |                                 |
| Started : 26/04/2010 18:32               |                                 |
`------------------------------------------/                                 |
                               |                                             |
                               `--------------------------------------------*/

#include "Perception/CommonFeatureGenerators.h"
using namespace lbcpp;

featureGenerator positiveNumberFeatures(double number, size_t numIntervalsPerUnit)
{
  jassert(isNumberValid(number));
  number *= numIntervalsPerUnit;
  int previous = (int)floor(number);
  int next = previous + 1;
  double k = number - (double)previous;
  if (k != 1.0)
  {
    if (previous > 0)
      featureScope(0) featureSense((size_t)previous, 1 - k);
    else
      featureScope(1) featureSense((size_t)-previous, 1 - k);
  }
  if (k != 0.0)
  {
    if (next > 0)
      featureScope(0) featureSense((size_t)next, k);
    else
      featureScope(1) featureSense((size_t)-next, k);
  }
}

featureGenerator positiveNumberLogFeatures(double number, size_t numIntervalsPerLog10)
{
  jassert(number > 0);
  featureCall(0) positiveNumberFeatures(log(number), numIntervalsPerLog10);
}

featureGenerator numberLogFeatures(double number, size_t numIntervalsPerLog10)
{
  jassert(isNumberValid(number));
  if (number == 0)
    featureSense(T("zero"));
  else if (number > 0)
    featureCall(T("positive")) positiveNumberFeatures(log(number), numIntervalsPerLog10);
  else
    featureCall(T("negative")) positiveNumberFeatures(log(-number), numIntervalsPerLog10); 
}

featureGenerator multiScalePositiveNumberFeatures(double number, size_t numIntervalsPerLog10InCoarestScale, size_t intervalRatio, size_t numScales)
{
  jassert(number > 0);
  size_t numIntervals = numIntervalsPerLog10InCoarestScale;
  for (size_t i = 0; i < numScales; ++i)
  {
    featureCall(i) positiveNumberFeatures(number, numIntervals);
    numIntervals *= intervalRatio;
  }
}

featureGenerator multiScaleNumberFeatures(double number, size_t numIntervalsPerLog10InCoarestScale, size_t intervalRatio, size_t numScales)
{
  if (number == 0)
    featureSense(T("zero"));
  else if (number > 0)
    featureCall(T("positive")) multiScalePositiveNumberFeatures(number, numIntervalsPerLog10InCoarestScale, intervalRatio, numScales);
  else
    featureCall(T("negative")) multiScalePositiveNumberFeatures(-number, numIntervalsPerLog10InCoarestScale, intervalRatio, numScales);
}

featureGenerator percentageFeatures(double percentage, size_t numIntervals, bool cycle)
{
  jassert(percentage > -0.001 && percentage < 1.001);
  percentage = juce::jlimit(0.0, 1.0, percentage);
  double value = percentage * (double)numIntervals;
  size_t first = (size_t)value;
  size_t second = first + 1;
  if (second == numIntervals && cycle)
    second = 0;
  double k = value - first;
  if (k != 1.0)
    featureSense(first, 1.0 - k);
  if (k != 0.0)
    featureSense(second, k);
}

featureGenerator multiScalePercentageFeatures(double percentage, size_t numIntervalsInCoarsestScale, size_t intervalRatio, size_t numScales)
{
  jassert(percentage >= 0.0 && percentage <= 1.0);
  size_t numIntervals = numIntervalsInCoarsestScale;
  for (size_t i = 0; i < numScales; ++i)
  {
    featureCall(i) percentageFeatures(percentage, numIntervals);
    numIntervals *= intervalRatio;
  }
}

featureGenerator multiScaleDihedralAngleFeatures(double dihedralAngle, size_t numIntervalsInCoarsestScale, size_t intervalRatio, size_t numScales)
{
  size_t numIntervals = numIntervalsInCoarsestScale;
  for (size_t i = 0; i < numScales; ++i)
  {
    featureCall(i) dihedralAngleFeatures(dihedralAngle, numIntervals);
    numIntervals *= intervalRatio;
  }
}
