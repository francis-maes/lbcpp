/*-----------------------------------------.---------------------------------.
| Filename: TestLearning.cpp               | Test Learning                   |
| Author  : Francis Maes                   |                                 |
| Started : 28/03/2010 12:31               |                                 |
`------------------------------------------/                                 |
                               |                                             |
                               `--------------------------------------------*/

#include <lbcpp/lbcpp.h>
#include "InferenceCallback/SingleStepSimulationLearningCallback.h"
#include "InferenceCallback/GlobalSimulationLearningCallback.h"
#include "ProteinInference/ProteinEvaluationCallback.h"
#include "ProteinInference/ProteinInference.h"
using namespace lbcpp;

extern void declareProteinsClasses();

class SecondaryStructureVariableSetExample : public VariableSetExample
{
public:
  SecondaryStructureVariableSetExample(ProteinPtr protein)
    : aminoAcidSequence(protein->getAminoAcidSequence()),
      positionSpecificScores(protein->getPositionSpecificScoringMatrix()),
      secondaryStructure(protein->getSecondaryStructureSequence(false))
  {
    initializeGlobalAminoAcidComposition();
    initializeLocalAminoAcidComposition();
    initializePSSMCumul();
  }
  
  void initializeGlobalAminoAcidComposition() {
    size_t word[globalWordLength];
    
    // Initialize first word
    for (size_t i = 0; i < globalWordLength; i++)
    {
      word[i] = aminoAcidSequence->getLabel(i);
    }

    aminoAcidCompositions[arrayToString(word, globalWordLength, 0)] = 1;
    // Body
    size_t index = 0;
    for (size_t i = globalWordLength; i < aminoAcidSequence->getNumVariables(); i++)
    {
      word[index++] = aminoAcidSequence->getLabel(i);
      index %= globalWordLength;
      
      aminoAcidCompositions[arrayToString(word, globalWordLength, index)]++;
    }
  }
  
  void initializeLocalAminoAcidComposition()
  {
    size_t word[localWordLength];
    
    // Initialize first word
    for (size_t i = 0; i < localWordLength; i++)
    {
      word[i] = aminoAcidSequence->getLabel(i);
    }

    std::vector<size_t> target(aminoAcidSequence->getNumVariables(), 0);
    target[localWordLength -1] = 1;
    aminoAcidCompositionCumuls[arrayToString(word, localWordLength, 0)] = target;

    // Body
    size_t index = 0;
    for (size_t i = localWordLength; i < aminoAcidSequence->getNumVariables(); i++)
    {
      // Refresh current composition
      for (std::map<String, std::vector<size_t> >::iterator iter = aminoAcidCompositionCumuls.begin(); iter != aminoAcidCompositionCumuls.end(); iter++)
      {
        aminoAcidCompositionCumuls[iter->first].at(i) = aminoAcidCompositionCumuls[iter->first].at(i - 1);
      }
      
      // Increment new word
      word[index++] = aminoAcidSequence->getLabel(i);
      index %= localWordLength;

      String sWord = arrayToString(word, localWordLength, index);
      if (!aminoAcidCompositionCumuls.count(sWord))
      {
        std::vector<size_t> newVector(aminoAcidSequence->getNumVariables(), 0);
        aminoAcidCompositionCumuls[sWord] = newVector;
      }
      aminoAcidCompositionCumuls[sWord].at(i)++;
    }
  }
  
  void initializePSSMCumul()
  {
    size_t numScore = positionSpecificScores->getNumScores();
    size_t numVariables = aminoAcidSequence->getNumVariables();
    
    pssmCumuls.resize(numScore);
    
    for (size_t i = 0; i < numScore; i++)
    {
      std::vector<double> newVector;
      newVector.resize(numVariables);
      newVector.at(0) = positionSpecificScores->getScore(0, i);
      pssmCumuls.at(i) = newVector;
    }
    
    for (size_t i = 1; i < numVariables; ++i)
    {
      for (size_t j = 0; j < numScore; ++j)
      {
        pssmCumuls.at(j).at(i) = pssmCumuls.at(j).at(i - 1) + positionSpecificScores->getScore(i, j);
      }
    }
  }
  
  static String arrayToString(size_t array[], size_t length, size_t startIndex)
  {
    String toReturn;
    for (size_t i = 0; i < length; i++)
    {
      toReturn += String('A' + (int) array[startIndex++]);
      startIndex %= length;
    }
    return toReturn;
  }
  
  virtual VariableSetPtr getTargetVariables() const
    {return secondaryStructure;}

  virtual VariableSetPtr createInitialPrediction() const
  {
    LabelSequencePtr res = new SecondaryStructureSequence(false);
    res->setLength(secondaryStructure->getLength());
    return res;
  }

  static featureGenerator numberLogFeatures(double positiveNumber, double weight)
  {
    static const double clog2 = log10(2.0);
    static const double clog5 = log10(5.0);
    double l = log10(positiveNumber);
    double fl = floor(l);

    static const double minLog10 = -4.0;
    if (fl < minLog10)
      featureSense (0, weight); // very small number
    else
    {
      double frac = l - fl;
      //double base = pow(10.0, fl);
      int fracCase;
      double valMin, valMax;
      if (frac < clog2)
        fracCase = 0, valMin = 0.0, valMax = clog2;
      else if (frac < clog5)
        fracCase = 1, valMin = clog2, valMax = clog5;
      else
        fracCase = 2, valMin = clog5, valMax = 1.0;

      int featureNumber = 1 + (int)(fl - minLog10) * fracCase;
      jassert(featureNumber > 0);
      featureSense ((size_t)featureNumber, (frac - valMin) / (valMax - valMin) * weight);
    }
  }

  static featureGenerator numberFeatures(double value, double weight)
  {
    if (value > 0)
      featureCall("positive") inline numberLogFeatures(value, weight);
    else if (value < 0)
      featureCall("negative") inline numberLogFeatures(-value, weight);
    else
      featureSense("nullValue", weight);
  }

  static featureGenerator percentFeatures(double percent, double weight)
  {
    jassert(percent >= 0.0 && percent <= 1.0);
    enum {valueCount = 10};
    double p = percent * valueCount;
    featureSense((size_t)p, (p - (int)p) * weight);
  }

  featureGenerator posAndLengthFeatures(size_t variableIndex, double weight) const
  {
    double length = (double)aminoAcidSequence->getNumVariables();
    featureCall("length") inline numberFeatures(length, weight);
    featureCall("position") inline numberFeatures((double)variableIndex / length, weight);
  }
  
  featureGenerator globalAminoAcidCompositionFeatures() const
  {
    size_t length = aminoAcidSequence->getNumVariables();
    for (std::map<String, size_t>::const_iterator iter = aminoAcidCompositions.begin(); iter != aminoAcidCompositions.end(); iter++)
    {
      featureSense(iter->first, (double) iter->second / length);
    }
  }
  
  featureGenerator localAminoAcidCompositionFeatures(size_t variableIndex, size_t nbLeft, size_t nbRight) const
  {
    size_t start = (variableIndex < nbLeft) ? 0 : variableIndex - nbLeft;
    size_t stop = (variableIndex + nbRight >= aminoAcidSequence->getNumVariables()) ? aminoAcidSequence->getNumVariables() - 1 : variableIndex + nbRight;
    size_t length = stop - start;
    
    for (std::map<String, std::vector<size_t> >::const_iterator iter = aminoAcidCompositionCumuls.begin(); iter != aminoAcidCompositionCumuls.end(); iter++)
    {
      if (iter->second[start] != iter->second[stop])
      {
        featureSense(iter->first, (double) (iter->second[stop] - iter->second[start]) / length);
      }
    }
  }
  
  featureGenerator cumulativePSSMScoreFeatures(size_t variableIndex, size_t nbLeft, size_t nbRight) const
  {
    size_t start = (variableIndex < nbLeft) ? 0 : variableIndex - nbLeft;
    size_t stop = (variableIndex + nbRight >= aminoAcidSequence->getNumVariables()) ? aminoAcidSequence->getNumVariables() - 1 : variableIndex + nbRight;
    size_t length = stop - start;
    
    for (size_t i = 0; i < pssmCumuls.size(); ++i) {
      if (pssmCumuls.at(i).at(stop) != pssmCumuls.at(i).at(start)) {
        featureSense(String((int) i), (pssmCumuls.at(i).at(stop) - pssmCumuls.at(i).at(start)) / length);
      }
    }
  }

  virtual featureGenerator getVariableFeatures(size_t variableIndex, VariableSetPtr prediction) const
  {
    featureCall("_") inline posAndLengthFeatures(variableIndex, 1.0);

    // conjunctions with current amino acid
    featureCall(T("A") + String((int)aminoAcidSequence->getLabel(variableIndex))) inline posAndLengthFeatures(variableIndex, 1.0);

    /* conjunctions with current pssm entries
    size_t n = positionSpecificScores->getNumScores();
    for (size_t i = 0; i < n; ++i)
    {
      double score = positionSpecificScores->getScore(variableIndex, i);
      if (score)
        featureCall(T("SS") + String((int)i)) inline posAndLengthFeatures(variableIndex, score);
    }*/
    
    featureCall("a") inline aminoAcidSequence->windowFeatures(variableIndex, nbAALeft, nbAARight, true);
    
    // conjunctions of AA of variable sizes, centred around the current position
    /*for (size_t i = 1; i < 4; ++i)
    {
      int p1 = (int)variableIndex - (int)i;
      int p2 = (int)variableIndex + (int)i;
      String featureName;
      for (int j = p1; j <= p2; ++j)
      {
        if (j < 0 || j >= (int)aminoAcidSequence->getLength())
          featureName += "_";
        else
          featureName += String(aminoAcidSequence->getLabel(j));
      }
      featureSense(featureName);
    }*/
    
    //featureCall("comp") inline aminoAcidCompositionFeatures();

    //featureCall("lc") inline localAminoAcidCompositionFeatures(variableIndex, nbAALeft, nbAARight);
    
    featureCall("pc") inline cumulativePSSMScoreFeatures(variableIndex, nbAALeft, nbAARight);

    featureCall("p") inline positionSpecificScores->windowFeatures(variableIndex, nbAALeft, nbAARight, true);
    if (prediction)
    {
      LabelSequencePtr predictedSecondaryStructure = prediction.dynamicCast<LabelSequence>();
      jassert(predictedSecondaryStructure);
      featureCall("pr") inline predictedSecondaryStructure->windowFeatures(variableIndex, nbAALeft, nbAARight, false);
    }
  }
  
  static void setWindowLength(size_t nbAALeft, size_t nbAARight)
  {
    SecondaryStructureVariableSetExample::nbAALeft = nbAALeft;
    SecondaryStructureVariableSetExample::nbAARight = nbAARight;
  }
  
  static String toStaticString()
  {
    return String("Feature: ")
    + String("\n    > AA at left: ") + String((int) nbAALeft)
    + String("\n    > AA at right: ") + String((int) nbAARight)
    //+ String("\n    > Global word length: ") + String((int) globalWordLength)
    //+ String("\n    > Local word length: ") + String((int) localWordLength)
    + String("\n    > Cumulative PSSM Score: ") + String("Yes");
  }
      
  
private:
  LabelSequencePtr aminoAcidSequence;
  ScoreVectorSequencePtr positionSpecificScores;
  LabelSequencePtr secondaryStructure;
  
  std::map<String, size_t> aminoAcidCompositions;
  std::map<String, std::vector<size_t> > aminoAcidCompositionCumuls;
  std::vector< std::vector<double> > pssmCumuls;

  static size_t nbAALeft;
  static size_t nbAARight;
  static size_t localWordLength;
  static size_t globalWordLength;
};

size_t SecondaryStructureVariableSetExample::nbAALeft = 7;
size_t SecondaryStructureVariableSetExample::nbAARight = 7;
size_t SecondaryStructureVariableSetExample::globalWordLength = 1;
size_t SecondaryStructureVariableSetExample::localWordLength = 1;

class ProteinToVariableSetExample : public ObjectFunction
{
public:
  virtual String getOutputClassName(const String& inputClassName) const
    {return T("VariableSetExample");}

  virtual ObjectPtr function(ObjectPtr object) const
  {
    ProteinPtr protein = object.dynamicCast<Protein>();
    jassert(protein);
    return new SecondaryStructureVariableSetExample(protein);
  }
};

StoppingCriterionPtr createLearningStoppingCriterion(size_t nbIteration)
{
  return maxIterationsStoppingCriterion(nbIteration);
}

using juce::Time;

class TestTrainingProgressCallback : public TrainingProgressCallback
{
public:
  TestTrainingProgressCallback(StoppingCriterionPtr stoppingCriterion, ObjectContainerPtr validationData, OutputStream& results)
    : trainAccuracy(0.0), testAccuracy(0.0), stoppingCriterion(stoppingCriterion), validationData(validationData), results(results) {}
  
  double trainAccuracy;
  double testAccuracy;
  int iterationNumber;
  double startTime;
  
  virtual void progressStart(const String& description)
  {
    startTime = Time::getMillisecondCounter() / 1000.0;
    iterationNumber = 0;
    std::cout << description << std::endl;
    stoppingCriterion->reset();
  }
  
  virtual bool trainingProgressStep(LearningMachinePtr m, ObjectContainerPtr trainingData)
  {
    VariableSetModelPtr model = m.dynamicCast<VariableSetModel>();
    jassert(model);
    
    std::cout << std::endl << "Iteration " << iterationNumber << " Time since begin: " << (Time::getMillisecondCounter() / 1000.0 - startTime) << std::endl;

    std::cout << "Evaluating on training data..." << std::flush;
    trainAccuracy = model->evaluate(trainingData);
    std::cout << " => " << trainAccuracy << std::endl;

    std::cout << "Evaluating on testing data..." << std::flush;
    testAccuracy = model->evaluate(validationData);
    std::cout << " => " << testAccuracy << std::endl;
    
    double time = Time::getMillisecondCounter() / 1000.0;
    results << iterationNumber << " " << trainAccuracy << " " << testAccuracy << " " << (time - startTime) << "\n";
    results.flush();
    ++iterationNumber;
    
    return !stoppingCriterion->shouldOptimizerStop(trainAccuracy);
  }

  virtual void progressEnd()
    {std::cout << "Training finished." << std::endl;}
    
private:
  StoppingCriterionPtr stoppingCriterion;
  ObjectContainerPtr validationData;
  OutputStream& results;
};

GradientBasedClassifierPtr createMaxentClassifier(FeatureDictionaryPtr labels, IterationFunctionPtr learningRate, double regularizer)
{
  GradientBasedLearnerPtr learner = stochasticDescentLearner(learningRate);  
  GradientBasedClassifierPtr classifier = maximumEntropyClassifier(learner, labels);
  classifier->setL2Regularizer(regularizer);
  return classifier;
}

void usage(char* command) {
  std::cout << "Usage: " << command << " PROTEIN_DIR RESULT_FILE NB_FOLD FOLD_ID NB_ITER REGULARIZER ('Inv' INIT ITER | 'Lin' CONST) NB_AA_LEFT NB_AA_RIGHT ('CO' | 'SICA' NB_PASSES RANDOM DETERMINISTIC)" << std::endl;
}

int main(int argc, char** argv)
{
  if (argc < 8)
  {
    usage(argv[0]);
    return -1;
  }
  
  size_t nextArgument = 1;
  
  File cwd = File::getCurrentWorkingDirectory();
  File cb513Directory = cwd.getChildFile(String(argv[nextArgument++]));
  File resultsFile = cwd.getChildFile(String(argv[nextArgument++]));
  size_t nbFolds = atoi(argv[nextArgument++]);
  size_t targetFold = atoi(argv[nextArgument++]);
  size_t nbIteration = atoi(argv[nextArgument++]);
  double regularizer = atof(argv[nextArgument++]);
  
  std::cout << "Protein Directory: " << cb513Directory.getFullPathName() << std::endl;
  std::cout << "Result File: " << resultsFile.getFullPathName() << std::endl;
  std::cout << "Fold: " << (targetFold+1) << "/" << nbFolds << std::endl;
  std::cout << "Stopping criterion: " << nbIteration << " iterations" << std::endl;
  std::cout << "L2 Regularizer value: " << regularizer << std::endl;
    

  resultsFile.deleteFile();
  OutputStream* resultsFileStream = resultsFile.createOutputStream();
  if (!resultsFileStream)
  {
    std::cerr << "Beeeruh" << std::endl;
    return 2;
  }
  
  
  std::cout << "Learning Rate: ";
  IterationFunctionPtr learningRate = NULL;
  String argumentValue = String(argv[nextArgument++]);
  if (argumentValue == String("Inv"))
  {
    double initialValue = atof(argv[nextArgument++]);
    size_t decreaseIteration = atoi(argv[nextArgument++]);
    learningRate = invLinearIterationFunction(initialValue, decreaseIteration);
    std::cout << "invLinear(" << initialValue << ", " << decreaseIteration  << ")" << std::endl;
  }
  else if (argumentValue == String("Lin"))
  {
    double constant = atof(argv[nextArgument++]);
    learningRate = constantIterationFunction(constant);
    std::cout << "constant(" << constant << ")" << std::endl;
  }
  else
  {
    std::cout << "unknown value '" << argumentValue << "'" << std::endl;
    usage(argv[0]);
    return -2;
  }

  //------
  declareProteinsClasses();
  ObjectStreamPtr proteinsStream = directoryObjectStream(cb513Directory, T("*.protein"));
  
  
    
  size_t nbAALeft = atoi(argv[nextArgument++]);
  size_t nbAARight = atoi(argv[nextArgument++]);
  
  SecondaryStructureVariableSetExample::setWindowLength(nbAALeft, nbAARight);
  std::cout << SecondaryStructureVariableSetExample::toStaticString() << std::endl;

  ObjectStreamPtr examplesStream = proteinsStream->apply(new ProteinToVariableSetExample());
  ObjectContainerPtr examples = examplesStream->load()->randomize();
  FeatureDictionaryPtr labels = examples->getAndCast<VariableSetExample>(0)->getTargetVariables()->getVariablesDictionary();
  //------



  GradientBasedClassifierPtr classifier = createMaxentClassifier(labels, learningRate, regularizer);

  std::cout << "Model: ";
  VariableSetModelPtr model = NULL;
  argumentValue = String(argv[nextArgument++]);
  if (argumentValue == String("CO"))
  {
    model = independantClassificationVariableSetModel(classifier);
    std::cout << "Content Only" << std::endl;
  }
  else if(argumentValue == String("SICA"))
  {
    size_t nbPasses = atoi(argv[nextArgument++]);
    bool randomOrder = atoi(argv[nextArgument++]) == 1;
    bool deterministic = atoi(argv[nextArgument++]) == 1;
    
    model = simulatedIterativeClassificationVariableSetModel(classifier, nbPasses, randomOrder, deterministic);
    std::cout << "Simlated Iterative Classification Algorithm" << std::endl;
    std::cout << "    > Maximun passes: " << nbPasses << std::endl;
    std::cout << "    > Random order: " << randomOrder << std::endl;
    std::cout << "    > Deterministic: " << deterministic << std::endl;
  }
  else
  {
    std::cout << "unkonwn value '" << argumentValue << "'" << std::endl;
    usage(argv[0]);
    return -3;
  }
  std::cout << model->toString() << std::endl;
    
  ObjectContainerPtr trainingData = examples->invFold(targetFold, nbFolds);
  ObjectContainerPtr testingData = examples->fold(targetFold, nbFolds);

  ReferenceCountedObjectPtr<TestTrainingProgressCallback> callback
    = new TestTrainingProgressCallback(createLearningStoppingCriterion(nbIteration), testingData, *resultsFileStream);
  model->trainBatch(trainingData, callback);
  
  std::cout << "Train Accuracy = " << callback->trainAccuracy << std::endl;
  std::cout << "Test Accuracy = " << callback->testAccuracy << std::endl;
  
  delete resultsFileStream;
 
  return 0;
}
