Arnaud:
 * Faire les headers dans le meme style que le reste de la librairie
 * OptimizerState: enlever incTotalNumberOfRequests() et incTotalNumberOfEvaluations() / mettre en private (?)
 * OptimizerState: renommer *UnprocessedEvaluations en *ProcessedRequests
 * Classe dérivé: DistributionBasedOptimizerState
 * OptimizerContext: enlever getDoubleFromOutput; utiliser Variable::toDouble()
 * OptimizerContext: renommer waitAllEvaluationsFinished -> waitUntilAllRequestsAreProcessed()
 * OptimizerContext: soit bool evaluate(ExecutionContext& , const Variable& ) si ca peut deconner, 
                 soit void evaluate(const Variable& ) si ca marche toujours
             (Une function qui renvoie false doit "justifier" pourquoi en appelant errorCallback au préalable sur le context donné en argument)
 * MultiThreadsOptimizerContext: renommer MTContext en multiThreadedContext / executionContext (Les noms de variables doivent toujours commencer par une minuscule)
 * MultiThreadsOptimizerContext: renommer nbThreads en numThreads (pour rester homogène avec le reste du code)
 * UniformSampleAndPickBestOptimizer: remplacer le std::cout par un informationCallback
        ... ou mieux: faire faire le informationCallback par la classe de base Optimizer
         (pour que tous les optimizers aient une manière cohérente de faire les informationCallback / resultCallback)
   => Au passage, la manière dont les enterScope/leaveScope/informationCallback/resultCallback sont fait, est "optimisé" pour un bon affichage dans l'explorer
       Donc, n'hésite pas à utiliser l'explorer pour tester tes optimiseurs; et verifier qu'on a un accès facile à tous les résultats intermédiare qui nous intéresse
 * GridOptimizer => code mort?    

Go:
 * learn a big model
 * integrate's olivier last modifs
 * Nouvelles features
 * Courbes dans l'evaluateur
 * GoPatterns
 * Utilisation du manager

Proteins:
 * Ajouter des features de segments

Core:
 * Renommer MultiLinearLearnableFunction en ParallelLearnableFunction<T>
 * MapContainerFunction: la transformer en ProxyFunction, faire la version parallele, absorber le Apply des container

Explorer:
 * LogScale dans les curves
 * Systeme d'export/import de fichiers general
 * Export as GnuPlot Data File
 * Export as CSV
 * ExecutionTrace: refermer les noeuds au fur et à mesure
 * ExecutionTrace: Améliorer le système de colonnes
 * Explorer: Faire un mecanisme general pour la gestion des FileFormat, utiliser sur les sgf par exemple
 * Explorer: Faire une vrai classe de base ObjectComponent qui absorbe ComponentWithPreferedSize / VariableSelector et qui gere les differents cas:
     topLevel | insideTree | oneLineComponent
 * Explorer: interfaces 
     - Importer: String -> UIImporter: (getName(), doesRecognizeFile(), perform())
     - Exporter: Type -> UIExporter: (getName(), getDefaultExtension(), perform())
     - Command: Type -> UICommand: (getIcon(), getName(), perform())
     - TreeItems: Type -> UITreeItemBuilder: (getIcon(), getToolTip(), getAttributes(), perform())
     - Component: Type -> UIComponent: (preferedSize, variableSelector, parameters, ...)
