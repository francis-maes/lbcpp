<?xml version="1.0" encoding="UTF-8"?>

<library name="Distribution" directory="Distribution">

  <include file="lbcpp/Distribution/Distribution.h"/>
  <include file="lbcpp/Distribution/DiscreteDistribution.h"/>
  <include file="lbcpp/Distribution/ContinuousDistribution.h"/>
  <include file="lbcpp/Distribution/MultiVariateDistribution.h"/>

  <import name="DistributionFunction"/>
  <import name="DistributionBuilder"/>

  <!-- Probability Distribution -->
  <template name="Distribution" base="Object" abstract="yes">
    <parameter name="elementsType" type="Variable"/>
  </template>

  <!-- Discrete Probability Distribution -->
  <template name="DiscreteDistribution" base="Distribution[elementsType]" abstract="yes">
    <parameter name="elementsType" type="Variable"/>
  </template>

  <class name="BernoulliDistribution" base="DiscreteDistribution[Boolean]">
    <variable type="Double" name="pTrue"/>
    <variable type="Double" name="pFalse"/>
  </class>
  
  <template name="EnumerationDistribution" base="DiscreteDistribution[enumeration]">
    <parameter name="enumeration" type="EnumValue"/>

    <code>
    EnumerationPtr getEnumeration() const
      {return getTemplateArgument(0).staticCast&lt;Enumeration&gt;();}

    virtual size_t getNumMemberVariables() const
      {return getEnumeration()->getNumElements() + 1;}

    virtual Variable getMemberVariableValue(const Object* pthis, size_t index) const
    {
      const EnumerationDistribution* distribution = dynamic_cast&lt;const EnumerationDistribution* &gt;(pthis);
      return distribution ? Variable(distribution->values[index], probabilityType) : Variable::missingValue(probabilityType);
    }

    virtual void setMemberVariableValue(ExecutionContext&amp; context, Object* pthis, size_t index, const Variable&amp; subValue) const
    {
      EnumerationDistribution* distribution = dynamic_cast&lt;EnumerationDistribution* &gt;(pthis);
      if (distribution)
      {
        if (!distribution->values.size())
          distribution->values.resize(distribution->getEnumeration()->getNumElements() + 1, 0.0);

        jassert(subValue.isDouble());
        jassert(index &lt; distribution->values.size());
        distribution->values[index] = subValue.getDouble();
      }
    }

    virtual VariableSignaturePtr getMemberVariable(size_t index) const
    {
      String name = Variable(index, getEnumeration()).toString();
      return new VariableSignature(probabilityType, T("p[") + name + T("]"), name);
    }
    </code>
  </template>
  
  <!-- Continuous Probability Distribution -->
  <class name="ContinuousDistribution" base="Distribution[Double]" abstract="yes"/>

  <class name="UniformDistribution" base="ContinuousDistribution">
    <variable type="Double" name="minimum"/>
    <variable type="Double" name="maximum"/>
  </class>

  <class name="GaussianDistribution" base="ContinuousDistribution">
    <variable type="Double" name="mean"/>
    <variable type="Double" name="variance"/>
  </class>
  
  <class name="IntegerGaussianDistribution" base="GaussianDistribution"/>
    
  <class name="PositiveIntegerGaussianDistribution" base="IntegerGaussianDistribution"/>
  
  <!-- MultiVariate Probability Distribution -->
  <template name="MultiVariateDistribution" base="Distribution[elementsType]" abstract="yes">
    <parameter name="elementsType" type="Variable"/>
  </template>
  
  <template name="IndependentMultiVariateDistribution" base="MultiVariateDistribution[elementsType]">
    <parameter name="elementsType" type="Object"/>
    
    <variable type="ObjectVector[Distribution[Variable]]" name="distributions"/>
  </template>
  
</library>
