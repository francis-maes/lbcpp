/*-----------------------------------------.---------------------------------.
 | Filename: LatinHypercubeVectorSampler.h  | Latin Hypercube Sampler         |
 | Author  : Denny Verbeeck                 |                                 |
 | Started : 25/02/2013 12:49               |                                 |
 `------------------------------------------/                                 |
                                |                                             |
                                `--------------------------------------------*/

#ifndef ML_SAMPLER_LATIN_HYPERCUBE_VECTOR_H_
# define ML_SAMPLER_LATIN_HYPERCUBE_VECTOR_H_

# include <ml/Sampler.h>

namespace lbcpp
{

/** Class for creating a Latin Hypercube Sample of a domain.
 *  Each dimension of the input domain (with dimensionality \f$D\f$) is 
 *  divided in to \f$N\f$ equally probable intervals. This partitions the
 *  input space into \f$N^D\f$ equally probable subspaces. Samples are
 *  chosen by uniformly sampling such a subspace. Additionally no two
 *  samples share the same interval for the same dimension. As a result,
 *  a total of \f$N\f$ samples are generated by the sample() function.
 **/
  
class LatinHypercubeVectorSampler : public Sampler
{
public:
  /** Constructor 
   *  \param numIntervals Number of intervals \f$N\f$
   *  \param enforceEdges When this is set, the result is ensured to have, 
   *                      for each dimension \f$d\f$, at least one sample
   *                      \f$\vec{x}\f$ for which \f$\vec{x}_d\f$ is minimal 
   *                      *and* at least one sample for which \f$\vec{x}_d\f$
   *                      is maximal. This results in \f$2D\f$ samples. The
   *                      remaining \f$N-2D\f$ samples are chosen by normal
   *                      LHS, from the \f$N\f$ intervals.
   **/
  LatinHypercubeVectorSampler(size_t numIntervals = 10, bool enforceEdges = false) 
    : numIntervals(numIntervals), enforceEdges(enforceEdges) {}
  
  virtual void initialize(ExecutionContext& context, const DomainPtr& domain)
  {
    this->domain = domain.staticCast<VectorDomain>()->getElementsDomain().staticCast<ScalarVectorDomain>();
    intervals.resize(this->domain->getNumDimensions());
    for (size_t d = 0; d < this->domain->getNumDimensions(); ++d)
    {
      intervals[d].resize(numIntervals);
      double step = (this->domain->getUpperLimit(d) - this->domain->getLowerLimit(d)) / numIntervals;
      double val = this->domain->getLowerLimit(d);
      for (size_t i = 0; i < numIntervals; ++i, val += step)
        intervals[d][i] = Interval(val, val + step);
    }
  }
  
  /** Create a Latin Hypercube Sample of size \f$N\f$.
   *  \return An OVector containing DenseDoubleVector. Each DenseDoubleVector is one sample.
   **/
  virtual ObjectPtr sample(ExecutionContext& context) const
  {
    jassert(numIntervals && domain);
    std::vector<std::vector<Interval> > remainingIntervals(intervals);  // remaining intervals from which to choose
    
    RandomGeneratorPtr random = context.getRandomGenerator();
    OVectorPtr res = vector(denseDoubleVectorClass(), numIntervals);
    
    size_t numEdges = 0;
    if (enforceEdges)
    {
      for (size_t d = 0; d < domain->getNumDimensions(); ++d) // for each dimension we need to create two samples
      {
        DenseDoubleVectorPtr sampleLowerbound = domain->sampleUniformly(random);
        DenseDoubleVectorPtr sampleUpperbound = domain->sampleUniformly(random);
        sampleLowerbound->setValue(d, domain->getLowerLimit(d));
        sampleUpperbound->setValue(d, domain->getUpperLimit(d));
        res->set(numEdges++, sampleLowerbound);
        res->set(numEdges++, sampleUpperbound);
      } // for d
    } // enforceEdges
    
    for (size_t i = numEdges; i < numIntervals; ++i)
    {
      DenseDoubleVectorPtr sample = new DenseDoubleVector(domain->getNumDimensions(), 0.0);
      for (size_t d = 0; d < domain->getNumDimensions(); ++d)
      {
        int interval = random->sampleInt(numIntervals);
        sample->setValue(d, random->sampleDouble(remainingIntervals[d][interval].first, remainingIntervals[d][interval].second));
        // O(1) alternative to erase, since order of the elements does not matter
        remainingIntervals[d][interval] = remainingIntervals[d].back();
        remainingIntervals[d].pop_back();
      }
      res->set(i, sample);
    }
    return res;
  }
  
protected:
  friend class LatinHypercubeVectorSamplerClass;
  
  typedef std::pair<double, double> Interval;           /**< Pair of doubles, representing a domain               */
  
  ScalarVectorDomainPtr domain;                         /**< Pointer to the domain in which we sample             */
  size_t numIntervals;                                  /**< Number of intervals \f$N\f$                          */
  bool enforceEdges;                                    /**< Enforce sampling dimension edges or not              */
  std::vector<std::vector<Interval> > intervals;        /**< Collection of available intervals for each dimension */
};

}; /* namespace lbcpp */

#endif // !ML_SAMPLER_LATIN_HYPERCUBE_VECTOR_H_
