#include "TreeSearchSpace.cr++"
#include "SortedTreeSearchNodeMap.cr++"

namespace cralgo
{

crAlgorithm int bestFirstSearch(TreeSearchSpace& searchSpace, size_t maxSteps)
{
  SortedTreeSearchNodeMap closedNodes;
  closedNodes.insert(0);
  
  for (size_t t = 0; t < maxSteps && closedNodes.size(); ++t)
  {
    stateFunction double nodeValues(size_t searchNodeIndex)
    {
      TreeSearchNode& searchNode = searchSpace.getNode(searchNodeIndex);
      if (searchNode.hasParent())
      {
        ChoosePtr choose = searchNode.getParentChoose();
        if (choose->getNumActionValues() > 0)
          return choose->actionValue(searchNode.getChoice());        
        searchNode.open();
        return choose->stateValue();
      }
      else
      {
        // initial node
        assert(searchNode.opened());
        return searchNode.getChoose()->stateValue();
      }
    }
    
    stateFunction featureGenerator nodeFeatures(size_t searchNodeIndex)
    {
      TreeSearchNode& searchNode = searchSpace.getNode(searchNodeIndex);
      if (searchNode.hasParent())
      {
        CRAlgorithmPtr state = searchNode.getParentState();
        ChoosePtr choose = searchNode.getParentChoose();
        const void* choice = searchNode.getChoice();
        
        if (choose->getNumActionFeatures() > 0)
        {
          FeatureGeneratorPtr actionFeatures = choose->actionFeatures(choice);
          featureCall actionFeatures;
        }
        else if (choose->getNumStateFeatures() > 0)
        {
          searchNode.open();
          FeatureGeneratorPtr stateFeatures = choose->stateFeatures();
          featureCall stateFeatures;
        }
      }
      else
      {
        // initial node
        assert(searchNode.opened());
        FeatureGeneratorPtr stateFeatures = searchNode.getChoose()->stateFeatures();
        featureCall stateFeatures;
      }
    }
    
    stateFunction std::string nodeToString(size_t searchNodeIndex)
    {
      TreeSearchNode& searchNode = searchSpace.getNode(searchNodeIndex);
      TreeSearchNode* parent = searchNode.getParent();
      if (parent)
        return searchNode.getParentChoose()->actionDescription(searchNode.getChoice());
      else
        return "<initial>";
    }
    
    stateFunction double postSupervision(size_t searchNodeIndex, const crAlgorithm<bestFirstSearch>& finalState)
    {
      assert(finalState.hasReturn());
      int solution = *finalState.getReturn();
      if (solution < 0)
        return 0.0;
      else
        return searchSpace.isAncestorOf(searchNodeIndex, (size_t)solution) ? 1.0 : 0.0;
    }
    
    // todo: node features
    TreeSearchNode* node = NULL;
    size_t nodeIndex = choose<size_t>(closedNodes, nodeValues, nodeFeatures, nodeToString, postSupervision);
    
    // test if node is a solution
    node = &searchSpace.getNode(nodeIndex);
    node->open();
    if (node->isSolution())
      return (int)nodeIndex; // found a solution !
      
    // remove selected node
    closedNodes.remove(nodeIndex);

    // insert sucessors
    { // TODO: virer ce scope, des que la dependence entre initialiseurs est resolu
      ActionIteratorPtr it = node->newIterator();
      if (it)
        for (; it->exists(); it->next())
          closedNodes.insert(searchSpace.getChildrenNode(nodeIndex, it->get()));
    }
    
    // cost of one step
    reward (-1.0);
  }
  return -1; // no solutions
}


}; /* namespace cralgo */

class BestFirstSearchInstanceSet : public CRAlgorithmInstanceSet
{
public:
  CRAlgorithmInstanceSetPtr getTarget() const
    {return getFrameAttributeCast<CRAlgorithmInstanceSet>(T("problems"));}
    
  size_t getMaxSteps() const
    {return (size_t)getIntAttribute(T("maxSteps"));}
    
  virtual unsigned getNumInstances()
    {CRAlgorithmInstanceSetPtr target = getTarget(); return target ? target->getNumInstances() : 0;}

  virtual std::string getInstanceName(size_t i)
    {CRAlgorithmInstanceSetPtr target = getTarget(); return target ? target->getInstanceName(i) : "<null>";}

  virtual cralgo::CRAlgorithmPtr createInstance(size_t i)
  {
    CRAlgorithmInstanceSetPtr target = getTarget();
    if (!target)
      return cralgo::CRAlgorithmPtr();
    cralgo::CRAlgorithmPtr c = target->createInstance(i);
    if (!c)
      return cralgo::CRAlgorithmPtr();
    searchSpace.reset(c);
    return cralgo::bestFirstSearch(searchSpace, getMaxSteps());
  }
  
private:
  cralgo::TreeSearchSpace searchSpace;
};

