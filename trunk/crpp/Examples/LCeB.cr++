namespace lceb
{

inline bool isMultipleOf(size_t a, size_t b)
{
  assert(b);
  return (a % b) == 0;
}

featureGenerator numberLogFeaturesBase(const std::string& nameMin, const std::string& nameMax, double valMin, double valMax, double value)
{
  jassert(value >= valMin && value <= valMax);
  double delta = valMax - valMin;
  assert(delta > 0);
  featureSense (nameMin, 1 - ((value - valMin) / delta));
  featureSense (nameMax, 1 - ((valMax - value) / delta));
}

featureGenerator numberLogFeatures(double positiveNumber)
{
  static const double clog2 = log10(2.0);
  static const double clog5 = log10(5.0);
  double l = log10(positiveNumber);
  double fl = floor(l);
  double frac = l - fl;
  double base = pow(10.0, fl);

  if (frac < clog2)
    featureCall inline numberLogFeaturesBase(cralgo::toString(base), cralgo::toString(2 * base), 0, clog2, frac);
  else if (frac < clog5)
    featureCall inline numberLogFeaturesBase(cralgo::toString(2 * base), cralgo::toString(5 * base), clog2, clog5, frac);
  else
    featureCall inline numberLogFeaturesBase(cralgo::toString(5 * base), cralgo::toString(10 * base), clog5, 1.0, frac);
}

featureGenerator numberFeatures(double value)
{
  if (value > 0)
    featureCall("positive") inline numberLogFeatures(value);
  else if (value < 0)
    featureCall("negative") inline numberLogFeatures(-value);
  else
    featureScope("_") inline featureSense("nullValue");
}

featureGenerator valueWRTTargetFeatures(int value, int target)
{
  assert(value > 0 && target > 0);
  
  featureCall("diff") inline numberFeatures((double)(value - target));
    
  // is value an approximate multiple of objective ?
  double k = value / (double)target;
  double distanceToMultiple = k - (int)(k + 0.5);
  featureCall("distToMultiple") inline numberFeatures(distanceToMultiple);

  // is value an approximate divisor of objective ?
  k = 1.0 / k;
  double distanceToDivisor = k - (int)(k + 0.5);
  featureCall("distToDivisor") inline numberFeatures(distanceToDivisor);
}

featureGenerator valueWRTSecondaryTargetsFeatures(int value, int targetModifier, int target)
{
  if (target > targetModifier)
    featureCall("plus") inline valueWRTTargetFeatures(value, target - targetModifier);
  featureCall("minus") inline valueWRTTargetFeatures(value, target + targetModifier);
  if (isMultipleOf(target, targetModifier))
    featureCall("times") inline valueWRTTargetFeatures(value, target / targetModifier);
  featureCall("divide") inline valueWRTTargetFeatures(value, target * targetModifier);
}
  
struct Operation
{
  Operation(int operation, size_t leftIndex, size_t rightIndex)
    : operation(operation), leftIndex(leftIndex), rightIndex(rightIndex) {}
  Operation() : operation(numOperations), leftIndex(0), rightIndex(0) {}
    
  int operation;
  size_t leftIndex, rightIndex;

  enum
  {
    plus = 0,
    minus,
    times,
    divide,
    
    numOperations,
  };
  
  static inline char getChar(int op)
    {static const char* symbols = "+-x/ "; return symbols[op];}
    
  static inline int compute(int operation, int leftValue, int rightValue)
  {
    switch (operation)
    {
      case plus: return leftValue + rightValue;
      case minus: assert(leftValue > rightValue); return leftValue - rightValue;
      case times: return leftValue * rightValue;
      case divide: assert(isMultipleOf(leftValue, rightValue)); return leftValue / rightValue;
      default: assert(false); return 0;
    }
  }
  
  friend inline std::ostream& operator <<(std::ostream& ostr, const Operation& op)
    {return ostr << "(" << getChar(op.operation) << " " << op.leftIndex << " " << op.rightIndex << ")";}
};

class Expression
{
public:
  Expression(int value = 0) : value(value), left(NULL), right(NULL), operation(Operation::numOperations) {}
  Expression(const Expression& other) : value(other.value), left(NULL), right(NULL), operation(other.operation)
  {
    if (other.left) left = new Expression(*other.left);
    if (other.right) right = new Expression(*other.right);
  }
  ~Expression()
  {
    if (left) delete left;
    if (right) delete right;
  }
  
  void setLeaf(int value)
    {this->value = value;}
  
  void setNonLeaf(int operation, Expression* left, Expression* right)
    {assert(left && right); this->operation = operation; this->left = left; this->right = right;}

  int getValue() const
    {return value;}
  
  bool isLeaf() const
    {return !left && !right;}
    
  friend std::ostream& operator <<(std::ostream& ostr, const Expression& expr)
  {
    if (expr.isLeaf())
      return ostr << expr.value;
    else
    {
      assert(expr.left && expr.right);
      return ostr << "(" << *expr.left << " " << Operation::getChar(expr.operation) << " " << *expr.right << ")";
    }
  }

private:
  int value;
  Expression* left;
  Expression* right;
  int operation;
};

class ExpressionSet
{
public: 
  ExpressionSet() {}
  ExpressionSet(const ExpressionSet& other)
  {
    v.resize(other.v.size());
    for (size_t i = 0; i < v.size(); ++i)
      v[i] = new Expression(*other.v[i]);
  }
  ExpressionSet(const std::vector<int>& numbers)
  {
    for (size_t i = 0; i < numbers.size(); ++i)
      add(numbers[i]);
  }    
  
  ~ExpressionSet()
  {
    for (size_t i = 0; i < v.size(); ++i)
      delete v[i];
  }
  
  void add(int value)
    {v.push_back(new Expression(value));}
  
  size_t size() const
    {return v.size();}
    
  int getValue(size_t index) const
    {return v[index]->getValue();}
    
  bool containTargetValue(int target) const
  {
    for (size_t i = 0; i < v.size(); ++i)
      if (v[i]->getValue() == target)
        return true;
    return false;
  }
  
  int getBestResult(int target) const
  {
    int minDist = 0x7FFFFFFF;
    size_t best = 0;
    for (size_t i = 0; i < v.size(); ++i)
    {
      int dist = abs(v[i]->getValue() - target);
      if (dist < minDist)
        minDist = dist, best = i;
    }
    return best;
  }
  
  int compute(const Operation& op) const
  {
    assert(op.leftIndex < v.size() && op.rightIndex < v.size() && op.leftIndex != op.rightIndex);
    return Operation::compute(op.operation, getValue(op.leftIndex), getValue(op.rightIndex));
  }
  
  void apply(const Operation& op)
  {
    Expression* result = new Expression(compute(op));
    result->setNonLeaf(op.operation, v[op.leftIndex], v[op.rightIndex]);
    std::cout << cralgo::toString(*result) << std::endl;
    
    int i1 = op.leftIndex;
    int i2 = op.rightIndex;
    if (i1 > i2)
      {int tmp = i1; i1 = i2; i2 = tmp;}
    v.erase(v.begin() + i2);
    v.erase(v.begin() + i1);
    v.push_back(result);
  }

  const Expression& getExpression(size_t index) const
    {assert(index < v.size()); return *v[index];}
    
  friend std::ostream& operator <<(std::ostream& ostr, const ExpressionSet& expressions)
    {return ostr << cralgo::toString(expressions.v);}
  
private:
  std::vector<Expression* > v;
};

crAlgorithm bool searchSpace(std::vector<int> numbers, int target, int featureVerbosity = 2)
{
  ExpressionSet expressions(numbers);

  while (expressions.size() > 1)
  {
    //std::cout << "Expressions: " << expressions << std::endl;
    int bestResult = expressions.getValue(expressions.getBestResult(target));
    if (expressions.containTargetValue(target))
      return true;

    std::vector<Operation> candidateOperations;
    
    /*
    ** Enumerate possible operations
    */
    {
      typedef std::pair<int, int> ValuePair;
      std::set<ValuePair> markedValuePairs;
      for (size_t i = 0; i < expressions.size(); ++i)
        for (size_t j = 0; j < expressions.size(); ++j)
        {
          if (i == j)
            continue;
          ValuePair valuePair(expressions.getValue(i), expressions.getValue(j));
          if (markedValuePairs.find(valuePair) != markedValuePairs.end())
            continue;

          markedValuePairs.insert(valuePair);
          if (valuePair.first < valuePair.second)
            continue;
            
          candidateOperations.push_back(Operation(Operation::plus, i, j));
          candidateOperations.push_back(Operation(Operation::times, i, j));
          if (valuePair.first > valuePair.second)
            candidateOperations.push_back(Operation(Operation::minus, i, j));
          if (isMultipleOf(valuePair.first, valuePair.second))
            candidateOperations.push_back(Operation(Operation::divide, i, j));
        }
    }
    //std::cout << "Candidate operations: " << candidateOperations << std::endl;
    if (candidateOperations.empty())
      return false;
    
    /*
    ** Choose and apply operation
    */
    stateFunction double greedyHeuristic(const Operation& op) {
      return -1.0 * abs(target - expressions.compute(op));
    }
    
    stateFunction featureGenerator actionFeatures(const Operation& op) {
      int left = expressions.getValue(op.leftIndex);
      int right = expressions.getValue(op.rightIndex);
      int value = expressions.compute(op);
      
      featureCall("computedValue") inline valueWRTTargetFeatures(value, target);
      
      featureScope((size_t)op.operation)
      {
        featureCall("left") inline numberFeatures(left);
        featureCall("leftVsTarget") inline valueWRTTargetFeatures(left, target);
        featureCall("right") inline numberFeatures(right);
        featureCall("rightVsTarget") inline valueWRTTargetFeatures(right, target);
      }
    }
    
    stateFunction std::string operationToString(const Operation& op) {
      return cralgo::toString(expressions.getExpression(op.leftIndex)) + " " + 
        Operation::getChar(op.operation) + " " + 
        cralgo::toString(expressions.getExpression(op.rightIndex));
    }
    
    Operation operation = choose<Operation>(candidateOperations, greedyHeuristic, actionFeatures, operationToString);
    expressions.apply(operation);
  }
  
  return false;
}

cralgo::CRAlgorithmPtr sampleInstance(size_t numNumbers,
                          int minTarget = 100, int maxTarget = 999,
                          size_t chanceInfTen = 2, size_t chanceSpecial = 1)
{
  assert(maxTarget > minTarget);
  
  std::vector<int> remaining;
  remaining.reserve(10 * chanceInfTen + 4 * chanceSpecial);
  for (unsigned i = 1; i <= 10; ++i)
    for (unsigned j = 0; j < chanceInfTen; ++j)
      remaining.push_back(i);
  for (unsigned j = 0; j < chanceSpecial; ++j)
  {
    remaining.push_back(25);
    remaining.push_back(50);
    remaining.push_back(75);
    remaining.push_back(100);
  }
  
  std::vector<int> numbers(numNumbers);
  for (size_t i = 0; i < numNumbers; ++i)
  {
    int r = rand() % remaining.size();
    numbers[i] = remaining[r];
    remaining.erase(remaining.begin() + r);
  }
  int target = minTarget + rand() % (maxTarget - minTarget);
  return searchSpace(numbers, target, 2);
}

}; /* namespace lceb */

class LCeBGeneratedInstanceSet : public CRAlgorithmInstanceSet
{
public:
  size_t getCount() const
    {return (unsigned)getIntAttribute(T("count"));}
    
  size_t getNumInputs() const
    {return (unsigned)getIntAttribute(T("numInputs"), 6);}  
  
  virtual unsigned getNumInstances()
    {return getCount();}

  virtual cralgo::CRAlgorithmPtr createInstance(size_t i)
    {return lceb::sampleInstance(getNumInputs());}
};
