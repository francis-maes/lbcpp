/*
** Graph labeling CR-algorithms
*/
#include "../Data/LabeledContentGraph.cr++"

namespace cralgo
{

crAlgorithm LabelSequence indexOrderedGraphLabeling(const ContentGraph& x, const LabelDictionary& labels, const LabelSequence* ycorrect = NULL, size_t contextSize = 1)
{
  LabeledContentGraph prediction(x, LabelSequence(labels, x.getNumNodes()));
  size_t currentNode;
  
  chooseFunction featureGenerator features(size_t choice)
  {
    featureCall(labels.getLabel(choice))
      prediction.nodeFeatures(currentNode, contextSize, contextSize, false);
  }
  
  chooseFunction double optimal(size_t choice)
    {return (ycorrect && choice == (*ycorrect)[currentNode]) ? 1.0 : 0.0;}

  chooseFunction std::string choiceToString(size_t choice)
    {return labels.getLabel(choice);}

  for (currentNode = 0; currentNode < x.getNumNodes(); ++currentNode)
  {
    size_t predictedLabel = choose <size_t> (labels, optimal, features, choiceToString);
    prediction.setLabel(currentNode, predictedLabel);
    if (ycorrect && predictedLabel == (*ycorrect)[currentNode])
       reward (1.0);
  }
  
  return prediction.getLabels();
}

}; /* namespace cralgo */

class GraphLabelingCRAlgorithmInstanceSet : public CRAlgorithmInstanceSet
{
public:
  virtual cralgo::CRAlgorithmPtr createInstance(const cralgo::ContentGraph& x, const cralgo::LabelDictionary& labels, const cralgo::LabelSequence* ycorrect) = 0;

  virtual unsigned getNumInstances()
    {return graphs.size();}
  
  virtual cralgo::CRAlgorithmPtr createInstance(size_t i)
  {
    assert(i < graphs.size());
    const cralgo::LabeledContentGraph& g = graphs[i];
    return createInstance(g.getGraph(), g.getDictionary(), g.hasLabels() ? &g.getLabels() : NULL);
  }
  
  virtual void updateFrame()
  {
    CRAlgorithmInstanceSet::updateFrame();
    learning::InstanceSetPtr target = getFrameAttributeCast<learning::InstanceSet>(T("graphs"));
    if (target && !graphs.size())
    {
      LabelSetPtr niemeLabels = LabelSet::getLabels(target);
      for (size_t i = 0; i < niemeLabels->getNumLabels(); ++i)
        labels.add((const char* )niemeLabels->getLabelString(i));

      for (unsigned i = 0; i < target->getNumInstances(); ++i)
      {
        representation::FramePtr f = target->open(i);
        GraphLabelingExamplePtr niemeGraph = boost::dynamic_pointer_cast<GraphLabelingExample>(f);
        if (niemeGraph)
          graphs.push_back(convertGraph(niemeGraph));
        target->close(i, f);
      }
    }
  }
  
private:
  cralgo::LabelDictionary labels;
  std::vector<cralgo::LabeledContentGraph> graphs;
  
  cralgo::LabeledContentGraph convertGraph(GraphLabelingExamplePtr niemeGraph)
  {
    cralgo::LabeledContentGraph res(labels);
    res.reserveNodes(niemeGraph->getNumNodes());
    
    GraphConceptPtr niemeContentGraph = niemeGraph->getInputGraph();
    for (size_t i = 0; i < niemeGraph->getNumNodes(); ++i)
    {
      IntConceptPtr predictedLabel = castFrame<IntConcept>(niemeGraph->getOutputLabels()->get(i));
      res.addNode(niemeConceptFeatures(niemeContentGraph->getNode(i)),
        (size_t)(predictedLabel ? predictedLabel->get() : labels.getNumLabels()));
    }
    
    for (size_t i = 0; i < niemeGraph->getNumNodes(); ++i)
      for (size_t j = 0; j < niemeContentGraph->getNumSuccessors(i); ++j)
      {
        size_t successor = niemeContentGraph->getSuccessor(i, j);
        res.getGraph().addLink(i, successor);
      }
      
    return res;
  }
};

class IndexOrderedGraphLabelingInstanceSet : public GraphLabelingCRAlgorithmInstanceSet
{
public:
  virtual cralgo::CRAlgorithmPtr createInstance(const cralgo::ContentGraph& x, const cralgo::LabelDictionary& labels, const cralgo::LabelSequence* ycorrect)
    {return cralgo::indexOrderedGraphLabeling(x, labels, ycorrect);}
};
