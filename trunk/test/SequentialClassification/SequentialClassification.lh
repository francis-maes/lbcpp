/*-----------------------------------------.---------------------------------.
| Filename: SequentialClassification.lh    | Sequential Classification       |
| Author  : Francis Maes                   |    CR-algorithm                 |
| Started : 15/03/2009 20:11               |                                 |
`------------------------------------------/                                 |
                               |                                             |
                               `--------------------------------------------*/
                               
using namespace cralgo;

namespace cralgo
{
  std::string toString(std::set<size_t>::const_iterator it)
    {return "iterator";}
};

featureGenerator unit() {featureScope("unit") featureSense(0);}

featureGenerator describeUsedFeatureGenerators(const std::vector<SparseVectorPtr>& usedFeatureGenerators)
{
  featureSense("unit");
  for (int i = 0; i < (int)usedFeatureGenerators.size(); ++i)
    featureCall((size_t)(usedFeatureGenerators.size() - 1 - i)) usedFeatureGenerators[i];    
}

crAlgorithm size_t sequentialClassification(const std::vector<FeatureGeneratorPtr>& featureGenerators, double featureCosts, size_t numClasses, size_t* ycorrect = NULL)
{
  typedef std::pair<bool, size_t> Choice; // decision: (true, classNumber), feature-request: (false, featureScopeNumber)
  
  std::set<size_t> unusedFeatureGenerators;
  for (size_t i = 0; i < featureGenerators.size(); ++i)
  {
    unusedFeatureGenerators.insert(i);
    //currentRepresentation->setSubVector(i, unit()->toSparseVector());
  }
  std::vector<SparseVectorPtr> usedFeatureGenerators;
  
  for (size_t step = 0; true; ++step)
  {
    std::vector<Choice> choices;
    {
      choices.reserve(unusedFeatureGenerators.size() + numClasses);
      for (std::set<size_t>::const_iterator it = unusedFeatureGenerators.begin(); it != unusedFeatureGenerators.end(); ++it)
        choices.push_back(Choice(false, *it));
      for (size_t i = 0; i < numClasses; ++i)
        choices.push_back(Choice(true, i));
    }
    
    chooseFunction double actionValues(const Choice& choice)
    {
      if (choice.first)
      {
        // decision: -1 for classification error
        // 0 otherwise
        return ycorrect && choice.second != *ycorrect ? -1 : 0;
      }
      else
      {
        // feature-request: feature-cost
          return -featureCosts;
      }
    }
    
    chooseFunction featureGenerator actionFeatures(const Choice& choice)
    {
      featureScope(step)
        if (choice.first)
        {
          featureScope("decision")
            featureCall(choice.second)
              inline describeUsedFeatureGenerators(usedFeatureGenerators);
        }
        else
        {
          featureScope("feature-request")
            featureCall(choice.second)
              inline describeUsedFeatureGenerators(usedFeatureGenerators);
        }
    }
    
    Choice c = choose<Choice>(choices, actionValues, actionFeatures);
    
    if (c.first)
    {
      if (ycorrect && c.second != *ycorrect) // reward -1 for a classification error
        reward (-1.0);
      return c.second;
    }
    else
    {
      SparseVectorPtr newFeatures;

      unusedFeatureGenerators.erase(c.second);
      assert(c.second < featureGenerators.size());
      assert(featureGenerators[c.second]);
      newFeatures = featureGenerators[c.second]->toSparseVector();
      assert(newFeatures);
      usedFeatureGenerators.push_back(newFeatures);
      reward (-featureCosts);
    }
  }
  return 0;
}
