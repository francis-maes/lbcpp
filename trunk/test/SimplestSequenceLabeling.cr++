#include <iostream>
#include <fstream>

namespace cralgo
{

struct SizeRange
{
  SizeRange(size_t begin, size_t end)
    : begin(begin), end(end) {}
  SizeRange(size_t end)
    : begin(0), end(end) {}
    
  size_t begin, end;
};

template<>
struct Traits< SizeRange > 
  : public DefaultContainerTraits< Traits<SizeRange>, SizeRange, size_t, size_t >
{
  static size_t size(const SizeRange& range)
    {return range.end - range.begin;}

  static size_t begin(const SizeRange& range)
    {return range.begin;}

  static size_t end(const SizeRange& range)
    {return range.end;}
  
  static const size_t& value(const size_t& iterator)
    {return iterator;}

  static std::string toString(const SizeRange& range)
    {return "[" + cralgo::toString(range.begin) + ", " + cralgo::toString(range.end) + "[";}
    
  static void write(std::ostream& ostr, const SizeRange& range)
    {cralgo::write(ostr, range.begin); cralgo::write(ostr, range.end);}
    
  static bool read(std::istream& istr, const SizeRange& range)
    {return cralgo::read(istr, range.begin) && cralgo::read(istr, range.end);}
};

crAlgorithm std::vector<size_t> simplestSequenceLabeling(const std::vector<FeatureGeneratorPtr>& x, size_t numLabels, const std::vector<size_t>* y = NULL)
{
  std::vector<size_t> res(x.size(), numLabels);
  SizeRange range(numLabels);
  
  for (size_t i = 0; i < x.size(); ++i)
  {
    stateFunction featureGenerator stateFeatures() {
      featureCall("content") x[i];
      if (i > 0)
        featureSense("previous", res[i - 1]);
    }
    
    stateFunction featureGenerator actionFeatures(size_t label) {
      featureScope(label) {
        featureCall("content") x[i];
        if (i > 0)
          featureSense("previous", res[i - 1]);
      }
    }
    
    stateFunction double actionValues(size_t label) {
      return y && (*y)[i] == label;
    }

    res[i] = choose<size_t>(range, stateFeatures, actionFeatures, actionValues);
    if (y && (*y)[i] == res[i])
      reward(1.0);
  }
  return res;
}

class SequenceExample : public LearningExample
{
public:
  SequenceExample(const std::vector<FeatureGeneratorPtr>& x, const std::vector<size_t>& y)
    : x(x), y(y) {}
    
  const std::vector<FeatureGeneratorPtr>& getContent() const
    {return x;}
  
  const std::vector<size_t>& getLabels() const
    {return y;}
    
private:
  std::vector<FeatureGeneratorPtr> x;
  std::vector<size_t> y;
};

class SequenceExamplesParser : public LearningExamplesParser
{
public:
  SequenceExamplesParser(std::vector<SequenceExample>& target, FeatureDictionary& labels)
    : target(target), labels(labels) {}
    
  std::vector<SequenceExample>& target;
  FeatureDictionary& labels;

  virtual void parseBegin()
  {
    currentContent.clear();
    currentLabels.clear();
  }

  virtual bool parseDataLine(const std::vector<std::string>& columns)
  {
    assert(columns.size());
    std::string label;
    if (!parse(columns[0], label))
      return false;
    SparseVectorPtr features;
    if (!parseFeatureList(columns, 1, features))
      return false;
    currentContent.push_back(features);
    currentLabels.push_back(labels.getFeatures().add(label));
    return true;
  }

  virtual bool parseEmptyLine()
  {
    if (currentContent.size())
    {
      target.push_back(SequenceExample(currentContent, currentLabels));
      currentContent.clear();
      currentLabels.clear();
    }
    return true;
  }
  
private:
  std::vector<FeatureGeneratorPtr> currentContent;
  std::vector<size_t> currentLabels;
};

}; /* namespace cralgo */

using namespace cralgo;

void runPolicy(PolicyPtr policy, const std::vector<SequenceExample>& examples, size_t numLabels)
{
  for (size_t i = 0; i < 5; ++i) //examples.size(); ++i)
  {
    const SequenceExample& sequence = examples[i];
    simplestSequenceLabeling(policy, sequence.getContent(), numLabels, &sequence.getLabels());
  }
  std::cout << "==> " << policy->toString() << std::endl;
}

void testClassifier(const std::vector<SequenceExample>& learningExamples, FeatureDictionary& labels)
{
  IterationFunctionPtr learningRate = IterationFunction::createConstant(0.01);

  GradientBasedClassifierPtr classifier = GradientBasedClassifier::createMaximumEntropy(
    GradientBasedLearner::createGradientDescent(learningRate), labels);
  
  PolicyPtr learnedPolicy = Policy::createGreedy(ActionValueFunction::createClassifierScores(classifier));
  
  PolicyPtr learnerPolicy =
    Policy::createClassificationExampleCreator(learnedPolicy, classifier)->addComputeStatistics();
  
  std::cout << "RANDOM: " << std::endl;
  runPolicy(Policy::createRandom()->addComputeStatistics(), learningExamples, labels.getNumFeatures());
  
  for (size_t i = 0; i < 10; ++i)
  {
    std::cout << "ITERATION: " << (i+1) << std::endl;
    runPolicy(learnerPolicy, learningExamples, labels.getNumFeatures());
  }
}

void testSarsa(const std::vector<SequenceExample>& learningExamples, FeatureDictionary& labels)
{
  IterationFunctionPtr learningRate = IterationFunction::createConstant(0.01);
  IterationFunctionPtr epsilon = IterationFunction::createConstant(0.1);

  GradientBasedRegressorPtr regressor = GradientBasedRegressor::createLeastSquaresLinear(
    GradientBasedLearner::createGradientDescent(learningRate));
  
  PolicyPtr learnedPolicy = Policy::createGreedy(ActionValueFunction::createRegressorPredictions(regressor));
  
  PolicyPtr learnerPolicy = Policy::createSarsaZero(learnedPolicy->epsilonGreedy(epsilon), regressor, 0.0)->addComputeStatistics();
  
  std::cout << "RANDOM: " << std::endl;
  runPolicy(Policy::createRandom()->addComputeStatistics()->verbose(std::cout, 1), learningExamples, labels.getNumFeatures());
  
  for (size_t i = 0; i < 1; ++i)
  {
    std::cout << "ITERATION: " << (i+1) << std::endl;
    runPolicy(learnerPolicy->verbose(std::cout, 1), learningExamples, labels.getNumFeatures());
    std::cout << "Params: " << regressor->getParameters()->toString() << std::endl;
  }
  

}

int main(int argc, char* argv[])
{
  static const char* filename = 
    "/Users/francis/Projets/Francis/NiemeTrunk/src/problems/sequences/experiments/test.smousse";

  std::ifstream istr(filename);
  if (!istr.is_open())
  {
    std::cerr << "Could not open file " << filename << std::endl;
    return 1;
  }

  
  FeatureDictionary features("myFeatures");
  FeatureDictionary labels("myLabels");

  std::vector<SequenceExample> learningExamples;
  SequenceExamplesParser parser(learningExamples, labels);
  parser.parse(istr, features);
  std::cout << learningExamples.size() << " sequences, " << labels.getNumFeatures()
    << " labels, " << features.getNumFeatures() << " features." << std::endl;

  
/*  const SequenceExample& sequence = learningExamples[0];
  CRAlgorithmPtr cralgo = simplestSequenceLabeling(sequence.getContent(), labels.getNumFeatures(), &sequence.getLabels());
  ChoosePtr choose = cralgo->runUntilFirstChoose();
  choose = cralgo->runUntilNextChoose(choose->sampleRandomChoice());
  std::cout << "Choose: " << choose->toString() << std::endl;
  std::cout << "State: " << cralgo->toString() << std::endl;
  std::cout << "State description: " << choose->stateFeatures()->toString() << std::endl;
  std::cout << "First action description: " << choose->actionFeatures(choose->newIterator()->get())->toString() << std::endl;*/
  
  testSarsa(learningExamples, labels);
  //testClassifier(learningExamples, labels);
  return 0;
}
