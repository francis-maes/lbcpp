#include <iostream>
#include <fstream>

namespace cralgo
{

struct SizeRange
{
  SizeRange(size_t begin, size_t end)
    : begin(begin), end(end) {}
  SizeRange(size_t end)
    : begin(0), end(end) {}
    
  size_t begin, end;
};

template<>
struct Traits< SizeRange > 
  : public DefaultContainerTraits< Traits<SizeRange>, SizeRange, size_t, size_t >
{
  static size_t size(const SizeRange& range)
    {return range.end - range.begin;}

  static size_t begin(const SizeRange& range)
    {return range.begin;}

  static size_t end(const SizeRange& range)
    {return range.end;}
  
  static const size_t& value(const size_t& iterator)
    {return iterator;}

  static std::string toString(const SizeRange& range)
    {return "[" + cralgo::toString(range.begin) + ", " + cralgo::toString(range.end) + "[";}
    
  static void write(std::ostream& ostr, const SizeRange& range)
    {cralgo::write(ostr, range.begin); cralgo::write(ostr, range.end);}
    
  static bool read(std::istream& istr, const SizeRange& range)
    {return cralgo::read(istr, range.begin) && cralgo::read(istr, range.end);}
};

crAlgorithm std::vector<size_t> simplestSequenceLabeling(const std::vector<FeatureGeneratorPtr>& x, size_t numLabels, const std::vector<size_t>* y = NULL)
{
  std::vector<size_t> res(x.size(), numLabels);
  SizeRange range(numLabels);
  
  for (size_t i = 0; i < x.size(); ++i)
  {
    stateFunction featureGenerator actionFeatures(size_t label) {
      featureScope(label) {
        featureCall("content") x[i];
        if (i > 0)
          featureSense("previous", res[i - 1]);
      }
    }
    
    stateFunction double actionValues(size_t label) {
      return y && (*y)[i] == label;
    }

    res[i] = choose<size_t>(range, actionFeatures, actionValues);
    if (y && (*y)[i] == res[i])
      reward(1.0);
  }
  return res;
}

class SequenceExample : public LearningExample
{
public:
  SequenceExample(const std::vector<FeatureGeneratorPtr>& x, const std::vector<size_t>& y)
    : x(x), y(y) {}
    
  const std::vector<FeatureGeneratorPtr>& getContent() const
    {return x;}
  
  const std::vector<size_t>& getLabels() const
    {return y;}
    
private:
  std::vector<FeatureGeneratorPtr> x;
  std::vector<size_t> y;
};

class SequenceExamplesParser : public LearningExamplesParser
{
public:
  SequenceExamplesParser(std::vector<SequenceExample>& target, FeatureDictionary& labels)
    : target(target), labels(labels) {}
    
  std::vector<SequenceExample>& target;
  FeatureDictionary& labels;

  virtual void parseBegin()
  {
    currentContent.clear();
    currentLabels.clear();
  }

  virtual bool parseDataLine(const std::vector<std::string>& columns)
  {
    assert(columns.size());
    std::string label;
    if (!parse(columns[0], label))
      return false;
    SparseVectorPtr features;
    if (!parseFeatureList(columns, 1, features))
      return false;
    currentContent.push_back(features);
    currentLabels.push_back(labels.getFeatures().add(label));
    return true;
  }

  virtual bool parseEmptyLine()
  {
    if (currentContent.size())
    {
      target.push_back(SequenceExample(currentContent, currentLabels));
      currentContent.clear();
      currentLabels.clear();
    }
    return true;
  }
  
private:
  std::vector<FeatureGeneratorPtr> currentContent;
  std::vector<size_t> currentLabels;
};

}; /* namespace cralgo */

using namespace cralgo;

int main(int argc, char* argv[])
{
  static const char* filename = 
    "/Users/francis/Projets/Francis/NiemeTrunk/src/problems/sequences/experiments/test.smousse";

  std::ifstream istr(filename);
  if (!istr.is_open())
  {
    std::cerr << "Could not open file " << filename << std::endl;
    return 1;
  }

  IterationFunctionPtr learningRate = IterationFunction::createConstant(0.01);
  
  FeatureDictionary features("myFeatures");
  FeatureDictionary labels("myLabels");

  std::vector<SequenceExample> learningExamples;
  SequenceExamplesParser parser(learningExamples, labels);
  parser.parse(istr, features);
  std::cout << learningExamples.size() << " sequences, " << labels.getNumFeatures()
    << " labels, " << features.getNumFeatures() << " features." << std::endl;
  
  GradientBasedClassifierPtr classifier = GradientBasedClassifier::createMaximumEntropy(
    GradientBasedLearner::createGradientDescent(learningRate), labels);
  
  PolicyPtr policy = Policy::createClassificationExampleCreator(Policy::createRandom(), classifier);
  policy = policy->addComputeStatistics();
  
//  PolicyPtr policy = Policy::createRandom()->addComputeStatistics();  
  for (size_t i = 0; i < learningExamples.size(); ++i)
  {
    SequenceExample& sequence = learningExamples[i];
    std::vector<size_t> prediction = simplestSequenceLabeling(policy, sequence.getContent(), labels.getNumFeatures(), &sequence.getLabels());
//    std::cout << "Prediction " << i << " : " << toString(prediction) << std::endl;
  }
  std::cout << toString(policy) << std::endl;
  
/*  for (size_t i = 0; i < learningExamples.size(); ++i)
  {
    SequenceExample& sequence = learningExamples[i];
    simplestSequenceLabeling(policy, sequence.getContent(), labels.getNumFeatures(), &sequence.getLabels());
  */
  return 0;
}
