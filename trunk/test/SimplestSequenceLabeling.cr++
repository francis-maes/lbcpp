#include <iostream>
#include <fstream>
using namespace lbcpp;

crAlgorithm std::vector<size_t> simplestSequenceLabeling(const std::vector<FeatureGeneratorPtr>& x, size_t numLabels, const std::vector<size_t>* y = NULL)
{
  std::vector<size_t> res(x.size(), numLabels);
  SizeRange range(numLabels);
  
  for (size_t i = 0; i < x.size(); ++i)
  {
    chooseFunction featureGenerator stateFeatures() {
      featureCall(0) x[i];
      if (i > 0)
        featureScope(1) featureSense(res[i - 1]);
    }
    
    chooseFunction featureGenerator actionFeatures(size_t label) {
      featureScope(label) {
        featureCall(0) x[i];
        if (i > 0)
          featureScope(1) featureSense(res[i - 1]);
      }
    }
    
    chooseFunction double actionValues(size_t label) {
      return y && (*y)[i] == label ? 1.0 : 0.0;
    }

    res[i] = choose<size_t>(range, stateFeatures, actionFeatures, actionValues);
    if (y && (*y)[i] == res[i])
      reward(1.0);
  }
  return res;
}

class SequenceExample : public LearningExample
{
public:
  SequenceExample(const std::vector<FeatureGeneratorPtr>& x, const std::vector<size_t>& y)
    : x(x), y(y) {}
    
  const std::vector<FeatureGeneratorPtr>& getContent() const
    {return x;}
  
  const std::vector<size_t>& getLabels() const
    {return y;}
    
private:
  std::vector<FeatureGeneratorPtr> x;
  std::vector<size_t> y;
};
typedef ReferenceCountedObjectPtr<SequenceExample> SequenceExamplePtr;

class SequenceExamplesParser : public LearningDataObjectParser
{
public:
  SequenceExamplesParser(const std::string& filename, FeatureDictionaryPtr features, StringDictionaryPtr labels)
    : LearningDataObjectParser(filename, features), labels(labels) {}
    
  StringDictionaryPtr labels;

  virtual void parseBegin()
  {
    currentContent.clear();
    currentLabels.clear();
  }

  virtual bool parseDataLine(const std::vector<std::string>& columns)
  {
    assert(columns.size());
    std::string label;
    if (!TextObjectParser::parse(columns[0], label))
      return false;
    SparseVectorPtr features;
    if (!parseFeatureList(columns, 1, features))
      return false;
    currentContent.push_back(features);
    currentLabels.push_back(labels->add(label));
    return true;
  }

  virtual bool parseEmptyLine()
  {
    if (currentContent.size())
    {
      setResult(new SequenceExample(currentContent, currentLabels));
      currentContent.clear();
      currentLabels.clear();
    }
    return true;
  }
  
private:
  std::vector<FeatureGeneratorPtr> currentContent;
  std::vector<size_t> currentLabels;
};

class SequenceToCRAlgorithmInstance : public ObjectFunction
{
public:
  SequenceToCRAlgorithmInstance(size_t numLabels) : numLabels(numLabels) {}
  
  virtual std::string getOutputClassName() const
    {return "CRAlgorithm";}
    
  virtual ObjectPtr function(ObjectPtr object) const
  {
    SequenceExamplePtr example = object.dynamicCast<SequenceExample>();
    assert(example);
    return simplestSequenceLabeling(example->getContent(), numLabels, &example->getLabels());
  }
  
private:
  size_t numLabels;  
};



void runPolicy(PolicyPtr policy, ObjectContainerPtr examples, size_t numLabels)
{
  for (size_t i = 0; i < examples->size(); ++i)
  {
    SequenceExamplePtr sequence = examples->getAndCast<SequenceExample>(i);
    simplestSequenceLabeling(policy, sequence->getContent(), numLabels, &sequence->getLabels());
  }
  std::cout << "==> " << policy->toString() << std::endl;
}

void testClassifier(ObjectContainerPtr learningExamples, StringDictionaryPtr labels)
{
  IterationFunctionPtr learningRate = constantIterationFunction(1.0);//InvLinear(26, 10000);

  GradientBasedClassifierPtr classifier = maximumEntropyClassifier(
        stochasticDescentLearner(learningRate), labels);
  
  PolicyPtr learnedPolicy = greedyPolicy(predictedActionValues(classifier));
  
  PolicyPtr learnerPolicy = classificationExampleCreatorPolicy(learnedPolicy, classifier)->addComputeStatistics();
  
  std::cout << "RANDOM: " << std::endl;
  randomPolicy()->addComputeStatistics()->run(learningExamples);
  
  for (size_t i = 0; i < 15; ++i)
  {
    std::cout << "ITERATION: " << (i+1) << std::endl;
    learnerPolicy->run(learningExamples);
  }
}

void testCRank(ObjectContainerPtr learningExamples)
{
  IterationFunctionPtr learningRate = invLinearIterationFunction(10, 10000);

  RankerPtr ranker = largeMarginAllPairsLinearRanker(stochasticDescentLearner(learningRate));
    //largeMarginBestAgainstAllLinearRanker
    //largeMarginMostViolatedPairLinearRanker
  
  PolicyPtr learnedPolicy = greedyPolicy(predictedActionValues(ranker));  
  PolicyPtr learnerPolicy = rankingExampleCreatorPolicy(learnedPolicy, ranker);

  for (size_t i = 0; i < 5; ++i)
  {
    std::cout << "ITERATION: " << (i+1) << std::endl;
    learnerPolicy->verbose(0)->addComputeStatistics()->run(learningExamples);
 //   std::cout << "Params: " << regressor->getParameters()->toString() << std::endl;
  }
}

void testSarsa(ObjectContainerPtr learningExamples)
{
  IterationFunctionPtr learningRate = constantIterationFunction(0.01);
  IterationFunctionPtr epsilon = constantIterationFunction(0.1);

  GradientBasedRegressorPtr regressor = leastSquaresLinearRegressor(stochasticDescentLearner(learningRate));
  
  PolicyPtr learnedPolicy = greedyPolicy(predictedActionValues(regressor));
  
  PolicyPtr learnerPolicy = sarsaZeroPolicy(epsilonGreedyPolicy(learnedPolicy, epsilon), regressor, 0.0)->addComputeStatistics();
  
  PolicyPtr p = randomPolicy()->addComputeStatistics()->verbose(0);
  p->run(learningExamples);
  std::cout << "RANDOM: " << p->toString() << std::endl;
  
  for (size_t i = 0; i < 15; ++i)
  {
    learnerPolicy->verbose(0)->run(learningExamples);
    std::cout << "ITERATION: " << (i+1) << " " << learnerPolicy->toString() << std::endl;
 //   std::cout << "Params: " << regressor->getParameters()->toString() << std::endl;
  }
}
/*
crAlgorithm void testTrivial()
{
  size_t c;
  std::vector<size_t> choices;
  choices.push_back(0);
  choices.push_back(1);
  
  chooseFunction featureGenerator features(size_t b) {
    featureSense(b);
  }
  
  c = choose<size_t>(choices, features);
  std::cout << "CHOICE = " << lbcpp::toString(c) << std::endl;
  if (c)
    reward (1.0);
}*/

void testOLPOMDP(ObjectContainerPtr learningExamples)
{
  IterationFunctionPtr learningRate = invLinearIterationFunction(0.1, 10000);

  GeneralizedClassifierPtr classifier = linearGeneralizedClassifier(stochasticDescentLearner(learningRate));
  
  PolicyPtr learnedPolicy = greedyPolicy(predictedActionValues(classifier));  
  PolicyPtr learnerPolicy = gpomdpPolicy(classifier, 0, 2.0);

  for (size_t i = 0; i < 10; ++i)
  {
    std::cout << "ITERATION: " << (i+1) << std::endl;
    PolicyPtr p = learnerPolicy->addComputeStatistics()->verbose(0);
  //  testTrivial(p);
//    std::cout << p->toString() << std::endl;
    p->run(learningExamples);
 //   std::cout << "Params: " << regressor->getParameters()->toString() << std::endl;
  }
}


int main(int argc, char* argv[])
{
  static const char* filename = 
    "/Users/francis/Projets/Francis/NiemeTrunk/src/problems/sequences/experiments/test.smousse";

  FeatureDictionaryPtr features = new FeatureDictionary("myFeatures");
  StringDictionaryPtr labels = new StringDictionary();

  ObjectContainerPtr learningExamples = (new SequenceExamplesParser(filename, features, labels))->load();
  ObjectContainerPtr crAlgorithms = learningExamples->apply(new SequenceToCRAlgorithmInstance(labels->getNumElements()), false);
  
  std::cout << crAlgorithms->size() << " sequences, " << labels->getNumElements()
    << " labels, " << features->getNumFeatures() << " features." << std::endl;
  
  CRAlgorithmLearnerPtr searn = searnLearner();
  searn->trainBatch(crAlgorithms, consoleProgressCallback());
  PolicyPtr policy = searn->getPolicy()->addComputeStatistics();

  policy->run(crAlgorithms);
  std::cout << "RESULT => " << policy->toString() << std::endl;

//  std::cout << " === SARSA === " << std::endl;
//  testSarsa(crAlgorithms);
//  std::cout << " === CLASSIFIER === " << std::endl;
//  testClassifier(crAlgorithms);
//  std::cout << " === RANKING === " << std::endl;
//  testCRank(crAlgorithms);
  
 // std::cout << " === OLPOMDP === " << std::endl;
 // testOLPOMDP(crAlgorithms);
  return 0;
}
