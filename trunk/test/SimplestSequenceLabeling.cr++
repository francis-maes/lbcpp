#include <iostream>
#include <fstream>

namespace lbcpp
{

crAlgorithm std::vector<size_t> simplestSequenceLabeling(const std::vector<FeatureGeneratorPtr>& x, size_t numLabels, const std::vector<size_t>* y = NULL)
{
  std::vector<size_t> res(x.size(), numLabels);
  SizeRange range(numLabels);
  
  for (size_t i = 0; i < x.size(); ++i)
  {
    chooseFunction featureGenerator stateFeatures() {
      featureCall(0) x[i];
      if (i > 0)
        featureScope(1) featureSense(res[i - 1]);
    }
    
    chooseFunction featureGenerator actionFeatures(size_t label) {
      featureScope(label) {
        featureCall(0) x[i];
        if (i > 0)
          featureScope(1) featureSense(res[i - 1]);
      }
    }
    
    chooseFunction double actionValues(size_t label) {
      return y && (*y)[i] == label ? 1.0 : 0.0;
    }

    res[i] = choose<size_t>(range, stateFeatures, actionFeatures, actionValues);
    if (y && (*y)[i] == res[i])
      reward(1.0);
  }
  return res;
}

class SequenceExample : public LearningExample
{
public:
  SequenceExample(const std::vector<FeatureGeneratorPtr>& x, const std::vector<size_t>& y)
    : x(x), y(y) {}
    
  const std::vector<FeatureGeneratorPtr>& getContent() const
    {return x;}
  
  const std::vector<size_t>& getLabels() const
    {return y;}
    
private:
  std::vector<FeatureGeneratorPtr> x;
  std::vector<size_t> y;
};
typedef ReferenceCountedObjectPtr<SequenceExample> SequenceExamplePtr;

class SequenceExamplesParser : public LearningDataObjectParser
{
public:
  SequenceExamplesParser(const std::string& filename, FeatureDictionaryPtr features, StringDictionaryPtr labels)
    : LearningDataObjectParser(filename, features), labels(labels) {}
    
  StringDictionaryPtr labels;

  virtual void parseBegin()
  {
    currentContent.clear();
    currentLabels.clear();
  }

  virtual bool parseDataLine(const std::vector<std::string>& columns)
  {
    assert(columns.size());
    std::string label;
    if (!TextObjectParser::parse(columns[0], label))
      return false;
    SparseVectorPtr features;
    if (!parseFeatureList(columns, 1, features))
      return false;
    currentContent.push_back(features);
    currentLabels.push_back(labels->add(label));
    return true;
  }

  virtual bool parseEmptyLine()
  {
    if (currentContent.size())
    {
      setResult(new SequenceExample(currentContent, currentLabels));
      currentContent.clear();
      currentLabels.clear();
    }
    return true;
  }
  
private:
  std::vector<FeatureGeneratorPtr> currentContent;
  std::vector<size_t> currentLabels;
};

}; /* namespace lbcpp */

using namespace lbcpp;

void runPolicy(PolicyPtr policy, ObjectContainerPtr examples, size_t numLabels)
{
  for (size_t i = 0; i < examples->size(); ++i)
  {
    SequenceExamplePtr sequence = examples->getCast<SequenceExample>(i);
    simplestSequenceLabeling(policy, sequence->getContent(), numLabels, &sequence->getLabels());
  }
  std::cout << "==> " << policy->toString() << std::endl;
}

void testClassifier(ObjectContainerPtr learningExamples, StringDictionaryPtr labels)
{
  IterationFunctionPtr learningRate = constantIterationFunction(1.0);//InvLinear(26, 10000);

  GradientBasedClassifierPtr classifier = maximumEntropyClassifier(
        stochasticDescentLearner(learningRate), labels);
  
  PolicyPtr learnedPolicy = Policy::createGreedy(ActionValueFunction::createScores(classifier));
  
  PolicyPtr learnerPolicy =
    Policy::createClassificationExampleCreator(learnedPolicy, classifier)->addComputeStatistics();
  
  std::cout << "RANDOM: " << std::endl;
  runPolicy(Policy::createRandom()->addComputeStatistics(), learningExamples, labels->getNumElements());
  
  for (size_t i = 0; i < 15; ++i)
  {
    std::cout << "ITERATION: " << (i+1) << std::endl;
    runPolicy(learnerPolicy, learningExamples, labels->getNumElements());
  }
}

void testCRank(ObjectContainerPtr learningExamples, StringDictionaryPtr labels)
{
  IterationFunctionPtr learningRate = invLinearIterationFunction(10, 10000);

  RankerPtr ranker = largeMarginAllPairsLinearRanker(stochasticDescentLearner(learningRate));
    //largeMarginBestAgainstAllLinearRanker
    //largeMarginMostViolatedPairLinearRanker
  
  PolicyPtr learnedPolicy = Policy::createGreedy(ActionValueFunction::createPredictions(ranker));  
  PolicyPtr learnerPolicy = Policy::createRankingExampleCreator(learnedPolicy, ranker);

  for (size_t i = 0; i < 5; ++i)
  {
    std::cout << "ITERATION: " << (i+1) << std::endl;
    runPolicy(learnerPolicy->verbose(0)->addComputeStatistics(), learningExamples, labels->getNumElements());
 //   std::cout << "Params: " << regressor->getParameters()->toString() << std::endl;
  }
}

void testSarsa(ObjectContainerPtr learningExamples, StringDictionaryPtr labels)
{
  IterationFunctionPtr learningRate = constantIterationFunction(0.01);
  IterationFunctionPtr epsilon = constantIterationFunction(0.1);

  GradientBasedRegressorPtr regressor = leastSquaresLinearRegressor(stochasticDescentLearner(learningRate));
  
  PolicyPtr learnedPolicy = Policy::createGreedy(ActionValueFunction::createPredictions(regressor));
  
  PolicyPtr learnerPolicy = Policy::createSarsaZero(learnedPolicy->epsilonGreedy(epsilon), regressor, 0.0)->addComputeStatistics();
  
  std::cout << "RANDOM: " << std::endl;
  runPolicy(Policy::createRandom()->addComputeStatistics()->verbose(0), learningExamples, labels->getNumElements());
  
  for (size_t i = 0; i < 15; ++i)
  {
    std::cout << "ITERATION: " << (i+1) << std::endl;
    runPolicy(learnerPolicy->verbose(0), learningExamples, labels->getNumElements());
 //   std::cout << "Params: " << regressor->getParameters()->toString() << std::endl;
  }
}
/*
crAlgorithm void testTrivial()
{
  size_t c;
  std::vector<size_t> choices;
  choices.push_back(0);
  choices.push_back(1);
  
  chooseFunction featureGenerator features(size_t b) {
    featureSense(b);
  }
  
  c = choose<size_t>(choices, features);
  std::cout << "CHOICE = " << lbcpp::toString(c) << std::endl;
  if (c)
    reward (1.0);
}*/

void testOLPOMDP(ObjectContainerPtr learningExamples, StringDictionaryPtr labels)
{
  IterationFunctionPtr learningRate = invLinearIterationFunction(0.1, 10000);

  GeneralizedClassifierPtr classifier = linearGeneralizedClassifier(stochasticDescentLearner(learningRate));
  
  PolicyPtr learnedPolicy = Policy::createGreedy(ActionValueFunction::createScores(classifier));  
  PolicyPtr learnerPolicy = Policy::createGPOMDP(classifier, 0, 2.0);

  for (size_t i = 0; i < 10; ++i)
  {
    std::cout << "ITERATION: " << (i+1) << std::endl;
    PolicyPtr p = learnerPolicy->addComputeStatistics()->verbose(0);
  //  testTrivial(p);
//    std::cout << p->toString() << std::endl;
    runPolicy(p, learningExamples, labels->getNumElements());
 //   std::cout << "Params: " << regressor->getParameters()->toString() << std::endl;
  }
}


int main(int argc, char* argv[])
{
  static const char* filename = 
    "/Users/francis/Projets/Francis/NiemeTrunk/src/problems/sequences/experiments/test.smousse";

  FeatureDictionaryPtr features = new FeatureDictionary("myFeatures");
  StringDictionaryPtr labels = new StringDictionary();

  ObjectContainerPtr learningExamples = (new SequenceExamplesParser(filename, features, labels))->load();
  std::cout << learningExamples->size() << " sequences, " << labels->getNumElements()
    << " labels, " << features->getNumFeatures() << " features." << std::endl;

  
/*  const SequenceExample& sequence = learningExamples[0];
  CRAlgorithmPtr lbcpp = simplestSequenceLabeling(sequence.getContent(), labels->getNumFeatures(), &sequence.getLabels());
  ChoosePtr choose = lbcpp->runUntilFirstChoose();
  choose = lbcpp->runUntilNextChoose(choose->sampleRandomChoice());
  std::cout << "Choose: " << choose->toString() << std::endl;
  std::cout << "State: " << lbcpp->toString() << std::endl;
  std::cout << "State description: " << choose->stateFeatures()->toString() << std::endl;
  std::cout << "First action description: " << choose->actionFeatures(choose->newIterator()->get())->toString() << std::endl;*/
  
  std::cout << " === SARSA === " << std::endl;
  testSarsa(learningExamples, labels);
//  std::cout << " === CLASSIFIER === " << std::endl;
//  testClassifier(learningExamples, labels);
//  std::cout << " === RANKING === " << std::endl;
//  testCRank(learningExamples, labels);
  
 // std::cout << " === OLPOMDP === " << std::endl;
 // testOLPOMDP(learningExamples, labels);
  return 0;
}
