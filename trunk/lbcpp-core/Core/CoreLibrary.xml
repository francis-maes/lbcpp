<?xml version="1.0" encoding="UTF-8"?>

<library name="Core" directory="Core">
  <import name="CoreType" pre="yes"/>
  <import name="CoreLoader"/>

  <include file="lbcpp/Core/Pair.h"/>
  <include file="lbcpp/Core/Vector.h"/>
  <include file="lbcpp/Core/Loader.h"/>
  <include file="lbcpp/Core/XmlSerialisation.h"/>
  <include file="lbcpp/Core/Boolean.h"/>
  <include file="lbcpp/Core/Integer.h"/>
  <include file="lbcpp/Core/Double.h"/>
  <include file="lbcpp/Core/String.h"/>

  <class name="Loader" base="Object" abstract="yes"/>
  <class name="TextLoader" base="Loader" abstract="yes"/>

  <class name="Library" base="Object" abstract="yes"/>

  <!-- Builtin Types -->
  <class name="NewBoolean">
    <code>
      virtual bool isConvertibleToDouble() const
        {return true;}
    </code>
  </class>
  <class name="NewInteger">
    <code>
      virtual bool isConvertibleToDouble() const
        {return true;}
    </code>
  </class>
  <class name="NewPositiveInteger" base="NewInteger"/>
  <class name="NewEnumValue" base="NewPositiveInteger"/>
  <class name="NewDouble">
    <code>
      virtual bool isConvertibleToDouble() const
        {return true;}
    </code>
  </class>
  <class name="NewProbability" base="NewDouble"/>
  <class name="NewTime" base="NewDouble"/>
  <class name="NewString"/>
  <class name="NewFile" base="NewString"/>
  <class name="Directory" base="NewFile"/>
  
  <!-- Pair -->
  <template name="Pair" base="Object">
    <parameter name="firstType" type="Variable"/>
    <parameter name="secondType" type="Variable"/>

    <variable type="firstType" name="first"/>
    <variable type="secondType" name="second"/>
  </template>

  <!-- Container -->
  <template name="Container" base="Object" abstract="yes">
    <parameter name="elementsType"/>
  </template>
  
  <!-- Vector -->
  <template name="Vector" base="Container[elementsType]" abstract="yes">
    <parameter name="elementsType"/>
    <function lang="lua" name="resize"/>
    <function lang="lua" name="append"/>
  </template>

  <template name="ObjectVector" base="Vector[elementsType]">
    <parameter name="elementsType"/>
    <constructor arguments="TypePtr elementsType, size_t initialSize" parameters="elementsType"/>
  </template>

  <class name="BooleanVector" base="Vector[Boolean]">
    <constructor arguments="size_t initialSize"/>
  </class>

  <template name="IntegerVector" base="Vector[Integer]">
    <parameter name="elementsType"/>
    <constructor arguments="TypePtr elementsType, size_t initialSize" parameters="elementsType"/>
  </class>

  <template name="AddMissingToEnumeration" metaclass="Enumeration">
    <parameter name="enumeration" type="EnumValue"/>
    <code>
      EnumerationPtr getEnumeration() const
        {return getTemplateArgument(0).dynamicCast&lt;Enumeration&gt;();}
 
      virtual size_t getNumElements() const
        {return getEnumeration()-&gt;getNumElements() + 1;}

      virtual EnumerationElementPtr getElement(size_t index) const
      {
        EnumerationPtr enumeration = getEnumeration();
        if (index &lt; enumeration-&gt;getNumElements())
          return enumeration->getElement(index);
        else
          return new EnumerationElement(T("missing"), T("_"), String::empty, T("Missing Value"));
      }
      </code>
  </template>

  <template name="AddEntropyToEnumeration" metaclass="Enumeration">
    <parameter name="enumeration" type="EnumValue"/>
    <code>
      EnumerationPtr getEnumeration() const
        {return getTemplateArgument(0).dynamicCast&lt;Enumeration&gt;();}
 
      virtual size_t getNumElements() const
        {return getEnumeration()-&gt;getNumElements() + 1;}

      virtual EnumerationElementPtr getElement(size_t index) const
      {
        EnumerationPtr enumeration = getEnumeration();
        if (index &lt; enumeration-&gt;getNumElements())
          return enumeration->getElement(index);
        else
          return new EnumerationElement(T("entropy"), String::empty, String::empty, T("Entropy"));
      }
      </code>
  </template>

  <template name="VariablesEnumeration" metaclass="Enumeration">
    <parameter name="class" type="Object"/>
    <code>
      ClassPtr getTargetClass() const
        {return getTemplateArgument(0).dynamicCast&lt;Class&gt;();}
 
      virtual size_t getNumElements() const
        {return getTargetClass()-&gt;getNumMemberVariables();}

      virtual EnumerationElementPtr getElement(size_t index) const
      {
        VariableSignaturePtr variable = getTargetClass()-&gt;getMemberVariable(index);
        return new EnumerationElement(variable->getName(), String::empty, variable->getShortName(), variable->getDescription());
      }
    </code>
  </template>
  
  <enumeration name="Singleton">
    <value name="singleton" oneLetterCode="e"/>
  </enumeration>
  
  <enumeration name="ExistOrMissing">
    <value name="exist" oneLetterCode="e"/>
    <value name="missing" oneLetterCode="m"/>
  </enumeration>

  <enumeration name="FalseOrTrue">
    <value name="false" oneLetterCode="f"/>
    <value name="true" oneLetterCode="t"/>
  </enumeration>

  <enumeration name="FalseTrueOrMissing">
    <value name="false" oneLetterCode="f"/>
    <value name="true" oneLetterCode="t"/>
    <value name="missing" oneLetterCode="m"/>
  </enumeration>
  
  <class name="PositiveIntegerEnumeration" metaclass="Enumeration">
    <code>
      virtual size_t getNumElements() const
        {return 0;}
      virtual EnumerationElementPtr getElement(size_t index) const
        {String str((int)index); return new EnumerationElement(str, String::empty, str);}
      virtual int findElementByName(const String&amp; name) const
        {return name.getIntValue();}
      virtual String toString(const VariableValue&amp; value) const
        {return String(value.getInteger());}
      virtual VariableValue getMissingValue() const
        {return VariableValue(-1);}
    </code>
  </class>
  
  <template name="CartesianProductEnumeration" metaclass="Enumeration">
    <parameter name="firstEnumeration" type="EnumValue"/>
    <parameter name="secondEnumeration" type="EnumValue"/>
    <code>
      EnumerationPtr getFirstEnumeration() const
        {return getTemplateArgument(0).dynamicCast&lt;Enumeration&gt;();}
      
      EnumerationPtr getSecondEnumeration() const
        {return getTemplateArgument(1).dynamicCast&lt;Enumeration&gt;();}
 
      virtual size_t getNumElements() const
        {return getFirstEnumeration()-&gt;getNumElements() * getSecondEnumeration()-&gt;getNumElements();}

      virtual EnumerationElementPtr getElement(size_t index) const
      {
        if (index &gt;= getNumElements())
          return new EnumerationElement(T("missing"), T("_"), String::empty, T("Missing Value"));

        EnumerationPtr firstEnumeration = getFirstEnumeration();
        EnumerationPtr secondEnumeration = getSecondEnumeration();
        size_t numSecondElements = secondEnumeration-&gt;getNumElements();
        EnumerationElementPtr firstElement = firstEnumeration->getElement(index / numSecondElements);
        EnumerationElementPtr secondElement = secondEnumeration->getElement(index % numSecondElements);

        return new EnumerationElement(T("(") + firstElement-&gt;getName() + T(", ") + secondElement-&gt;getName() + T(")"),
                                      String::empty,
                                      firstElement-&gt;getShortName() + T("x") + secondElement-&gt;getShortName(),
                                      T("Cartesian Product (") + firstElement-&gt;getDescription() +
                                            T(", ") + secondElement-&gt;getDescription() + T(")"));
      }
      </code>
  </template>

  <!-- XmlElement -->
  <class name="XmlElement" base="Object">
    <variable type="NewString" name="tagName"/>
    <variable type="ObjectVector[XmlElement]" name="childElements"/>
    <variable type="ObjectVector[Pair[NewString, NewString]]" name="attributes"/>
    <variable type="NewString" name="text"/>
  </class>

</library>
